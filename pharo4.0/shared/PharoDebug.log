THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MessageTally>>withDeepCollect:
20 October 2015 5:12:29.969833 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
	Receiver: UndefinedObject(ProtoObject) >> ~~
	Arguments and temporary variables: 
		aMessage: 	withDeepCollect: #children
		exception: 	MessageNotUnderstood: MessageTally>>withDeepCollect:
		resumeValue: 	nil
	Receiver's instance variables: 
		class: 	UndefinedObject
		method: 	ProtoObject>>#'~~'
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	66
		receivers: 	#()
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


MessageTally>>gtInspectorMessageTreeIn:
	Receiver: UndefinedObject(ProtoObject) >> ~~
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=243531776 title=nil pane=a GLMPane(144...etc...
		methods: 	nil
		normalizer: 	nil
	Receiver's instance variables: 
		class: 	UndefinedObject
		method: 	ProtoObject>>#'~~'
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	66
		receivers: 	#()
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
	Receiver: UndefinedObject(ProtoObject) >> ~~
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=243531776 title=nil pane=a GLMPane(144...etc...
		aGTInspector: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLM...etc...
		pragmas: 	an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOr...etc...
		eachPragma: 	<gtInspectorPresentationOrder: 40>
	Receiver's instance variables: 
		class: 	UndefinedObject
		method: 	ProtoObject>>#'~~'
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	66
		receivers: 	#()
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOrder: 40> <gtInspecto...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue:...etc...
		index: 	2
	Receiver's instance variables: 
an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOrder: 40> <gtInspecto...etc...

MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
	Receiver: UndefinedObject(ProtoObject) >> ~~
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=243531776 title=nil pane=a GLMPane(144...etc...
		aGTInspector: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLM...etc...
		pragmas: 	an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOr...etc...
	Receiver's instance variables: 
		class: 	UndefinedObject
		method: 	ProtoObject>>#'~~'
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	66
		receivers: 	#()
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=806092800 title=a MessageTally (UndefinedObjec...etc...
		each: 	UndefinedObject(ProtoObject) >> ~~
		x: 	UndefinedObject(ProtoObject) >> ~~
		d: 	a GLMCompositePresentation(id=375390208 title=nil pane=a GLMPane(1024458752 ...etc...
	Receiver's instance variables: 
a RTExampleBrowser

GLMCompositePresentation(GLMPresentation)>>with:
	Receiver: a GLMCompositePresentation(id=375390208 title=nil pane=a GLMPane(1024458752 root))
	Arguments and temporary variables: 
		aBlock: 	[ :d | each gtInspectorPresentationsIn: d inContext: pager ]
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(1024458752 root)
		title: 	nil
		titleIcon: 	nil
		transformation: 	nil
		actions: 	nil
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentations: 	an OrderedCollection(a GTObjectVariablesBrowser(id=788004864 tit...etc...
		arrangement: 	nil


[ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=806092800 title=a MessageTally (UndefinedObjec...etc...
		each: 	UndefinedObject(ProtoObject) >> ~~
		x: 	UndefinedObject(ProtoObject) >> ~~
	Receiver's instance variables: 
a RTExampleBrowser

BlockClosure>>glamourValueWithArgs:
	Receiver: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inCon...etc...
	Arguments and temporary variables: 
		anArray: 	an Array(UndefinedObject(ProtoObject) >> ~~)
	Receiver's instance variables: 
		outerContext: 	[ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: eac...etc...
		startpc: 	167
		numArgs: 	1


BlockClosure(Object)>>glamourValue:
	Receiver: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inCon...etc...
	Arguments and temporary variables: 
		anObject: 	UndefinedObject(ProtoObject) >> ~~
		args: 	an Array(UndefinedObject(ProtoObject) >> ~~)
	Receiver's instance variables: 
		outerContext: 	[ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: eac...etc...
		startpc: 	167
		numArgs: 	1


GLMDynamicPresentation(GLMPresentation)>>displayValue
	Receiver: a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(578289664 4))
	Arguments and temporary variables: 

	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(578289664 4)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=934805504 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMDynamicPresentation>>currentPresentation
	Receiver: a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(578289664 4))
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=251133952 title=nil pane=a GLMPane(131...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(578289664 4)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=934805504 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMMorphicDynamicRenderer>>render:
	Receiver: a GLMMorphicDynamicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(5...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(152829952)


GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicDynamicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(5...etc...
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicWidgetRenderer
		methodDict: 	a MethodDictionary(#actOnPresentationUpdated:->GLMMorphicDynamicRen...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#container)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicDynamicRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderDynamicPresentation:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(5...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMDynamicPresentation>>renderGlamorouslyOn:
	River: a GLMDynamicPresentation(id=269484032 title=nil pane=a GLMPane(452460544 5))
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(452460544 5)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=766771200 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMDynamicPresentation(id=269484032 title=nil pane=a GLMPane(452...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMDynamicPresentation(id=269484032 title=nil pane=a GLMPane(452460...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=269484032 title=nil pane=a GLMPane(4...etc...
		morph: 	nil
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer>>render:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMCompositePresentation(id=137101312 title=a MessageTally (Un...etc...
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicCompositeRenderer
		methodDict: 	a MethodDictionary(#actOnContextChanged:->GLMMorphicTabbedRenderer>...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#tabs)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicTabbedRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderTabbedCompositePresentation:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aCompositePresentation: 	a GLMCompositePresentation(id=137101312 title=a Message...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMTabbedArrangement>>renderGlamorouslyOn:
	Receiver: a GLMTabbedArrangement
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		composite: 	a GLMCompositePresentation(id=137101312 title=a MessageTally (Undefi...etc...


GLMCompositePresentation>>renderGlamorouslyOn:
	Receiver: a GLMCompositePresentation(id=137101312 title=a MessageTally (UndefinedObject(ProtoObject)...etc...
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
er
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(578289664 4)
		title: 	[ GTInspector new printObjectAsAnItem: each ]
		titleIcon: 	nil
		transformation: 	nil
		actions: 	nil
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	[ :aPresentation | each gtInspectorActions asOrderedCollec...etc...
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	a GLMCompositePresentation(id=806092800 title=a MessageTally (...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentations: 	an OrderedCollection(a GLMDynamicPresentation(id=467664896 title...etc...
		arrangement: 	a GLMTabbedArrangement


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMCompositePresentation(id=335282176 title=a MessageTally (Unde...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMCompositePresentation(id=335282176 title=a MessageTally (Undefin...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(1018691584)
		contentMorph: 	nil


GLMMorphicPaneRenderer>>renderContainerFor:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(1018691584)
		contentMorph: 	nil


GLMMorphicPaneRenderer>>render:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(1018691584)
		contentMorph: 	nil


GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMPane(578289664 4)
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicWidgetRenderer
		methodDict: 	a MethodDictionary(#actOnMatchingPresentationChanged:->GLMMorphicPa...etc...
		format: 	136
		layout: 	a FixedLayout
		instanceVariables: 	#(#container #contentMorph)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicPaneRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderPane:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMPane>>renderGlamorouslyOn:
	Receiver: a GLMPane(578289664 4)
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		browser: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(...etc...
		name: 	'4'
		presentations: 	a GLMCompositePresentation(id=335282176 title=a MessageTally (Un...etc...
		ports: 	an OrderedCollection(Port (pane='4' name=#activePresentation value=nil) ...etc...
		lastActivePresentation: 	nil
		allowedToNotePresentationsChanged: 	true
		cachedMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=4...etc...


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


GLMMorphicPagerRenderer>>actOnPaneAdded:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		ann: 	a GLMPaneAdded
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


MessageSend>>value:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		anObject: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg1: 	a GLMPaneAdded
		arg2: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(675...etc...
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a GLMPaneAdded
	Receiver's instance variables: 
		announcer: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPan...etc...
		announcementClass: 	GLMPaneAdded
		subscriber: 	a GLMMorphicPagerRenderer
		action: 	MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
MessageTally>>gtInspectorMessageTreeIn:
[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
Array(SequenceableCollection)>>do:
MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
GLMCompositePresentation(GLMPresentation)>>with:
[ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
BlockClosure>>glamourValueWithArgs:
BlockClosure(Object)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
GLMMorphicDynamicRenderer>>render:
GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderDynamicPresentation:
GLMDynamicPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GLMCompositePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPaneRenderer>>renderContainerFor:
GLMMorphicPaneRenderer>>render:
GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPane:
GLMPane>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPagerRenderer>>actOnPaneAdded:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MessageTally>>withDeepCollect:
20 October 2015 5:13:02.437839 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
	Receiver: LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Arguments and temporary variables: 
		aMessage: 	withDeepCollect: #children
		exception: 	MessageNotUnderstood: MessageTally>>withDeepCollect:
		resumeValue: 	nil
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


MessageTally>>gtInspectorMessageTreeIn:
	Receiver: LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(101...etc...
		methods: 	nil
		normalizer: 	nil
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
	Receiver: LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(101...etc...
		aGTInspector: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLM...etc...
		pragmas: 	an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOr...etc...
		eachPragma: 	<gtInspectorPresentationOrder: 40>
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOrder: 40> <gtInspecto...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue:...etc...
		index: 	2
	Receiver's instance variables: 
an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOrder: 40> <gtInspecto...etc...

MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
	Receiver: LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(101...etc...
		aGTInspector: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLM...etc...
		pragmas: 	an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOr...etc...
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=629407744 title=a MessageTally (LazyMorphListM...etc...
		each: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		x: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		d: 	a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(1016594432 ...etc...
	Receiver's instance variables: 
a RTExampleBrowser

GLMCompositePresentation(GLMPresentation)>>with:
	Receiver: a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(1016594432 root))
	Arguments and temporary variables: 
		aBlocationOr...etc...
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=689700864 title=a MessageTally (LazyMorphListM...etc...
		each: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		x: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		d: 	a GLMCompositePresentation(id=228851712 title=nil pane=a GLMPane(871890944 r...etc...
	Receiver's instance variables: 
a RTExampleBrowser

GLMCompositePresentation(GLMPresentation)>>with:
	Receiver: a GLMCompositePresentation(id=228851712 title=nil pane=a GLMPane(871890944 root))
	Arguments and temporary variables: 
		aBlock: 	[ :d | each gtInspectorPresentationsIn: d inContext: pager ]
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(871890944 root)
		title: 	nil
		titleIcon: 	nil
		transformation: 	nil
		actions: 	nil
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentations: 	an OrderedCollection(a GTObjectVariablesBrowser(id=647495680 tit...etc...
		arrangement: 	nil


[ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=689700864 title=a MessageTally (LazyMorphListM...etc...
		each: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		x: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Receiver's instance variables: 
a RTExampleBrowser

BlockClosure>>glamourValueWithArgs:
	Receiver: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inCon...etc...
	Arguments and temporary variables: 
		anArray: 	an Array(LazyMorphListMorph(LazyMorphListMorph) >> listChanged)
	Receiver's instance variables: 
		outerContext: 	[ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: eac...etc...
		startpc: 	167
		numArgs: 	1


BlockClosure(Object)>>glamourValue:
	Receiver: [ :x | (GLMCompositePresennsformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMDynamicPresentation>>currentPresentation
	Receiver: a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(486014976 4))
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=207093760 title=nil pane=a GLMPane(650...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(486014976 4)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=782237696 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMMorphicDynamicRenderer>>render:
	Receiver: a GLMMorphicDynamicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(4...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(102760448)


GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicDynamicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(4...etc...
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicWidgetRenderer
		methodDict: 	a MethodDictionary(#actOnPresentationUpdated:->GLMMorphicDynamicRen...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#container)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicDynamicRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderDynamicPresentation:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(4...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMDynamicPresentation>>renderGlamorouslyOn:
	Receiver: a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(486014976 4))
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(486014976 4)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=782237696 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(486...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(486014...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(4...etc...
		morph: 	nil
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer>>render:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (La...etc...
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicCompositeRenderer
		methodDict: 	a MethodDictionary(#actOnContextChanged:->GLMMorphicTabbedRenderer>...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#tabs)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicTabbedRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderTabbedCompositePresentation:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aCompositePresentation: 	a GLMCompositePresentation(id=212860928 title=a Message...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMTabbedArrangement>>renderGlamorouslyOn:
	Receiver: a GLMTabbedArrangement
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		composite: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (LazyMo...etc...


GLMCompositePresentation>>renderGlamorouslyOn:
	Receiver: a GLMCompositePresentation(id=212860928 title=a MessageTally (LazyMorphListMorph>>#listCha...etc...
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(486014976 4)
		title: 	[ GTInspector new printObjectAsAnItem: each ]
		titleIcon: 	nil
		transformation: 	nil
		actions: 	nil
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	[ :aPresentation | each gtInspectorActions asOrderedCollec...etc...
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	a GLMCompositePresentation(id=629407744 title=a MessageTally (...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentations: 	an OrderedCollection(a GLMDynamicPresentation(id=339214336 title...etc...
		arrangement: 	a GLMTabbedArrangement


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (Lazy...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (LazyMor...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(938475520)
		contentMorph: 	nil


GLMMorphicPaneRenderer>>renderContainerFor:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(938475520)
		contentMorph: 	nil


GLMMorphicPaneRenderer>>render:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(938475520)
		contentMorph: 	nil


GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMPane(486014976 4)
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicWidgetRenderer
		methodDict: 	a MethodDictionary(#actOnMatchingPresentationChanged:->GLMMorphicPa...etc...
		format: 	136
		layout: 	a FixedLayout
		instanceVariables: 	#(#container #contentMorph)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicPaneRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderPane:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMPane>>renderGlamorouslyOn:
	Receiver: a GLMPane(486014976 4)
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		browser: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(...etc...
		name: 	'4'
		presentations: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (La...etc...
		ports: 	an OrderedCollection(Port (pane='4' name=#activePresentation value=nil) ...etc...
		lastActivePresentation: 	nil
		allowedToNotePresentationsChanged: 	true
		cachedMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=3...etc...


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


GLMMorphicPagerRenderer>>actOnPaneAdded:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		ann: 	a GLMPaneAdded
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


MessageSend>>value:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		anObject: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:
	Recinstance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		browser: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(...etc...
		name: 	'5'
		presentations: 	a GLMCompositePresentation(id=164626432 title=a MessageTally (La...etc...
		ports: 	an OrderedCollection(Port (pane='5' name=#activePresentation value=nil) ...etc...
		lastActivePresentation: 	nil
		allowedToNotePresentationsChanged: 	true
		cachedMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=2...etc...


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMPane(528220160 5)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMPane(528220160 5)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


GLMMorphicPagerRenderer>>actOnPaneAdded:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		ann: 	a GLMPaneAdded
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


MessageSend>>value:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		anObject: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg1: 	a GLMPaneAdded
		arg2: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(675...etc...
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a GLMPaneAdded
	Receiver's instance variables: 
		announcer: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPan...etc...
		announcementClass: 	GLMPaneAdded
		subscriber: 	a GLMMorphicPagerRenderer
		action: 	MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
MessageTally>>gtInspectorMessageTreeIn:
[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
Array(SequenceableCollection)>>do:
MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsInslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPagerRenderer>>actOnPaneAdded:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


MessageSend>>value:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		anObject: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg1: 	a GLMPaneAdded
		arg2: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(675...etc...
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a GLMPaneAdded
	Receiver's instance variables: 
		announcer: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPan...etc...
		announcementClass: 	GLMPaneAdded
		subscriber: 	a GLMMorphicPagerRenderer
		action: 	MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
MessageTally>>gtInspectorMessageTreeIn:
[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
Array(SequenceableCollection)>>do:
MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
GLMCompositePresentation(GLMPresentation)>>with:
[ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
BlockClosure>>glamourValueWithArgs:
BlockClosure(Object)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
GLMMorphicDynamicRenderer>>render:
GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderDynamicPresentation:
GLMDynamicPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GLMCompositePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPaneRenderer>>renderContainerFor:
GLMMorphicPaneRenderer>>render:
GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPane:
GLMPane>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPagerRenderer>>actOnPaneAdded:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: TRConstraint class>>stick:onTheBottomLeftOf:
22 October 2015 3:36:40.686015 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

TRConstraint class(Object)>>doesNotUnderstand: #stick:onTheBottomLeftOf:
	Receiver: TRConstraint
	Arguments and temporary variables: 
		aMessage: 	stick: a TRLabelShape onTheBottomLeftOf: a TRArcShape
		exception: 	MessageNotUnderstood: TRConstraint class>>stick:onTheBottomLeftOf:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TRObject
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TRConstraint
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Trachel-Core'
		traitComposition: 	{}
		localSelectors: 	nil


RTLabelled>>initializeElement:
	Receiver: a RTLabelled
	Arguments and temporary variables: 
		element: 	a RTElement
		s: 	a TRArcShape
		t: 	1
		callback: 	a TRRemoveCallback
	Receiver's instance variables: 
		canvas: 	a TRCanvas
		color: 	Color gray
		highlightable: 	false
		lbl: 	a TRLabelShape
		lowColor: 	Color veryVeryLightGray
		offsetOnEdge: 	0.5
		position: 	#bottomLeft
		text: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		fontSize: 	12


RTElement(RTAnnounceableObject)>>addInteraction:
	Receiver: a RTElement
	Arguments and temporary variables: 
		anInteractionClassOrInstance: 	a RTLabelled
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	a Dictionary(#RTLabelledCallback->a TRRemoveCallback #RTLabelledLab...etc...
		isFixed: 	false
		model: 	1
		shape: 	a RTArc
		trachelShape: 	a TRArcShape
		view: 	a RTView
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTElement(RTAnnounceableObject)>>@
	Receiver: a RTElement
	Arguments and temporary variables: 
		anInteractionClassOrInstance: 	a RTLabelled
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	a Dictionary(#RTLabelledCallback->a TRRemoveCallback #RTLabelledLab...etc...
		isFixed: 	false
		model: 	1
		shape: 	a RTArc
		trachelShape: 	a TRArcShape
		view: 	a RTView
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


[ :e | e @ interaction ] in RTGroup>>@
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		interaction: 	a RTLabelled
		e: 	a RTElement
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	10
		attributes: 	nil


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | e @ interaction ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	10
		attributes: 	nil


RTGroup>>@
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		interaction: 	a RTLabelled
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	10
		attributes: 	nil


RTRoassalExample>>exampleArc
	Receiver: a RTRoassalExample
	Arguments and temporary variables: 
		view: 	a RTView
		shape: 	a RTArc
		label: 	a RTLabelled
	Receiver's instance variables: 
a RTRoassalExample

RTExampleSelection(GTExample)>>result
	Receiver: a RTExampleSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		result: 	nil
		title: 	nil
		provider: 	a RTRoassalExample
		selector: 	#exampleArc
		parentExample: 	nil
		extractionStrategy: 	nil


[ :example | example result ] in RTRoassalExample(RTAbstractExample)>>gtInspectorPreviewIn:
	Receiver: a RTRoassalExample
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=258473984 title=nil pane=a GLMPane(478...etc...
		example: 	a RTExampleSelection
	Receiver's instance variables: 
a RTRoassalExample

BlockClosure>>glamourValueWithArgs:
	Receiver: [ :example | example result ]
	Arguments and temporary variables: 
		anArray: 	an Array(a RTExampleSelection)
	Receiver's instance variables: 
		outerContext: 	RTRoassalExample(RTAbstractExample)>>gtInspectorPreviewIn:
		startpc: 	79
		numArgs: 	1


BlockClosure(Object)>>glamourValue:
	Receiver: [ :example | example result ]
	Arguments and temporary variables: 
		anObject: 	a RTExampleSelection
		args: 	an Array(a RTExampleSelection)
	Receiver's instance variables: 
		outerContext: 	RTRoassalExample(RTAbstractExample)>>gtInspectorPreviewIn:
		startpc: 	79
		numArgs: 	1


GLMTransmission>>value
	Receiver: GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 757858304 (name=#...etc...
	Arguments and temporary variables: 
		originalValue: 	a RTExampleSelection
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		context: 	nil
		destination: 	a GLMPresentationBoundPort 794558464 (name=#selection value=a RTVi...etc...
		browser: 	nil
		origins: 	an OrderedCollection(a GLMOriginPortReference 793247744 (a GLMPresenta...etc...
		transmissionStrategy: 	a GLMNoStrategy
		transformation: 	[ :example | example result ]
		condition: 	true


GLMPanePort>>receive:in:
	Receiver: Port (pane='2' name=#selection value=a RTView)
	Arguments and temporary variables: 
		aTransmission: 	GLMTransmission (origins=an OrderedCollection(a GLMPresentationB...etc...
		aContext: 	a GLMTransmissionContext(nil)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		name: 	#selection
		pane: 	a GLMPane(478937088 2)
		value: 	a RTView


GLMPresentationBoundPort>>receive:in:
	Receiver: a GLMPresentationBoundPort 794558464 (name=#selection value=a RTView)
	Arguments and temporary variables: 
		aTransmission: 	GLMTransmission (origins=an OrderedCollection(a GLMPresentationB...etc...
		aContext: 	a GLMTransmissionContext(nil)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		name: 	#selection
		presentation: 	a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMP...etc...


[ 
self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn:
	Receiver: GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 757858304 (name=#...etc...
	Arguments and temporary variables: 
		aContext: 	a GLMTransmissionContext(nil)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		context: 	nil
		destination: 	a GLMPresentationBoundPort 794558464 (name=#selection value=a RTVi...etc...
		browser: 	nil
		origins: 	an OrderedCollection(a GLMOriginPortReference 793247744 (a GLMPresenta...etc...
		transmissionStrategy: 	a GLMNoStrategy
		transformation: 	[ :example | example result ]
		condition: 	true


GLMPane>>notingPresentationChangeDo:
	Receiver: a GLMPane(478937088 2)
	Arguments and temporary variables: 
		aBlock: 	[ 
self transmissionStrategy transmitIn: aContext.
self destination rec...etc...
		oldPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=350224384 ti...etc...
		oldMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=3502...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		browser: 	a GLMPager(id=108003328 title=Roassal examples browser pane=a GLMPane(...etc...
		name: 	'2'
		presentations: 	a GLMCompositePresentation(id=217841664 title=a RTRoassalExample...etc...
		ports: 	an OrderedCollection(Port (pane='2' name=#activePresentation value=nil) ...etc...
		lastActivePresentation: 	nil
		allowedToNotePresentationsChanged: 	false
		cachedMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=3...etc...


GLMPresentationBoundPort(GLMBoundPort)>>notingPresentationChangeDo:
	Receiver: a GLMPresentationBoundPort 794558464 (name=#selection value=a RTView)
	Arguments and temporary variables: 
		aBlock: 	[ 
self transmissionStrategy transmitIn: aContext.
self destination rec...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		name: 	#selection
		presentation: 	a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMP...etc...


GLMTransmission>>transmitIn:
	Receiver: GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 757858304 (name=#...etc...
	Arguments and temporary variables: 
		aContext: 	a GLMTransmissionContext(nil)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		context: 	nil
		destination: 	a GLMPresentationBoundPort 794558464 (name=#selection value=a RTVi...etc...
		browser: 	nil
		origins: 	an OrderedCollection(a GLMOriginPortReference 793247744 (a GLMPresenta...etc...
		transmissionStrategy: 	a GLMNoStrategy
		transformation: 	[ :example | example result ]
		condition: 	true


GLMTransmission>>transmit
	Receiver: GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 757858304 (name=#...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		context: 	nil
		destination: 	a GLMPresentationBoundPort 794558464 (name=#selection value=a RTVi...etc...
		browser: 	nil
		origins: 	an OrderedCollection(a GLMOriginPortReference 793247744 (a GLMPresenta...etc...
		transmissionStrategy: 	a GLMNoStrategy
		transformation: 	[ :example | example result ]
		condition: 	true


ByteSymbol(Symbol)>>value:
	Receiver: #transmit
	Arguments and temporary variables: 
		anObject: 	GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundP...etc...
	Receiver's instance variables: 
#transmit

IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 75...etc...
	Arguments and temporary variables: 
		aBlock: 	#transmit
		index: 	1
		each: 	GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort ...etc...
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(GLMTransmission (origins=an OrderedCollection(a GLMPresentation...etc...


GLMRoassal2Presentation(GLMPresentation)>>selection:
	Receiver: a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMPane(478937088 2))
	Arguments and temporary variables: 
		anObject: 	a RTExampleSelection
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(478937088 2)
		title: 	'Examples'
		titleIcon: 	nil
		transformation: 	nil
		actions: 	an OrderedCollection(a GLMGenericAction a GLMGenericAction a GLMGeneri...etc...
		condition: 	[ self gtExamples notEmpty ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	true
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>roassal2
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		painting: 	nil
		paintingBlock: 	[ :view | 
view @ RTDraggableView.
self gtOpenOn: view ]
		view: 	a RTView
		shouldPopulateSelection: 	true
		newViewBlock: 	[ RTView new ]


[ :event | self selection: each model ] in [ :each | each when: TRMouseLeftClick do: [ :event | self selection: each model ] ] in GLMRoassal2Presentation>>renderOn:
	Receiver: a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMPane(478937088 2))
	Arguments and temporary variables: 
		aView: 	a RTView
		each: 	a RTElement
		event: 	a TRMouseLeftClick
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(478937088 2)
		title: 	'Examples'
		titleIcon: 	nil
		transformation: 	nil
		actions: 	an OrderedCollection(a GLMGenericAction a GLMGenericAction a GLMGeneri...etc...
		condition: 	[ self gtExamples notEmpty ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	true
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>roassal2
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		painting: 	nil
		paintingBlock: 	[ :view | 
view @ RTDraggableView.
self gtOpenOn: view ]
		view: 	a RTView
		shouldPopulateSelection: 	true
		newViewBlock: 	[ RTView new ]


BlockClosure>>cull:
	Receiver: [ :event | self selection: each model ]
	Arguments and temporary variables: 
		anArg: 	a TRMouseLeftClick
	Receiver's instance variables: 
		outerContext: 	[ :each | each when: TRMouseLeftClick do: [ :event | self selecti...etc...
		startpc: 	107
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :event | self selection: each model ]
	Arguments and temporary variables: 
		firstArg: 	a TRMouseLeftClick
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	[ :each | each when: TRMouseLeftClick do: [ :event | self selecti...etc...
		startpc: 	107
		numArgs: 	1


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseLeftClick
		subscriber: 	a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMPan...etc...
		action: 	[ :event | self selection: each model ]


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		copy: 	nil
		onDoCtx: 	nil
		process: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
TRConstraint class(Object)>>doesNotUnderstand: #stick:onTheBottomLeftOf:
RTLabelled>>initializeElement:
RTElement(RTAnnounceableObject)>>addInteraction:
RTElement(RTAnnounceableObject)>>@
[ :e | e @ interaction ] in RTGroup>>@
RTGroup(OrderedCollection)>>do:
RTGroup>>@
RTRoassalExample>>exampleArc
RTExampleSelection(GTExample)>>result
[ :example | example result ] in RTRoassalExample(RTAbstractExample)>>gtInspectorPreviewIn:
BlockClosure>>glamourValueWithArgs:
BlockClosure(Object)>>glamourValue:
GLMTransmission>>value
GLMPanePort>>receive:in:
GLMPresentationBoundPort>>receive:in:
[ 
self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn:
GLMPane>>notingPresentationChangeDo:
GLMPresentationBoundPort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
GLMTransmission>>transmit
ByteSymbol(Symbol)>>value:
IdentitySet(Set)>>do:
GLMRoassal2Presentation(GLMPresentation)>>selection:
[ :event | self selection: each model ] in [ :each | each when: TRMouseLeftClick do: [ :event | self selection: each model ] ] in GLMRoassal2Presentation>>renderOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: HideWindow>>hideButton
26 November 2015 4:32:46.680323 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow(Object)>>doesNotUnderstand: #hideButton
	Receiver: a HideWindow
	Arguments and temporary variables: 
		aMessage: 	hideButton
		exception: 	MessageNotUnderstood: HideWindow>>hideButton
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	nil
		showButton: 	nil


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#hideButton
		args: 	#()
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#hideButton
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #hideButton)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. ...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0....etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0....etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. ...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayou...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayout...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutF...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFract...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFract...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayout...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSea...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSear...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearc...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearch). #layout:. {#...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearch). #layout:. {#...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSear...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a HideWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a HideWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
HideWindow(Object)>>doesNotUnderstand: #hideButton
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
HideWindow(ComposableModel)>>adapterFrom:model:
HideWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
HideWindow(ComposableModel)>>openWithSpecLayout:
HideWindow(ComposableModel)>>openWithSpec:
HideWindow(ComposableModel)>>openWithSpec
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: HideWindow>>hideButton
26 November 2015 4:33:38.535615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow(Object)>>doesNotUnderstand: #hideButton
	Receiver: a HideWindow
	Arguments and temporary variables: 
		aMessage: 	hideButton
		exception: 	MessageNotUnderstood: HideWindow>>hideButton
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#hideButton
		args: 	#()
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#hideButton
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #hideButton)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. ...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0....etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0....etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. ...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayou...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayout...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutF...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFract...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFract...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayout...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSea...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSear...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearc...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearch). #layout:. {#...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearch). #layout:. {#...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSear...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a HideWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a HideWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
HideWindow(Object)>>doesNotUnderstand: #hideButton
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
HideWindow(ComposableModel)>>adapterFrom:model:
HideWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
HideWindow(ComposableModel)>>openWithSpecLayout:
HideWindow(ComposableModel)>>openWithSpec:
HideWindow(ComposableModel)>>openWithSpec
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 4:38:58.935615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
a := hideMenu multiSelection.
self halt ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu multiSelection.
self halt ] ]
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(574881792))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(574881792)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		event: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		evt: 	[(1462@402) mouseUp 881604 nil]
		all: 	an Array(a PluggableButtonMorph(574881792) a PluggableButtonMorph(56675532...etc...
		m: 	a PluggableButtonMorph(574881792)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(574881792) a PluggableButtonMorph(566755328))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(574881792) a PluggableButtonMorph(566755328))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		evt: 	[(1462@402) mouseUp 881604 nil]
		all: 	an Array(a PluggableButtonMorph(574881792) a PluggableButtonMorph(56675532...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


MouseButtonEvent>>sentTo:
	Receiver: [(1462@402) mouseUp 881604 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(574881792)
	Receiver's instance variables: 
		timeStamp: 	881604
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1462@402)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		focusHolder: 	a PluggableButtonMorph(574881792)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1462@402) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(860094464) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		focusHolder: 	a PluggableButtonMorph(574881792)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		focusHolder: 	a PluggableButtonMorph(574881792)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		evt: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1462@402) mouseUp 881604 nil]
		evtBuf: 	#(1 881604 1462 402 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	881780
		lastStepMessage: 	nil
		lastCycleTime: 	881780
		alarms: 	a Heap()
		lastAlarmTime: 	881780
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	881780
		lastStepMessage: 	nil
		lastCycleTime: 	881780
		alarms: 	a Heap()
		lastAlarmTime: 	881780
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	881780
		lastStepMessage: 	nil
		lastCycleTime: 	881780
		alarms: 	a Heap()
		lastAlarmTime: 	881780
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	881780
		lastStepMessage: 	nil
		lastCycleTime: 	881780
		alarms: 	a Heap()
		lastAlarmTime: 	881780
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(860094464) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
a := hideMenu multiSelection.
self halt ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MultiColumnListModel>>selectItems
26 November 2015 4:40:38.437617 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

MultiColumnListModel(Object)>>doesNotUnderstand: #selectItems
	Receiver: a MultiColumnListModel
	Arguments and temporary variables: 
		aMessage: 	selectItems
		exception: 	MessageNotUnderstood: MultiColumnListModel>>selectItems
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicMultiColumnListAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self clickOnSelectedItem...etc...
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'List' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		selectionHolder: 	a SelectionValueHolder[ an Array(a NewValueHolder[ 4 ] a NewVa...etc...
		listHolder: 	a CollectionValueHolder[ an OrderedCollection(a Node a Node a Node ...etc...
		menuHolder: 	a NewValueHolder[ [ :m :s | self menu: m shifted: s ] ]
		shortcutsHolder: 	nil
		multiSelectionHolder: 	a DictionaryValueHolder[ an IdentityDictionary(3->false 4...etc...
		multiSelection: 	a NewValueHolder[ true ]
		allowToSelect: 	a NewValueHolder[ true ]
		listItemsCache: 	an OrderedCollection(a Node a Node a Node a Node)
		filteringBlockHolder: 	a NewValueHolder[ [ :col | col ] ]
		sortingBlockHolder: 	a NewValueHolder[ [ :a :b | a objName < b objName ] ]
		wrapBlockHolder: 	a NewValueHolder[ [ :item | self wrapItem: item ] ]
		listAnnouncer: 	an Announcer
		backgroundColorBlock: 	a NewValueHolder[ [ :item :index | Smalltalk ui theme bac...etc...
		autoDeselect: 	a NewValueHolder[ true ]


[ 
a := hideMenu selectItems.
self halt ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectItems.
self halt ] ]
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(254017536))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(254017536)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		event: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		evt: 	[(1440@399) mouseUp 981204 nil]
		all: 	an Array(a PluggableButtonMorph(254017536) a PluggableButtonMorph(31064064...etc...
		m: 	a PluggableButtonMorph(254017536)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(254017536) a PluggableButtonMorph(310640640))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(254017536) a PluggableButtonMorph(310640640))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		evt: 	[(1440@399) mouseUp 981204 nil]
		all: 	an Array(a PluggableButtonMorph(254017536) a PluggableButtonMorph(31064064...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


MouseButtonEvent>>sentTo:
	Receiver: [(1440@399) mouseUp 981204 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(254017536)
	Receiver's instance variables: 
		timeStamp: 	981204
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1440@399)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		focusHolder: 	a PluggableButtonMorph(254017536)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1440@399) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(173539328) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		focusHolder: 	a PluggableButtonMorph(254017536)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		focusHolder: 	a PluggableButtonMorph(254017536)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		evt: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1440@399) mouseUp 981204 nil]
		evtBuf: 	#(1 981204 1440 399 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	981278
		lastStepMessage: 	nil
		lastCycleTime: 	981278
		alarms: 	a Heap()
		lastAlarmTime: 	981278
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	981278
		lastStepMessage: 	nil
		lastCycleTime: 	981278
		alarms: 	a Heap()
		lastAlarmTime: 	981278
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	981278
		lastStepMessage: 	nil
		lastCycleTime: 	981278
		alarms: 	a Heap()
		lastAlarmTime: 	981298
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	981298
		lastStepMessage: 	nil
		lastCycleTime: 	981298
		alarms: 	a Heap()
		lastAlarmTime: 	981298
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(173539328) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MultiColumnListModel(Object)>>doesNotUnderstand: #selectItems
[ 
a := hideMenu selectItems.
self halt ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 4:41:06.665617 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
a := hideMenu selectedItems.
self halt ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#(#('D' 'true'))
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems.
self halt ] ]
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(470548480))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(470548480)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		event: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		evt: 	[(1485@392) mouseUp 1009420 nil]
		all: 	an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424...etc...
		m: 	a PluggableButtonMorph(470548480)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		evt: 	[(1485@392) mouseUp 1009420 nil]
		all: 	an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


MouseButtonEvent>>sentTo:
	Receiver: [(1485@392) mouseUp 1009420 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(470548480)
	Receiver's instance variables: 
		timeStamp: 	1009420
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1485@392)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1485@392) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1042022400) a GLMSys...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		evt: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1485@392) mouseUp 1009420 nil]
		evtBuf: 	#(1 1009420 1485 392 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1009514
		lastStepMessage: 	nil
		lastCycleTime: 	1009514
		alarms: 	a Heap()
		lastAlarmTime: 	1009514
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1009514
		lastStepMessage: 	nil
		lastCycleTime: 	1009514
		alarms: 	a Heap()
		lastAlarmTime: 	1009514
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1009514
		lastStepMessage: 	nil
		lastCycleTime: 	1009514
		alarms: 	a Heap()
		lastAlarmTime: 	1009514
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1009514
		lastStepMessage: 	nil
		lastCycleTime: 	1009514
		alarms: 	a Heap()
		lastAlarmTime: 	1009514
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1042022400) a GLMSys...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
a := hideMenu selectedItems.
self halt ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 4:41:25.641618 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
a := hideMenu selectedItems.
self halt ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#(#('D' 'true') #('B' 'true') #('C' 'true'))
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems.
self halt ] ]
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(470548480))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(470548480)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		event: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		evt: 	[(1448@398) mouseUp 1028412 nil]
		all: 	an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424...etc...
		m: 	a PluggableButtonMorph(470548480)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		evt: 	[(1448@398) mouseUp 1028412 nil]
		all: 	an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


MouseButtonEvent>>sentTo:
	Receiver: [(1448@398) mouseUp 1028412 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(470548480)
	Receiver's instance variables: 
		timeStamp: 	1028412
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1448@398)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1448@398) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1042022400) a GLMSys...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		evt: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1448@398) mouseUp 1028412 nil]
		evtBuf: 	#(1 1028412 1448 398 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1028480
		lastStepMessage: 	nil
		lastCycleTime: 	1028480
		alarms: 	a Heap()
		lastAlarmTime: 	1028480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1028480
		lastStepMessage: 	nil
		lastCycleTime: 	1028480
		alarms: 	a Heap()
		lastAlarmTime: 	1028480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1028480
		lastStepMessage: 	nil
		lastCycleTime: 	1028480
		alarms: 	a Heap()
		lastAlarmTime: 	1028480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1028480
		lastStepMessage: 	nil
		lastCycleTime: 	1028480
		alarms: 	a Heap()
		lastAlarmTime: 	1028480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1042022400) a GLMSys...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
a := hideMenu selectedItems.
self halt ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "a" is nil
26 November 2015 4:42:37.535621 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #a
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	a
		exception: 	MessageNotUnderstood: receiver of "a" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')).

...etc...
		itsSelection: 	a Text for 'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''tr...etc...
		itsSelectionString: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	a := #(#('D' 'true') #('B' 'true') #('C' 'true')).
	^ first a
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(901513216)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(371982336)
		submorphs: 	an Array(a RubPrimarySelectionMorph(708050944) a RubCursor(225968128...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (299892736) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(333709312)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(225968128)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(74973184))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1100288
		lastStepMessage: 	nil
		lastCycleTime: 	1100310
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1100288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1100288
		lastStepMessage: 	nil
		lastCycleTime: 	1100310
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1100288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1100288
		lastStepMessage: 	nil
		lastCycleTime: 	1100310
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1100288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #a
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "a" is nil
26 November 2015 4:42:48.909615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #a
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	a
		exception: 	MessageNotUnderstood: receiver of "a" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ first a
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1111670
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 
		anArgument: 	1111674
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1111670
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1111674
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111734
		lastStepMessage: 	nil
		lastCycleTime: 	1111734
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111734
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		now: 	1111674
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111734
		lastStepMessage: 	nil
		lastCycleTime: 	1111734
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111734
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111734
		lastStepMessage: 	nil
		lastCycleTime: 	1111734
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111734
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111754
		lastStepMessage: 	nil
		lastCycleTime: 	1111754
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111754
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111754
		lastStepMessage: 	nil
		lastCycleTime: 	1111754
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111754
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #a
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "a" is nil
26 November 2015 4:43:11.405616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #a
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	a
		exception: 	MessageNotUnderstood: receiver of "a" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')).

...etc...
		itsSelection: 	a Text for 'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''tr...etc...
		itsSelectionString: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	a := #(#('D' 'true') #('B' 'true') #('C' 'true')).
	^ first a
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(901513216)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(371982336)
		submorphs: 	an Array(a RubPrimarySelectionMorph(708050944) a RubCursor(225968128...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (299892736) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(333709312)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(225968128)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(111411200))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SimpleBalloonMorph(46399488))(a Simp...etc...
		lastStepTime: 	1134178
		lastStepMessage: 	nil
		lastCycleTime: 	1134198
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1134178
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a SimpleBalloonMorph(46399488) a TaskbarMorph(984088576) a ...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SimpleBalloonMorph(46399488))(a Simp...etc...
		lastStepTime: 	1134178
		lastStepMessage: 	nil
		lastCycleTime: 	1134198
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1134178
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SimpleBalloonMorph(46399488))(a Simp...etc...
		lastStepTime: 	1134178
		lastStepMessage: 	nil
		lastCycleTime: 	1134198
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1134178
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a SimpleBalloonMorph(46399488) a TaskbarMorph(984088576) a ...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #a
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>elements
26 November 2015 4:49:48.091614 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>doesNotUnderstand: #elements
	Receiver: #(#('D' 'true') #('B' 'true') #('C' 'true'))
	Arguments and temporary variables: 
		aMessage: 	elements
		exception: 	MessageNotUnderstood: Array>>elements
		resumeValue: 	nil
	Receiver's instance variables: 
#(#('D' 'true') #('B' 'true') #('C' 'true'))

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')).

...etc...
		itsSelection: 	a Text for 'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''tr...etc...
		itsSelectionString: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	a := #(#('D' 'true') #('B' 'true') #('C' 'true')).
	b := OrderedColl...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(901513216)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (285@164)
		owner: 	a TransformWithLayoutMorph(371982336)
		submorphs: 	an Array(a RubPrimarySelectionMorph(951320576) a RubCursor(225968128...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (299892736) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(333709312)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(225968128)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(336592896))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1530872
		lastStepMessage: 	nil
		lastCycleTime: 	1530892
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1530872
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1530872
		lastStepMessage: 	nil
		lastCycleTime: 	1530892
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1530872
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1530872
		lastStepMessage: 	nil
		lastCycleTime: 	1530892
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1530872
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #elements
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>b
26 November 2015 4:50:08.395616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #b
	Receiver: [ :asd | b add: asd first ]
	Arguments and temporary variables: 
		aMessage: 	b
		exception: 	MessageNotUnderstood: BlockClosure>>b
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	53
		numArgs: 	1


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')).

...etc...
		itsSelection: 	a Text for 'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''tr...etc...
		itsSelectionString: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	a := #(#('D' 'true') #('B' 'true') #('C' 'true')).
	b := OrderedColl...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(901513216)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (285@145)
		owner: 	a TransformWithLayoutMorph(371982336)
		submorphs: 	an Array(a RubPrimarySelectionMorph(951320576) a RubCursor(225968128...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (299892736) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(333709312)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(225968128)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(749207552))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1551172
		lastStepMessage: 	nil
		lastCycleTime: 	1551192
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1551172
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1551172
		lastStepMessage: 	nil
		lastCycleTime: 	1551192
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1551172
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1551172
		lastStepMessage: 	nil
		lastCycleTime: 	1551192
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1551172
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #b
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>key
26 November 2015 4:52:00.363626 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>doesNotUnderstand: #key
	Receiver: #('D' 'true')
	Arguments and temporary variables: 
		aMessage: 	key
		exception: 	MessageNotUnderstood: Array>>key
		resumeValue: 	nil
	Receiver's instance variables: 
#('D' 'true')

[ :item | item key ] in Array>>DoIt
	Receiver: #(#('D' 'true') #('B' 'true') #('C' 'true'))
	Arguments and temporary variables: 
		item: 	#('D' 'true')
	Receiver's instance variables: 
#(#('D' 'true') #('B' 'true') #('C' 'true'))

Array(SequenceableCollection)>>collect:
	Receiver: #(#('D' 'true') #('B' 'true') #('C' 'true'))
	Arguments and temporary variables: 
		aBlock: 	[ :item | item key ]
		newCollection: 	#(nil nil nil)
		index: 	1
	Receiver's instance variables: 
#(#('D' 'true') #('B' 'true') #('C' 'true'))

Array>>DoIt
	Receiver: #(#('D' 'true') #('B' 'true') #('C' 'true'))
	Arguments and temporary variables: 

	Receiver's instance variables: 
#(#('D' 'true') #('B' 'true') #('C' 'true'))

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self collect: [ :item | item key ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	#(#('D' 'true') #('B' 'true') #('C' 'true'))
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	#(#('D' 'true') #('B' 'true') #('C' 'true'))
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(513015808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(513015808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(262144)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1663126
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 
		anArgument: 	1663136
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1663126
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1663136
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		now: 	1663136
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(220987392) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(220987392) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #key
[ :item | item key ] in Array>>DoIt
Array(SequenceableCollection)>>collect:
Array>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: HideWindow>>listChange:with:
26 November 2015 5:00:17.255619 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow(Object)>>doesNotUnderstand: #listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		aMessage: 	listChange: 'C' with: true
		exception: 	MessageNotUnderstood: HideWindow>>listChange:with:
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(11534336))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(11534336)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		event: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
		m: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


MouseButtonEvent>>sentTo:
	Receiver: [(1444@397) mouseUp 2160014 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		timeStamp: 	2160014
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1444@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseUp 2160014 nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1444@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(927727616) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseUp 2160014 nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseOver nil nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseOver nil nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		evt: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseOver nil nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		evtBuf: 	#(1 2160014 1444 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseOver nil nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(853016576))(a DropList...etc...
		lastStepTime: 	2160106
		lastStepMessage: 	nil
		lastCycleTime: 	2160104
		alarms: 	a Heap()
		lastAlarmTime: 	2160106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(853016576))(a DropList...etc...
		lastStepTime: 	2160106
		lastStepMessage: 	nil
		lastCycleTime: 	2160104
		alarms: 	a Heap()
		lastAlarmTime: 	2160106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(853016576))(a DropList...etc...
		lastStepTime: 	2160106
		lastStepMessage: 	nil
		lastCycleTime: 	2160104
		alarms: 	a Heap()
		lastAlarmTime: 	2160106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(853016576))(a DropList...etc...
		lastStepTime: 	2160106
		lastStepMessage: 	nil
		lastCycleTime: 	2160104
		alarms: 	a Heap()
		lastAlarmTime: 	2160106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(927727616) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow(Object)>>doesNotUnderstand: #listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteString>>equals:
26 November 2015 5:00:56.159614 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ByteString(Object)>>doesNotUnderstand: #equals:
	Receiver: 'A'
	Arguments and temporary variables: 
		aMessage: 	equals: 'C'
		exception: 	MessageNotUnderstood: ByteString>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
'A'

[ :item | item objName equals: nameObj ] in HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	nil
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :item | item objName equals: nameObj ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(11534336))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(11534336)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		event: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
		m: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


MouseButtonEvent>>sentTo:
	Receiver: [(1444@397) mouseUp 2160014 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		timeStamp: 	2160014
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1444@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1444@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		evt: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		evtBuf: 	#(1 2160014 1444 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	2199056
		lastStepMessage: 	nil
		lastCycleTime: 	2199056
		alarms: 	a Heap()
		lastAlarmTime: 	2199056
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	2199056
		lastStepMessage: 	nil
		lastCycleTime: 	2199056
		alarms: 	a Heap()
		lastAlarmTime: 	2199056
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	2199056
		lastStepMessage: 	nil
		lastCycleTime: 	2199056
		alarms: 	a Heap()
		lastAlarmTime: 	2199056
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	2199056
		lastStepMessage: 	nil
		lastCycleTime: 	2199056
		alarms: 	a Heap()
		lastAlarmTime: 	2199056
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #equals:
[ :item | item objName equals: nameObj ] in HideWindow>>listChange:with:
OrderedCollection>>select:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteString>>equals:
26 November 2015 5:01:46.119616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ByteString(Object)>>doesNotUnderstand: #equals:
	Receiver: 'A'
	Arguments and temporary variables: 
		aMessage: 	equals: 'C'
		exception: 	MessageNotUnderstood: ByteString>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
'A'

[ :item | item objName equals: nameObj ] in HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	nil
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :item | item objName equals: nameObj ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(11534336))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(11534336)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		event: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
		m: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


MouseButtonEvent>>sentTo:
	Receiver: [(1444@397) mouseUp 2160014 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		timeStamp: 	2160014
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1444@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1444@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		evt: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		evtBuf: 	#(1 2160014 1444 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(700973056))(a Spec...etc...
		lastStepTime: 	2248956
		lastStepMessage: 	nil
		lastCycleTime: 	2248950
		alarms: 	a Heap()
		lastAlarmTime: 	2248956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(700973056))(a Spec...etc...
		lastStepTime: 	2248956
		lastStepMessage: 	nil
		lastCycleTime: 	2248950
		alarms: 	a Heap()
		lastAlarmTime: 	2248956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(700973056))(a Spec...etc...
		lastStepTime: 	2248956
		lastStepMessage: 	nil
		lastCycleTime: 	2248950
		alarms: 	a Heap()
		lastAlarmTime: 	2248956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(700973056))(a Spec...etc...
		lastStepTime: 	2248956
		lastStepMessage: 	nil
		lastCycleTime: 	2248950
		alarms: 	a Heap()
		lastAlarmTime: 	2248956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #equals:
[ :item | item objName equals: nameObj ] in HideWindow>>listChange:with:
OrderedCollection>>select:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:02:13.35162 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	an OrderedCollection(a Node)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(11534336))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(11534336)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		event: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
		m: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


MouseButtonEvent>>sentTo:
	Receiver: [(1444@397) mouseUp 2160014 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		timeStamp: 	2160014
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1444@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1444@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		evt: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		evtBuf: 	#(1 2160014 1444 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(966787072))(a SearchMorp...etc...
		lastStepTime: 	2276208
		lastStepMessage: 	nil
		lastCycleTime: 	2276190
		alarms: 	a Heap()
		lastAlarmTime: 	2276208
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(966787072))(a SearchMorp...etc...
		lastStepTime: 	2276208
		lastStepMessage: 	nil
		lastCycleTime: 	2276190
		alarms: 	a Heap()
		lastAlarmTime: 	2276208
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(966787072))(a SearchMorp...etc...
		lastStepTime: 	2276208
		lastStepMessage: 	nil
		lastCycleTime: 	2276190
		alarms: 	a Heap()
		lastAlarmTime: 	2276208
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(966787072))(a SearchMorp...etc...
		lastStepTime: 	2276208
		lastStepMessage: 	nil
		lastCycleTime: 	2276190
		alarms: 	a Heap()
		lastAlarmTime: 	2276208
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:07:40.807619 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	true
		temp: 	an OrderedCollection(a Node a Node a Node a Node)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('D')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('D')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('D')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(565444608))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(565444608)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		event: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		evt: 	[(1378@391) mouseUp 2603574 nil]
		all: 	an Array(a PluggableButtonMorph(565444608) a PluggableButtonMorph(62364057...etc...
		m: 	a PluggableButtonMorph(565444608)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(565444608) a PluggableButtonMorph(623640576))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(565444608) a PluggableButtonMorph(623640576))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		evt: 	[(1378@391) mouseUp 2603574 nil]
		all: 	an Array(a PluggableButtonMorph(565444608) a PluggableButtonMorph(62364057...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


MouseButtonEvent>>sentTo:
	Receiver: [(1378@391) mouseUp 2603574 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(565444608)
	Receiver's instance variables: 
		timeStamp: 	2603574
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1378@391)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		focusHolder: 	a PluggableButtonMorph(565444608)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1378@391) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(664535040) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		focusHolder: 	a PluggableButtonMorph(565444608)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		focusHolder: 	a PluggableButtonMorph(565444608)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		evt: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1378@391) mouseUp 2603574 nil]
		evtBuf: 	#(1 2603574 1378 391 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 358350848))(3...etc...
		lastStepTime: 	2603660
		lastStepMessage: 	nil
		lastCycleTime: 	2603660
		alarms: 	a Heap()
		lastAlarmTime: 	2603660
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 358350848))(3...etc...
		lastStepTime: 	2603660
		lastStepMessage: 	nil
		lastCycleTime: 	2603660
		alarms: 	a Heap()
		lastAlarmTime: 	2603660
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 358350848))(3...etc...
		lastStepTime: 	2603660
		lastStepMessage: 	nil
		lastCycleTime: 	2603660
		alarms: 	a Heap()
		lastAlarmTime: 	2603660
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 358350848))(3...etc...
		lastStepTime: 	2603660
		lastStepMessage: 	nil
		lastCycleTime: 	2603660
		alarms: 	a Heap()
		lastAlarmTime: 	2603660
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(664535040) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:09:03.341615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	false
		temp: 	an OrderedCollection(a Node a Node a Node a Node)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('D')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('D')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('D')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(599261184))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(599261184)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		event: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		evt: 	[(1244@397) mouseUp 2686102 nil]
		all: 	an Array(a PluggableButtonMorph(973602816) a PluggableButtonMorph(59926118...etc...
		m: 	a PluggableButtonMorph(599261184)
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(973602816) a PluggableButtonMorph(599261184))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(973602816) a PluggableButtonMorph(599261184))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		evt: 	[(1244@397) mouseUp 2686102 nil]
		all: 	an Array(a PluggableButtonMorph(973602816) a PluggableButtonMorph(59926118...etc...
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


MouseButtonEvent>>sentTo:
	Receiver: [(1244@397) mouseUp 2686102 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(599261184)
	Receiver's instance variables: 
		timeStamp: 	2686102
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1244@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		focusHolder: 	a PluggableButtonMorph(599261184)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1244@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(471597056) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		focusHolder: 	a PluggableButtonMorph(599261184)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		focusHolder: 	a PluggableButtonMorph(599261184)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		evt: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1244@397) mouseUp 2686102 nil]
		evtBuf: 	#(1 2686102 1244 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2686184
		lastStepMessage: 	nil
		lastCycleTime: 	2686184
		alarms: 	a Heap()
		lastAlarmTime: 	2686184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2686184
		lastStepMessage: 	nil
		lastCycleTime: 	2686184
		alarms: 	a Heap()
		lastAlarmTime: 	2686184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2686184
		lastStepMessage: 	nil
		lastCycleTime: 	2686184
		alarms: 	a Heap()
		lastAlarmTime: 	2686184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2686184
		lastStepMessage: 	nil
		lastCycleTime: 	2686184
		alarms: 	a Heap()
		lastAlarmTime: 	2686184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(471597056) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:10:43.325616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
		temp: 	an OrderedCollection(a Node a Node a Node a Node)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(186646528))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(186646528)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		event: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		evt: 	[(733@345) mouseUp 2786086 nil]
		all: 	an Array(a PluggableButtonMorph(573833216) a PluggableButtonMorph(18664652...etc...
		m: 	a PluggableButtonMorph(186646528)
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(573833216) a PluggableButtonMorph(186646528))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(573833216) a PluggableButtonMorph(186646528))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		evt: 	[(733@345) mouseUp 2786086 nil]
		all: 	an Array(a PluggableButtonMorph(573833216) a PluggableButtonMorph(18664652...etc...
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


MouseButtonEvent>>sentTo:
	Receiver: [(733@345) mouseUp 2786086 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(186646528)
	Receiver's instance variables: 
		timeStamp: 	2786086
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(733@345)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		focusHolder: 	a PluggableButtonMorph(186646528)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(733@345) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(410255360) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		focusHolder: 	a PluggableButtonMorph(186646528)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		focusHolder: 	a PluggableButtonMorph(186646528)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		evt: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(733@345) mouseUp 2786086 nil]
		evtBuf: 	#(1 2786086 733 345 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2786160
		lastStepMessage: 	nil
		lastCycleTime: 	2786160
		alarms: 	a Heap()
		lastAlarmTime: 	2786160
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2786160
		lastStepMessage: 	nil
		lastCycleTime: 	2786160
		alarms: 	a Heap()
		lastAlarmTime: 	2786160
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2786160
		lastStepMessage: 	nil
		lastCycleTime: 	2786160
		alarms: 	a Heap()
		lastAlarmTime: 	2786160
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2786160
		lastStepMessage: 	nil
		lastCycleTime: 	2786160
		alarms: 	a Heap()
		lastAlarmTime: 	2786160
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(410255360) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>self
26 November 2015 5:29:45.025616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #self
	Receiver: [ :el | self halt ]
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: BlockClosure>>self
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializePresenter
		startpc: 	35
		numArgs: 	1


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow(ComposableModel)>>initialize
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initialize
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow class(Behavior)>>new
	Receiver: RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ComposableModel
		methodDict: 	a MethodDictionary(#data->RQTGMainWindow>>#data #data:->RQTGMainWin...etc...
		format: 	176
		layout: 	a FixedLayout
		instanceVariables: 	#(#refreshButton #showData #showName #hideNodes #hideTopics ...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RQTGMainWindow
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


TestingGraph>>testMainWindow1
	Receiver: a TestingGraph
	Arguments and temporary variables: 
		nodeA: 	a Node
		nodeB: 	a Node
		nodeC: 	a Node
		nodeD: 	a Node
		topic1: 	a Topic
		topic2: 	a Topic
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		graph: 	nil
	Receiver's instance variables: 
a TestingGraph

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"KeymapBrowser new openWithSpec."
TestingGraph new testMainWin...etc...
		itsSelection: 	a Text for '"KeymapBrowser new openWithSpec."
TestingGraph new te...etc...
		itsSelectionString: 	'"KeymapBrowser new openWithSpec."
TestingGraph new testMai...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(944504832)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (272@601)
		owner: 	a TransformWithLayoutMorph(451149824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(434896896) a RubCursor(317194240...etc...
		fullBounds: 	(0@0) corner: (272@601)
		color: 	Color transparent
		extension: 	a MorphExtension (348913664) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(412876800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(317194240)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(22020096))
		getMenuPolicy: 	a RubEditingArea(944504832)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	3927856
		lastStepMessage: 	nil
		lastCycleTime: 	3927856
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	3927856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1016594432) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	3927856
		lastStepMessage: 	nil
		lastCycleTime: 	3927856
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	3927856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	3927856
		lastStepMessage: 	nil
		lastCycleTime: 	3927856
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	3927856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1016594432) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #self
RQTGMainWindow>>initializePresenter
RQTGMainWindow(ComposableModel)>>initialize
RQTGMainWindow>>initialize
RQTGMainWindow class(Behavior)>>new
TestingGraph>>testMainWindow1
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: OrderedCollection>>whenChangedDo:
26 November 2015 5:30:00.071621 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

OrderedCollection(Object)>>doesNotUnderstand: #whenChangedDo:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aMessage: 	whenChangedDo: [ :el | self halt ]
		exception: 	MessageNotUnderstood: OrderedCollection>>whenChangedDo:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow(ComposableModel)>>initialize
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initialize
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow class(Behavior)>>new
	Receiver: RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ComposableModel
		methodDict: 	a MethodDictionary(#data->RQTGMainWindow>>#data #data:->RQTGMainWin...etc...
		format: 	176
		layout: 	a FixedLayout
		instanceVariables: 	#(#refreshButton #showData #showName #hideNodes #hideTopics ...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RQTGMainWindow
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


TestingGraph>>testMainWindow1
	Receiver: a TestingGraph
	Arguments and temporary variables: 
		nodeA: 	a Node
		nodeB: 	a Node
		nodeC: 	a Node
		nodeD: 	a Node
		topic1: 	a Topic
		topic2: 	a Topic
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		graph: 	nil
	Receiver's instance variables: 
a TestingGraph

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"KeymapBrowser new openWithSpec."
TestingGraph new testMainWin...etc...
		itsSelection: 	a Text for '"KeymapBrowser new openWithSpec."
TestingGraph new te...etc...
		itsSelectionString: 	'"KeymapBrowser new openWithSpec."
TestingGraph new testMai...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(944504832)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (272@601)
		owner: 	a TransformWithLayoutMorph(451149824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(434896896) a RubCursor(317194240...etc...
		fullBounds: 	(0@0) corner: (272@601)
		color: 	Color transparent
		extension: 	a MorphExtension (348913664) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(412876800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(317194240)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(22020096))
		getMenuPolicy: 	a RubEditingArea(944504832)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	3942846
		lastStepMessage: 	nil
		lastCycleTime: 	3942866
		alarms: 	a Heap()
		lastAlarmTime: 	3942846
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(314310656) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	3942846
		lastStepMessage: 	nil
		lastCycleTime: 	3942866
		alarms: 	a Heap()
		lastAlarmTime: 	3942846
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	3942846
		lastStepMessage: 	nil
		lastCycleTime: 	3942866
		alarms: 	a Heap()
		lastAlarmTime: 	3942846
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(314310656) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
OrderedCollection(Object)>>doesNotUnderstand: #whenChangedDo:
RQTGMainWindow>>initializePresenter
RQTGMainWindow(ComposableModel)>>initialize
RQTGMainWindow>>initialize
RQTGMainWindow class(Behavior)>>new
TestingGraph>>testMainWindow1
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
26 November 2015 5:31:01.737613 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow



--- The full stack ---
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:31:36.905615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(59768832))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(59768832)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		event: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		evt: 	[(1313@532) mouseUp 4039676 nil]
		all: 	an Array(a PluggableButtonMorph(19660800) a PluggableButtonMorph(59768832)...etc...
		m: 	a PluggableButtonMorph(59768832)
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(19660800) a PluggableButtonMorph(59768832))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(19660800) a PluggableButtonMorph(59768832))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		evt: 	[(1313@532) mouseUp 4039676 nil]
		all: 	an Array(a PluggableButtonMorph(19660800) a PluggableButtonMorph(59768832)...etc...
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


MouseButtonEvent>>sentTo:
	Receiver: [(1313@532) mouseUp 4039676 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(59768832)
	Receiver's instance variables: 
		timeStamp: 	4039676
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1313@532)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		focusHolder: 	a PluggableButtonMorph(59768832)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1313@532) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(11010048) a SpecWind...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		focusHolder: 	a PluggableButtonMorph(59768832)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		focusHolder: 	a PluggableButtonMorph(59768832)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		evt: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1313@532) mouseUp 4039676 nil]
		evtBuf: 	#(1 4039676 1313 532 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	4039740
		lastStepMessage: 	nil
		lastCycleTime: 	4039740
		alarms: 	a Heap()
		lastAlarmTime: 	4039740
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	4039740
		lastStepMessage: 	nil
		lastCycleTime: 	4039740
		alarms: 	a Heap()
		lastAlarmTime: 	4039740
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	4039740
		lastStepMessage: 	nil
		lastCycleTime: 	4039740
		alarms: 	a Heap()
		lastAlarmTime: 	4039740
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	4039740
		lastStepMessage: 	nil
		lastCycleTime: 	4039740
		alarms: 	a Heap()
		lastAlarmTime: 	4039740
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(11010048) a SpecWind...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ConnectionTimedOut: Cannot connect to 127.0.0.1:11311
30 November 2015 4:33:12.23723 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ ConnectionTimedOut signal: 'Cannot connect to ' , (NetNameResolver stringFromAddress: hostAddress) , ':' , port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	11311
		timeout: 	30
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[20 119 8 93 0 0 0 0 184 76 147 9]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	30
		timeoutBlock: 	[ ConnectionTimedOut signal: 'Cannot connect to ' , (NetNameResol...etc...
		startTime: 	659377
		msecsDelta: 	30000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[20 119 8 93 0 0 0 0 184 76 147 9]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	11311
		timeout: 	30
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[20 119 8 93 0 0 0 0 184 76 147 9]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


ZdcSocketStream(ZdcAbstractSocketStream)>>socketConnectTo:port:
	Receiver: a ZdcSocketStream
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		portNumber: 	11311
	Receiver's instance variables: 
		socket: 	a Socket[unconnected]
		readBuffer: 	a ZdcIOBuffer(#[] +4096)
		writeBuffer: 	a ZdcIOBuffer(#[] +4096)
		timeout: 	30
		debug: 	false


ZdcSocketStream(ZdcSimpleSocketStream)>>connectTo:port:
	Receiver: a ZdcSocketStream
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		portNumber: 	11311
	Receiver's instance variables: 
		socket: 	a Socket[unconnected]
		readBuffer: 	a ZdcIOBuffer(#[] +4096)
		writeBuffer: 	a ZdcIOBuffer(#[] +4096)
		timeout: 	30
		debug: 	false


ZdcSocketStream class(ZdcSimpleSocketStream class)>>openConnectionToHost:port:timeout:
	Receiver: ZdcSocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	11311
		timeout: 	30
		platformSocket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	ZdcOptimizedSocketStream
		methodDict: 	a MethodDictionary(#next:putAll:startingAt:->ZdcSocketStream>>#next...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZdcSocketStream
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zodiac-Core'
		traitComposition: 	{}
		localSelectors: 	nil


ZnNetworkingUtils>>socketStreamToUrlDirectly:
	Receiver: a ZnNetworkingUtils
	Arguments and temporary variables: 
		url: 	http://localhost:11311/
		stream: 	nil
		address: 	#[127 0 0 1]
	Receiver's instance variables: 
		socketStreamClass: 	ZdcSocketStream
		secureSocketStreamClass: 	ZdcSecureSocketStream


ZnNetworkingUtils>>socketStreamToUrl:
	Receiver: a ZnNetworkingUtils
	Arguments and temporary variables: 
		url: 	http://localhost:11311/
	Receiver's instance variables: 
		socketStreamClass: 	ZdcSocketStream
		secureSocketStreamClass: 	ZdcSecureSocketStream


ZnNetworkingUtils class>>socketStreamToUrl:
	Receiver: ZnNetworkingUtils
	Arguments and temporary variables: 
		url: 	http://localhost:11311/
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#bufferSize->ZnNetworkingUtils>>#bufferSize #htt...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('socketStreamClass' 'secureSocketStreamClass')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnNetworkingUtils
		classPool: 	a Dictionary(#Default->a ZnNetworkingUtils #DefaultSocketStreamTimeo...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Support'
		traitComposition: 	{}
		localSelectors: 	nil


ZnClient>>newConnectionTo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		url: 	http://localhost:11311/
		initialMilliseconds: 	659377
		proxied: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>getConnectionAndExecute
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithRedirectsRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		redirectCount: 	3
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	0
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRedirectsRemaining: self maxNumberOfRedirects ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :exception | 
retryCount > 0
	ifTrue: [ 
		self
			handleRetry...etc...
	Receiver's instance variables: 
		outerContext: 	ZnClient>>executeWithRetriesRemaining:
		startpc: 	49
		numArgs: 	0


ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	0
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ self executeWithRetriesRemaining: self numberOfRetries ] in [ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRetriesRemaining: self numberOfRetries ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :exception | exception pass ]
	Receiver's instance variables: 
		outerContext: 	[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on...etc...
		startpc: 	46
		numArgs: 	0


[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ 
p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


BlockClosure>>ensure:
	Receiver: [ 
p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnConnectionTimeout(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


ZnConnectionTimeout class(DynamicVariable class)>>value:during:
	Receiver: ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnConnectionTimeout
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		hash: 	972029952
		soleInstance: 	a ZnConnectionTimeout


ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ result := self executeWithTimeout ] in ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ 
p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	false
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ 
p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnSignalProgress(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	false
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


ZnSignalProgress class(DynamicVariable class)>>value:during:
	Receiver: ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	false
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnSignalProgress
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		hash: 	nil
		soleInstance: 	a ZnSignalProgress


ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>post
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /)
		response: 	nil
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnEasy class>>post:data:
	Receiver: ZnEasy
	Arguments and temporary variables: 
		urlObject: 	'http://localhost:11311'
		entity: 	a ZnStringEntity(application/xml 156B <?xml version="1.0"?><methodCall>...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnEasy
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Client-Server'
		traitComposition: 	{}
		localSelectors: 	nil


XMLRPCProxy>>sendXmlRpc:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		data: 	'<?xml version="1.0"?><methodCall><methodName>getSystemState</methodName>...etc...
		s: 	nil
		req: 	nil
		res: 	nil
		xml: 	nil
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


XMLRPCProxy>>invokeMethod:withArgs:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		aString: 	'getSystemState'
		anArray: 	#('/script')
		request: 	'<?xml version="1.0"?><methodCall><methodName>getSystemState</methodNa...etc...
		response: 	nil
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://lo...etc...
		itsSelection: 	a Text for '| proxy systemState |
proxy := XMLRPCProxy withUrl:''...etc...
		itsSelectionString: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http:...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| proxy systemState |
	proxy := XMLRPCProxy withUrl: 'http://localho...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false



--- The full stack ---
[ ConnectionTimedOut signal: 'Cannot connect to ' , (NetNameResolver stringFromAddress: hostAddress) , ':' , port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
ZdcSocketStream(ZdcAbstractSocketStream)>>socketConnectTo:port:
ZdcSocketStream(ZdcSimpleSocketStream)>>connectTo:port:
ZdcSocketStream class(ZdcSimpleSocketStream class)>>openConnectionToHost:port:timeout:
ZnNetworkingUtils>>socketStreamToUrlDirectly:
ZnNetworkingUtils>>socketStreamToUrl:
ZnNetworkingUtils class>>socketStreamToUrl:
ZnClient>>newConnectionTo:
ZnClient>>getConnectionAndExecute
ZnClient>>executeWithRedirectsRemaining:
[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
BlockClosure>>on:do:
ZnClient>>executeWithRetriesRemaining:
[ self executeWithRetriesRemaining: self numberOfRetries ] in [ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
BlockClosure>>on:do:
[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
[ ^ block value ] in ZnClient>>withTimeoutDo:
[ 
p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnConnectionTimeout(DynamicVariable)>>value:during:
ZnConnectionTimeout class(DynamicVariable class)>>value:during:
ZnClient>>withTimeoutDo:
ZnClient>>executeWithTimeout
[ result := self executeWithTimeout ] in ZnClient>>execute
[ ^ block value ] in ZnClient>>withProgressDo:
[ 
p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnSignalProgress(DynamicVariable)>>value:during:
ZnSignalProgress class(DynamicVariable class)>>value:during:
ZnClient>>withProgressDo:
ZnClient>>execute
ZnClient>>post
ZnEasy class>>post:data:
XMLRPCProxy>>sendXmlRpc:
XMLRPCProxy>>invokeMethod:withArgs:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "parse:" is nil
30 November 2015 4:33:48.11523 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #parse:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	parse: '<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<va...etc...
		exception: 	MessageNotUnderstood: receiver of "parse:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

XMLRPCProxy>>processResponse:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		xmlStream: 	'<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<value><a...etc...
		xmldoc: 	nil
		methodResponse: 	nil
		fault: 	nil
		parameters: 	nil
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


XMLRPCProxy>>invokeMethod:withArgs:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		aString: 	'getSystemState'
		anArray: 	#('/script')
		request: 	'<?xml version="1.0"?><methodCall><methodName>getSystemState</methodNa...etc...
		response: 	'<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<value><ar...etc...
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://lo...etc...
		itsSelection: 	a Text for '| proxy systemState |
proxy := XMLRPCProxy withUrl:''...etc...
		itsSelectionString: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http:...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| proxy systemState |
	proxy := XMLRPCProxy withUrl: 'http://localho...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(15466496)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(15466496)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(617349120)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(15466496)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@107)
		owner: 	a TransformWithLayoutMorph(739246080)
		submorphs: 	an Array(a RubCursor(492044288) a RubPrimarySelectionMorph(597164032...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (481558528) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(700973056)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(492044288)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(745537536))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(617349120)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(271056896))(a TRMorph(271056...etc...
		lastStepTime: 	695237
		lastStepMessage: 	nil
		lastCycleTime: 	695257
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(492044288)))
		lastAlarmTime: 	695237
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(277610496) a Sp...etc...
		fullBounds: 	(0@0) corner: (927@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(271056896))(a TRMorph(271056...etc...
		lastStepTime: 	695237
		lastStepMessage: 	nil
		lastCycleTime: 	695257
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(492044288)))
		lastAlarmTime: 	695237
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(271056896))(a TRMorph(271056...etc...
		lastStepTime: 	695237
		lastStepMessage: 	nil
		lastCycleTime: 	695257
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(492044288)))
		lastAlarmTime: 	695237
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(277610496) a Sp...etc...
		fullBounds: 	(0@0) corner: (927@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #parse:
XMLRPCProxy>>processResponse:
XMLRPCProxy>>invokeMethod:withArgs:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RoassalModel>>updateData:
30 November 2015 4:55:53.191231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RoassalModel(Object)>>doesNotUnderstand: #updateData:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aMessage: 	updateData: an OrderedCollection(a Node a Node a Node a Node)
		exception: 	MessageNotUnderstood: RoassalModel>>updateData:
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | Graph new createGraph: data withVie...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


Array(SequenceableCollection)>>do:
	Receiver: #('B')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('B')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('B')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(131334144))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(131334144)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(131334144)
	Arguments and temporary variables: 
		event: 	[(1089@668) mouseUp 2020317 nil]
	Receiver's instance variables: 
		bounds: 	(994.0@660.0) corner: (1189.0@689.0)
		owner: 	a PanelMorph(864026624)
		submorphs: 	an Array(an AlignmentMorph(953679872))
		fullBounds: 	(994@660) corner: (1189@689)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (198705152) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1035730944)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(131334144)
	Arguments and temporary variables: 
		evt: 	[(1089@668) mouseUp 2020317 nil]
		all: 	an Array(a PluggableButtonMorph(591659008) a PluggableButtonMorph(13133414...etc...
		m: 	a PluggableButtonMorph(131334144)
	Receiver's instance variables: 
		bounds: 	(994.0@660.0) corner: (1189.0@689.0)
		owner: 	a PanelMorph(864026624)
		submorphs: 	an Array(an AlignmentMorph(953679872))
		fullBounds: 	(994@660) corner: (1189@689)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (198705152) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1035730944)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(591659008) a PluggableButtonMorph(131334144))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(591659008) a PluggableButtonMorph(131334144))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(131334144)
	Arguments and temporary variables: 
		evt: 	[(1089@668) mouseUp 2020317 nil]
		all: 	an Array(a PluggableButtonMorph(591659008) a PluggableButtonMorph(13133414...etc...
	Receiver's instance variables: 
		bounds: 	(994.0@660.0) corner: (1189.0@689.0)
		owner: 	a PanelMorph(864026624)
		submorphs: 	an Array(an AlignmentMorph(953679872))
		fullBounds: 	(994@660) corner: (1189@689)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (198705152) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1035730944)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(131334144)
	Arguments and temporary variables: 
		anEvent: 	[(1089@668) mouseUp 2020317 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(994.0@660.0) corner: (1189.0@689.0)
		owner: 	a PanelMorph(864026624)
		submorphs: 	an Array(an AlignmentMorph(953679872))
		fullBounds: 	(994@660) corner: (1189@689)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (198705152) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1035730944)


MouseButtonEvent>>sentTo:
	Receiver: [(1089@668) mouseUp 2020317 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(131334144)
	Receiver's instance variables: 
		timeStamp: 	2020317
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1089@668)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(131334144)
	Arguments and temporary variables: 
		anEvent: 	[(1089@668) mouseUp 2020317 nil]
	Receiver's instance variables: 
		bounds: 	(994.0@660.0) corner: (1189.0@689.0)
		owner: 	a PanelMorph(864026624)
		submorphs: 	an Array(an AlignmentMorph(953679872))
		fullBounds: 	(994@660) corner: (1189@689)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (198705152) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1035730944)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(131334144)
	Arguments and temporary variables: 
		anEvent: 	[(1089@668) mouseUp 2020317 nil]
	Receiver's instance variables: 
		bounds: 	(994.0@660.0) corner: (1189.0@689.0)
		owner: 	a PanelMorph(864026624)
		submorphs: 	an Array(an AlignmentMorph(953679872))
		fullBounds: 	(994@660) corner: (1189@689)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (198705152) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1035730944)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1089@668) mouseUp 2020317 nil]
		focusHolder: 	a PluggableButtonMorph(131334144)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1089@668) corner: (1105@684)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1089@668) corner: (1105@684)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(131334144)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1089@668) mouseOver nil nil]
		targetOffset: 	(95.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2020317 1089 668 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1089@668) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(972029952) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1089@668) mouseUp 2020317 nil]
		focusHolder: 	a PluggableButtonMorph(131334144)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1089@668) corner: (1105@684)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1089@668) corner: (1105@684)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(131334144)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1089@668) mouseOver nil nil]
		targetOffset: 	(95.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2020317 1089 668 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1089@668) mouseUp 2020317 nil]
		focusHolder: 	a PluggableButtonMorph(131334144)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1089@668) corner: (1105@684)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1089@668) corner: (1105@684)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(131334144)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1089@668) mouseOver nil nil]
		targetOffset: 	(95.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2020317 1089 668 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1089@668) mouseUp 2020317 nil]
	Receiver's instance variables: 
		bounds: 	(1089@668) corner: (1105@684)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1089@668) corner: (1105@684)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(131334144)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1089@668) mouseOver nil nil]
		targetOffset: 	(95.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2020317 1089 668 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1089@668) mouseUp 2020317 nil]
		evt: 	[(1089@668) mouseUp 2020317 nil]
	Receiver's instance variables: 
		bounds: 	(1089@668) corner: (1105@684)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1089@668) corner: (1105@684)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(131334144)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1089@668) mouseOver nil nil]
		targetOffset: 	(95.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2020317 1089 668 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1089@668) mouseUp 2020317 nil]
		evtBuf: 	#(1 2020317 1089 668 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1089@668) corner: (1105@684)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1089@668) corner: (1105@684)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(131334144)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1089@668) mouseOver nil nil]
		targetOffset: 	(95.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2020317 1089 668 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(1034420224))(a DropLis...etc...
		lastStepTime: 	2020373
		lastStepMessage: 	nil
		lastCycleTime: 	2020373
		alarms: 	a Heap()
		lastAlarmTime: 	2020373
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(927203328))(a TRMorph(927203...etc...
		lastStepTime: 	2020395
		lastStepMessage: 	nil
		lastCycleTime: 	2020395
		alarms: 	a Heap()
		lastAlarmTime: 	2020395
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(927203328))(a TRMorph(927203...etc...
		lastStepTime: 	2020395
		lastStepMessage: 	nil
		lastCycleTime: 	2020395
		alarms: 	a Heap()
		lastAlarmTime: 	2020395
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(927203328))(a TRMorph(927203...etc...
		lastStepTime: 	2020395
		lastStepMessage: 	nil
		lastCycleTime: 	2020395
		alarms: 	a Heap()
		lastAlarmTime: 	2020395
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(972029952) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
RoassalModel(Object)>>doesNotUnderstand: #updateData:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Graph class>>updateData:
30 November 2015 4:58:12.783231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Graph class(Object)>>doesNotUnderstand: #updateData:
	Receiver: Graph
	Arguments and temporary variables: 
		aMessage: 	updateData: an OrderedCollection(a Node a Node a Node a Node)
		exception: 	MessageNotUnderstood: Graph class>>updateData:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#addLayout:->Graph>>#addLayout: #createGraph:->G...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#data #view)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Graph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


[ :view :canvas | Graph updateData: data ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | Graph updateData: data ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>listChange:with:
		startpc: 	64
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(42991616)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(42991616)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(42991616)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | Graph updateData: data ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | Graph updateData: data ]
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | Graph updateData: data ]
		secondArg: 	[ :view :canvas | Graph new createGraph: data withView: view ]
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | Graph updateData: data ]
		secondArg: 	[ :view :canvas | Graph new createGraph: data withView: view ]
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | Graph updateData: data ]
		secondArg: 	[ :view :canvas | Graph new createGraph: data withView: view ]
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | Graph updateData: data ]


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		announcement: 	a ValueChanged
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


NewValueHolder>>valueChanged:
	Receiver: a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
	Arguments and temporary variables: 
		oldValue: 	[ :view :canvas | Graph new createGraph: data withView: view ]
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | Graph updateData: data ]


[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
	Receiver: a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
	Arguments and temporary variables: 
		anObject: 	[ :view :canvas | Graph updateData: data ]
		oldValue: 	[ :view :canvas | Graph new createGraph: data withView: view ]
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | Graph updateData: data ]


BlockClosure>>ensure:
	Receiver: [ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ]
	Arguments and temporary variables: 
		aBlock: 	[ lock := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>value:
		startpc: 	27
		numArgs: 	0


NewValueHolder>>handleCircularReferencesWhile:
	Receiver: a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
	Arguments and temporary variables: 
		aBlock: 	[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | Graph updateData: data ]


NewValueHolder>>value:
	Receiver: a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
	Arguments and temporary variables: 
		anObject: 	[ :view :canvas | Graph updateData: data ]
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | Graph updateData: data ]


RoassalModel>>script:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aBlock: 	[ :view :canvas | Graph updateData: data ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | Graph updateData: data ] ]
		lastEvent: 	a NewValueHolder[ nil ]


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]



--- The full stack ---
Graph class(Object)>>doesNotUnderstand: #updateData:
[ :view :canvas | Graph updateData: data ] in RQTGMainWindow>>listChange:with:
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "ifTrue:" is nil
30 November 2015 5:15:52.797231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #ifTrue:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	ifTrue: RTLabel
		exception: 	MessageNotUnderstood: receiver of "ifTrue:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Graph>>ExecuteUnOptimizedIn:
	Receiver: a Graph
	Arguments and temporary variables: 
		t1: 	Graph>>withName
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	nil


UndefinedObject(Object)>>mustBeBooleanInMagic:
	Receiver: nil
	Arguments and temporary variables: 
		context: 	Graph>>withName
		sendNode: 	RBMessageNode(names
	ifTrue: [ ^ RTLabel text: [ :val | val objName ]...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ names
		ifTrue: [ ThisContext ...etc...
		method: 	Graph>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>mustBeBoolean
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

Graph>>withName
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	nil


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	176
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(540278784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(540278784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #ifTrue:
Graph>>ExecuteUnOptimizedIn:
UndefinedObject(Object)>>mustBeBooleanInMagic:
UndefinedObject(Object)>>mustBeBoolean
Graph>>withName
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow1
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>instance
30 November 2015 5:17:15.019233 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #instance
	Receiver: [ :val | self withName: val ]
	Arguments and temporary variables: 
		aMessage: 	instance
		exception: 	MessageNotUnderstood: BlockClosure>>instance
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	129
		numArgs: 	1


RTEllipse(RTShape)>>+
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anotherShape: 	[ :val | self withName: val ]
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	nil


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	176
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(461111296)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(461111296)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #instance
RTEllipse(RTShape)>>+
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow1
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>instance
30 November 2015 5:17:36.88923 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #instance
	Receiver: [ :val | self withName: val ]
	Arguments and temporary variables: 
		aMessage: 	instance
		exception: 	MessageNotUnderstood: BlockClosure>>instance
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	129
		numArgs: 	1


RTEllipse(RTShape)>>+
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anotherShape: 	[ :val | self withName: val ]
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	nil


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	176
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(36700160)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(36700160)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #instance
RTEllipse(RTShape)>>+
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow1
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "parse:" is nil
30 November 2015 5:21:10.509235 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #parse:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	parse: '<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<va...etc...
		exception: 	MessageNotUnderstood: receiver of "parse:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

XMLRPCProxy>>processResponse:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		xmlStream: 	'<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<value><a...etc...
		xmldoc: 	nil
		methodResponse: 	nil
		fault: 	nil
		parameters: 	nil
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


XMLRPCProxy>>invokeMethod:withArgs:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		aString: 	'getSystemState'
		anArray: 	#('/script')
		request: 	'<?xml version="1.0"?><methodCall><methodName>getSystemState</methodNa...etc...
		response: 	'<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<value><ar...etc...
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://lo...etc...
		itsSelection: 	a Text for '| proxy systemState |
proxy := XMLRPCProxy withUrl:''...etc...
		itsSelectionString: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http:...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| proxy systemState |
	proxy := XMLRPCProxy withUrl: 'http://localho...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | t selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@107)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubCursor(425721856) a RubPrimarySelectionMorph(603193344...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(992739328))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(42991616))(a TRMorph(4299161...etc...
		lastStepTime: 	3537607
		lastStepMessage: 	nil
		lastCycleTime: 	3537627
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3537607
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a GL...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(42991616))(a TRMorph(4299161...etc...
		lastStepTime: 	3537607
		lastStepMessage: 	nil
		lastCycleTime: 	3537627
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3537607
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(42991616))(a TRMorph(4299161...etc...
		lastStepTime: 	3537607
		lastStepMessage: 	nil
		lastCycleTime: 	3537627
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3537607
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a GL...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #parse:
XMLRPCProxy>>processResponse:
XMLRPCProxy>>invokeMethod:withArgs:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "parse:" is nil
30 November 2015 5:21:19.191234 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #parse:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	parse: '<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<va...etc...
		exception: 	MessageNotUnderstood: receiver of "parse:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

XMLRPCProxy>>processResponse:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		xmlStream: 	'<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<value><a...etc...
		xmldoc: 	nil
		methodResponse: 	nil
		fault: 	nil
		parameters: 	nil
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


XMLRPCProxy>>invokeMethod:withArgs:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		aString: 	'getSystemState'
		anArray: 	#('/script')
		request: 	'<?xml version="1.0"?><methodCall><methodName>getSystemState</methodNa...etc...
		response: 	'<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<value><ar...etc...
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://lo...etc...
		itsSelection: 	a Text for '| proxy systemState |
proxy := XMLRPCProxy withUrl:''...etc...
		itsSelectionString: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http:...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| proxy systemState |
	proxy := XMLRPCProxy withUrl: 'http://localho...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | t selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@88)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubCursor(425721856) a RubPrimarySelectionMorph(603193344...etc...
		fullBounds: 	(0@0) corner: (580@88)
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(477888512))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(896532480))(a SearchMorp...etc...
		lastStepTime: 	3546351
		lastStepMessage: 	nil
		lastCycleTime: 	3546347
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3546351
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a GL...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(896532480))(a SearchMorp...etc...
		lastStepTime: 	3546351
		lastStepMessage: 	nil
		lastCycleTime: 	3546347
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3546351
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(896532480))(a SearchMorp...etc...
		lastStepTime: 	3546351
		lastStepMessage: 	nil
		lastCycleTime: 	3546347
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3546351
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a GL...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #parse:
XMLRPCProxy>>processResponse:
XMLRPCProxy>>invokeMethod:withArgs:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "parse:" is nil
30 November 2015 5:22:04.13523 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #parse:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	parse: '<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<va...etc...
		exception: 	MessageNotUnderstood: receiver of "parse:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

XMLRPCProxy>>processResponse:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		xmlStream: 	'<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<value><a...etc...
		xmldoc: 	nil
		methodResponse: 	nil
		fault: 	nil
		parameters: 	nil
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


XMLRPCProxy>>invokeMethod:withArgs:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		aString: 	'getSystemState'
		anArray: 	#('/script')
		request: 	'<?xml version="1.0"?><methodCall><methodName>getSystemState</methodNa...etc...
		response: 	'<?xml version=''1.0''?>
<methodResponse>
<params>
<param>
<value><ar...etc...
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://lo...etc...
		itsSelection: 	a Text for '| proxy systemState |
proxy := XMLRPCProxy withUrl:''...etc...
		itsSelectionString: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http:...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| proxy systemState |
	proxy := XMLRPCProxy withUrl: 'http://localho...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | t selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@88)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubCursor(425721856) a RubPrimarySelectionMorph(603193344...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(22282240))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(21495808))(a RubE...etc...
		lastStepTime: 	3591257
		lastStepMessage: 	nil
		lastCycleTime: 	3591277
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3591257
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Sy...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(21495808))(a RubE...etc...
		lastStepTime: 	3591257
		lastStepMessage: 	nil
		lastCycleTime: 	3591277
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3591257
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(21495808))(a RubE...etc...
		lastStepTime: 	3591257
		lastStepMessage: 	nil
		lastCycleTime: 	3591277
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3591257
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Sy...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #parse:
XMLRPCProxy>>processResponse:
XMLRPCProxy>>invokeMethod:withArgs:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "new" is nil
30 November 2015 5:23:33.847231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	new
		exception: 	MessageNotUnderstood: receiver of "new" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

XMLRPCClientTest>>setUp
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


[ 
self setUp.
self performTest ] in XMLRPCClientTest(TestCase)>>runCase
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	XMLRPCClientTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


XMLRPCClientTest(TestCase)>>runCase
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


[ (self class selector: testSelector) runCase ] in XMLRPCClientTest(TestCase)>>debug
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	#()
		proxy: 	nil
		server: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	XMLRPCClientTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


XMLRPCClientTest(TestCase)>>debug
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	#()
		proxy: 	nil
		server: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	XMLRPCClientTest>>#testArray
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testArray)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(XMLRPCClientTest>>#testArray)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(XMLRPCClientTest>>#testArray nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testArray)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testArray)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	XMLRPCClientTest>>#testArray
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		event: 	[(1481@411) mouseUp 3680977 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		evt: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1481@411) mouseUp 3680977 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		timeStamp: 	3680977
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1481@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		aMorph: 	a PluggableListMorph(347340800)
		localEvt: 	[(1481@411) mouseUp 3680977 nil]
		index: 	3
		child: 	a TransformMorph(656146432)
		morphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1481@411) mouseUp 3680977 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	3680977
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1481@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		aMorph: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		aMorph: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		focusHolder: 	a PluggableListMorph(347340800)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1481@411) corner: (1497@427)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1481@411) corner: (1497@427)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(347340800)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1481@411) mouseOver nil nil]
		targetOffset: 	(84.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3680977 1481 411 0 0 0 1)
		lastKeyScanCode: 	76
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #new
XMLRPCClientTest>>setUp
[ 
self setUp.
self performTest ] in XMLRPCClientTest(TestCase)>>runCase
BlockClosure>>ensure:
XMLRPCClientTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in XMLRPCClientTest(TestCase)>>debug
BlockClosure>>ensure:
XMLRPCClientTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Unwind error during termination
30 November 2015 5:23:40.045231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #stop
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	stop
		exception: 	MessageNotUnderstood: receiver of "stop" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

XMLRPCClientTest>>tearDown
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


[ 
self tearDown.
self cleanUpInstanceVariables ] in XMLRPCClientTest(TestCase)>>runCase
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	XMLRPCClientTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


XMLRPCClientTest(TestCase)>>runCase
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


[ (self class selector: testSelector) runCase ] in XMLRPCClientTest(TestCase)>>debug
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	#()
		proxy: 	nil
		server: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	XMLRPCClientTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


XMLRPCClientTest(TestCase)>>debug
	Receiver: XMLRPCClientTest>>#testArray
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testArray
		expectedFails: 	#()
		proxy: 	nil
		server: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	XMLRPCClientTest>>#testArray
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testArray)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(XMLRPCClientTest>>#testArray)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(XMLRPCClientTest>>#testArray nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testArray)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testArray)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	XMLRPCClientTest>>#testArray
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests')
		categoryIndex: 	1
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testArray
		lastUpdate: 	3626367811
		result: 	20 run, 1 passes, 0 skipped, 0 expected failures, 0 failures, 19 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		event: 	[(1481@411) mouseUp 3680977 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		evt: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1481@411) mouseUp 3680977 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		timeStamp: 	3680977
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1481@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		aMorph: 	a PluggableListMorph(347340800)
		localEvt: 	[(1481@411) mouseUp 3680977 nil]
		index: 	3
		child: 	a TransformMorph(656146432)
		morphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1481@411) mouseUp 3680977 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	3680977
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1481@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		aMorph: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		aMorph: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1481@411) mouseUp 3680977 nil]
		focusHolder: 	a PluggableListMorph(347340800)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(630@169) corner: (646@185)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(630@169) corner: (646@185)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(542113792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(630@169) mouseUp 3687175 nil]
		targetOffset: 	(8.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3687175 630 169 0 0 0 1)
		lastKeyScanCode: 	76
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #stop
XMLRPCClientTest>>tearDown
[ 
self tearDown.
self cleanUpInstanceVariables ] in XMLRPCClientTest(TestCase)>>runCase
Context>>resume:through:
BlockClosure>>ensure:
XMLRPCClientTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in XMLRPCClientTest(TestCase)>>debug
BlockClosure>>ensure:
XMLRPCClientTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "new" is nil
30 November 2015 5:25:37.159231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	new
		exception: 	MessageNotUnderstood: receiver of "new" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

XMLRPCClientTest>>setUp
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


[ 
self setUp.
self performTest ] in XMLRPCClientTest(TestCase)>>runCase
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	XMLRPCClientTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


XMLRPCClientTest(TestCase)>>runCase
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


[ (self class selector: testSelector) runCase ] in XMLRPCClientTest(TestCase)>>debug
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	#()
		proxy: 	nil
		server: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	XMLRPCClientTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


XMLRPCClientTest(TestCase)>>debug
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	#()
		proxy: 	nil
		server: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	XMLRPCClientTest>>#testBinary
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testBinary)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(XMLRPCClientTest>>#testBinary)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(XMLRPCClientTest>>#testBinary nil nil nil nil nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testBinary)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testBinary)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	XMLRPCClientTest>>#testBinary
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	3
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anInteger: 	3
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		event: 	[(1530@449) mouseUp 3804299 nil]
		row: 	3
		mdr: 	3
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		evt: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1530@449) mouseUp 3804299 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		timeStamp: 	3804299
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1530@449)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		aMorph: 	a PluggableListMorph(347340800)
		localEvt: 	[(1530@449) mouseUp 3804299 nil]
		index: 	3
		child: 	a TransformMorph(656146432)
		morphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1530@449) mouseUp 3804299 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	3804299
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1530@449)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		aMorph: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		aMorph: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [other:  (announcer -> an Announcer)]
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		focusHolder: 	a PluggableListMorph(347340800)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1530@449) corner: (1546@465)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1530@449) corner: (1546@465)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableListMorph(347340800)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1530@449) mouseUp 3804299 nil]
		targetOffset: 	(133.0@46.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3804299 1530 449 0 0 0 1)
		lastKeyScanCode: 	23
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #new
XMLRPCClientTest>>setUp
[ 
self setUp.
self performTest ] in XMLRPCClientTest(TestCase)>>runCase
BlockClosure>>ensure:
XMLRPCClientTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in XMLRPCClientTest(TestCase)>>debug
BlockClosure>>ensure:
XMLRPCClientTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Unwind error during termination
30 November 2015 5:25:41.24723 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #stop
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	stop
		exception: 	MessageNotUnderstood: receiver of "stop" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

XMLRPCClientTest>>tearDown
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


[ 
self tearDown.
self cleanUpInstanceVariables ] in XMLRPCClientTest(TestCase)>>runCase
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	XMLRPCClientTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


XMLRPCClientTest(TestCase)>>runCase
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	nil
		proxy: 	nil
		server: 	nil


[ (self class selector: testSelector) runCase ] in XMLRPCClientTest(TestCase)>>debug
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	#()
		proxy: 	nil
		server: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	XMLRPCClientTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


XMLRPCClientTest(TestCase)>>debug
	Receiver: XMLRPCClientTest>>#testBinary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testBinary
		expectedFails: 	#()
		proxy: 	nil
		server: 	nil


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	XMLRPCClientTest>>#testBinary
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testBinary)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(XMLRPCClientTest>>#testBinary)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(XMLRPCClientTest>>#testBinary nil nil nil nil nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testBinary)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: eac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(XMLRPCClientTest>>#testBinary)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


BlockClosure>>ensure:
	Receiver: [ aBlock cull: aTestSuite cull: result ]
	Arguments and temporary variables: 
		aBlock: 	[ aTestSuite unsubscribe: TestAnnouncement ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>executeSuite:as:
		startpc: 	49
		numArgs: 	0


TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	XMLRPCClientTest>>#testBinary
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	3
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(1055916032) a SearchMorph(81946214...etc...
		categories: 	#(#'XMLRPC-Client-Tests' #'XML-Writer-Tests' #'XML-Tests-Parser' #'...etc...
		categoryIndex: 	0
		categoriesSelected: 	a Set(#'XMLRPC-Client-Tests')
		classes: 	{XMLRPCClientBaseTest. XMLRPCClientTest. XMLRPCDecoderTest. XMLRPCEnco...etc...
		classIndex: 	0
		classesSelected: 	a Set(XMLRPCEncoderTest XMLRPCClientBaseTest XMLRPCClientTest ...etc...
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(XMLRPCClientTest>>#testArray XMLRPCClientTest>>#testArray X...etc...
		errorSelected: 	XMLRPCClientTest>>#testBinary
		lastUpdate: 	3626367932
		result: 	20 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 17 errors...etc...
		previousRun: 	nil
		categoryPattern: 	a RxMatcher
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anInteger: 	3
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUpOnSingle:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		event: 	[(1530@449) mouseUp 3804299 nil]
		row: 	3
		mdr: 	3
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		evt: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1530@449) mouseUp 3804299 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		timeStamp: 	3804299
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1530@449)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		aMorph: 	a PluggableListMorph(347340800)
		localEvt: 	[(1530@449) mouseUp 3804299 nil]
		index: 	3
		child: 	a TransformMorph(656146432)
		morphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1530@449) mouseUp 3804299 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	3804299
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1530@449)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		aMorph: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		aMorph: 	a PluggableListMorph(347340800)
	Receiver's instance variables: 
		morph: 	nil


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(347340800)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
	Receiver's instance variables: 
		bounds: 	(1397.0@403.0) corner: (1848.0@602.0)
		owner: 	a SystemWindow(1055916032)
		submorphs: 	an Array(a ScrollBar(379846656) a TransformMorph(656146432))
		fullBounds: 	(1397@403) corner: (1848@602)
		color: 	Color white
		extension: 	a MorphExtension (709361664) [locked]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a TestRunner
		scrollBar: 	a ScrollBar(379846656)
		scroller: 	a TransformMorph(656146432)
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(1067450368)
		list: 	#('XMLRPCClientTest>>#testArray' 'XMLRPCClientTest>>#testArray' 'XMLRPCCl...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(723255296)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	nil
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.686 g: 0.835 b: 0.979 alpha: 1.0)
		selectionColorToUse: 	nil
		enabled: 	nil
		getEnabledSelector: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1530@449) mouseUp 3804299 nil]
		focusHolder: 	a PluggableListMorph(347340800)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(628@166) corner: (644@182)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(628@166) corner: (644@182)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(598474752)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(628@166) mouseUp 3808385 nil]
		targetOffset: 	(6.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3808385 628 166 0 0 0 1)
		lastKeyScanCode: 	23
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #stop
XMLRPCClientTest>>tearDown
[ 
self tearDown.
self cleanUpInstanceVariables ] in XMLRPCClientTest(TestCase)>>runCase
Context>>resume:through:
BlockClosure>>ensure:
XMLRPCClientTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in XMLRPCClientTest(TestCase)>>debug
BlockClosure>>ensure:
XMLRPCClientTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ZdcPluginMissing: SSL/TLS plugin initailization failed (VM plugin missing ? OS libraries missing ?)
30 November 2015 5:26:45.197231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :exception | 
"Give a more human friendly error message"
ZdcPluginMissing signal ] in ZdcPluginSSLSession>>initialize
	Receiver: a ZdcPluginSSLSession
	Arguments and temporary variables: 
		exception: 	PrimitiveFailed: primitive #primitiveSSLCreate in ZdcPluginSSLSessio...etc...
	Receiver's instance variables: 
		handle: 	nil


BlockClosure>>cull:
	Receiver: [ :exception | 
"Give a more human friendly error message"
ZdcPluginMissing signal ]
	Arguments and temporary variables: 
		anArg: 	PrimitiveFailed: primitive #primitiveSSLCreate in ZdcPluginSSLSession fa...etc...
	Receiver's instance variables: 
		outerContext: 	ZdcPluginSSLSession>>initialize
		startpc: 	51
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	PrimitiveFailed: primitive #primitiveSSLCreate in ZdcPluginSSLSessio...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	ZdcPluginSSLSession>>initialize
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ handle := self primitiveSSLCreate ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	PrimitiveFailed: primitive #primitiveSSLCreate in ZdcPluginSSLSessio...etc...
	Receiver's instance variables: 
		sender: 	ZdcPluginSSLSession>>initialize
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ handle := self primitiveSSLCreate ]


PrimitiveFailed(Exception)>>signal
	Receiver: PrimitiveFailed: primitive #primitiveSSLCreate in ZdcPluginSSLSession failed
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'primitive #primitiveSSLCreate in ZdcPluginSSLSession failed'
		tag: 	nil
		signaler: 	a ZdcPluginSSLSession
		signalContext: 	PrimitiveFailed(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		selector: 	#primitiveSSLCreate


PrimitiveFailed class(SelectorException class)>>signalFor:
	Receiver: PrimitiveFailed
	Arguments and temporary variables: 
		aSelector: 	#primitiveSSLCreate
	Receiver's instance variables: 
		superclass: 	SelectorException
		methodDict: 	a MethodDictionary(#standardMessageText->PrimitiveFailed>>#standard...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PrimitiveFailed
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


ZdcPluginSSLSession(Object)>>primitiveFailed:
	Receiver: a ZdcPluginSSLSession
	Arguments and temporary variables: 
		selector: 	#primitiveSSLCreate
	Receiver's instance variables: 
		handle: 	nil


ZdcPluginSSLSession(Object)>>primitiveFailed
	Receiver: a ZdcPluginSSLSession
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	nil


ZdcPluginSSLSession>>primitiveSSLCreate
	Receiver: a ZdcPluginSSLSession
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	nil


[ handle := self primitiveSSLCreate ] in ZdcPluginSSLSession>>initialize
	Receiver: a ZdcPluginSSLSession
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	nil


BlockClosure>>on:do:
	Receiver: [ handle := self primitiveSSLCreate ]
	Arguments and temporary variables: 
		exception: 	PrimitiveFailed
		handlerAction: 	[ :exception | 
"Give a more human friendly error message"
ZdcPl...etc...
	Receiver's instance variables: 
		outerContext: 	ZdcPluginSSLSession>>initialize
		startpc: 	41
		numArgs: 	0


ZdcPluginSSLSession>>initialize
	Receiver: a ZdcPluginSSLSession
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	nil


ZdcPluginSSLSession class(Behavior)>>new
	Receiver: ZdcPluginSSLSession
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ZdcAbstractSSLSession
		methodDict: 	a MethodDictionary(#accept:from:to:into:->ZdcPluginSSLSession>>#acc...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#('handle')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZdcPluginSSLSession
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zodiac-Core'
		traitComposition: 	{}
		localSelectors: 	nil


ZdcSecureSocketStream>>sslSession
	Receiver: a ZdcSecureSocketStream
	Arguments and temporary variables: 

	Receiver's instance variables: 
		socket: 	a Socket[connected]
		readBuffer: 	a ZdcIOBuffer(#[] +16384)
		writeBuffer: 	a ZdcIOBuffer(#[] +4096)
		timeout: 	30
		debug: 	false
		sslSession: 	nil
		in: 	#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0...etc...
		out: 	#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...etc...
		connecting: 	true


ZdcSecureSocketStream>>connect
	Receiver: a ZdcSecureSocketStream
	Arguments and temporary variables: 
		count: 	0
		result: 	nil
	Receiver's instance variables: 
		socket: 	a Socket[connected]
		readBuffer: 	a ZdcIOBuffer(#[] +16384)
		writeBuffer: 	a ZdcIOBuffer(#[] +4096)
		timeout: 	30
		debug: 	false
		sslSession: 	nil
		in: 	#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0...etc...
		out: 	#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...etc...
		connecting: 	true


ZnClient>>newConnectionTo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		url: 	https://api.flickr.com:443/services/xmlrpc/
		initialMilliseconds: 	3872153
		proxied: 	false
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>getConnectionAndExecute
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithRedirectsRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		redirectCount: 	3
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	0
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRedirectsRemaining: self maxNumberOfRedirects ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :exception | 
retryCount > 0
	ifTrue: [ 
		self
			handleRetry...etc...
	Receiver's instance variables: 
		outerContext: 	ZnClient>>executeWithRetriesRemaining:
		startpc: 	49
		numArgs: 	0


ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	0
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ self executeWithRetriesRemaining: self numberOfRetries ] in [ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRetriesRemaining: self numberOfRetries ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :exception | exception pass ]
	Receiver's instance variables: 
		outerContext: 	[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on...etc...
		startpc: 	46
		numArgs: 	0


[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ 
p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


BlockClosure>>ensure:
	Receiver: [ 
p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnConnectionTimeout(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


ZnConnectionTimeout class(DynamicVariable class)>>value:during:
	Receiver: ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnConnectionTimeout
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		hash: 	972029952
		soleInstance: 	a ZnConnectionTimeout


ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ result := self executeWithTimeout ] in ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


[ 
p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	false
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ 
p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnSignalProgress(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	false
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


ZnSignalProgress class(DynamicVariable class)>>value:during:
	Receiver: ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	false
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnSignalProgress
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		hash: 	nil
		soleInstance: 	a ZnSignalProgress


ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3


ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(POST /services/xmlrpc/)
		response: 	nil
		connection: 	a ZdcSecureSocketStream
		lastUsed: 	nil
		options: 	a Dictionary(#oneShot->true )
		session: 	nil
		logLevel: 	3



--- The full stack ---
[ :exception | 
"Give a more human friendly error message"
ZdcPluginMissing signal ] in ZdcPluginSSLSession>>initialize
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
PrimitiveFailed(Exception)>>signal
PrimitiveFailed class(SelectorException class)>>signalFor:
ZdcPluginSSLSession(Object)>>primitiveFailed:
ZdcPluginSSLSession(Object)>>primitiveFailed
ZdcPluginSSLSession>>primitiveSSLCreate
[ handle := self primitiveSSLCreate ] in ZdcPluginSSLSession>>initialize
BlockClosure>>on:do:
ZdcPluginSSLSession>>initialize
ZdcPluginSSLSession class(Behavior)>>new
ZdcSecureSocketStream>>sslSession
ZdcSecureSocketStream>>connect
ZnClient>>newConnectionTo:
ZnClient>>getConnectionAndExecute
ZnClient>>executeWithRedirectsRemaining:
[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
BlockClosure>>on:do:
ZnClient>>executeWithRetriesRemaining:
[ self executeWithRetriesRemaining: self numberOfRetries ] in [ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
BlockClosure>>on:do:
[ 
[ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
[ ^ block value ] in ZnClient>>withTimeoutDo:
[ 
p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnConnectionTimeout(DynamicVariable)>>value:during:
ZnConnectionTimeout class(DynamicVariable class)>>value:during:
ZnClient>>withTimeoutDo:
ZnClient>>executeWithTimeout
[ result := self executeWithTimeout ] in ZnClient>>execute
[ ^ block value ] in ZnClient>>withProgressDo:
[ 
p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnSignalProgress(DynamicVariable)>>value:during:
ZnSignalProgress class(DynamicVariable class)>>value:during:
ZnClient>>withProgressDo:
ZnClient>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ZnClient>>post
ZnEasy class>>post:data:
XMLRPCProxy>>sendXmlRpc:
XMLRPCProxy>>invokeMethod:withStruct:
XMLRPCFlickrTest>>testEchoFlickr
XMLRPCFlickrTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in XMLRPCFlickrTest(TestCase)>>runCase
BlockClosure>>ensure:
XMLRPCFlickrTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in XMLRPCFlickrTest(TestCase)>>debug
BlockClosure>>ensure:
XMLRPCFlickrTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>systemState
30 November 2015 5:26:54.68123 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>doesNotUnderstand: #systemState
	Receiver: #(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosout' #('/rosout')))...etc...
	Arguments and temporary variables: 
		aMessage: 	systemState
		exception: 	MessageNotUnderstood: Array>>systemState
		resumeValue: 	nil
	Receiver's instance variables: 
#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosout' #('/rosout')))...etc...

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://lo...etc...
		itsSelection: 	a Text for '| proxy systemState |
proxy := XMLRPCProxy withUrl:''...etc...
		itsSelectionString: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http:...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| proxy systemState |
	proxy := XMLRPCProxy withUrl: 'http://localho...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | t selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@88)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubCursor(425721856) a RubPrimarySelectionMorph(603193344...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(373030912))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(21495808))(a RubE...etc...
		lastStepTime: 	3881803
		lastStepMessage: 	nil
		lastCycleTime: 	3881823
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3881803
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Sy...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(21495808))(a RubE...etc...
		lastStepTime: 	3881803
		lastStepMessage: 	nil
		lastCycleTime: 	3881823
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3881803
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(21495808))(a RubE...etc...
		lastStepTime: 	3881803
		lastStepMessage: 	nil
		lastCycleTime: 	3881823
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	3881803
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Sy...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #systemState
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "true" is nil
30 November 2015 5:42:44.133231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #true
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	true
		exception: 	MessageNotUnderstood: receiver of "true" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ no true
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	4831263
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 
		anArgument: 	4831273
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	4831263
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	4831273
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4831293
		lastStepMessage: 	nil
		lastCycleTime: 	4831293
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	4831293
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		now: 	4831273
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4831293
		lastStepMessage: 	nil
		lastCycleTime: 	4831293
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	4831293
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4831293
		lastStepMessage: 	nil
		lastCycleTime: 	4831293
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	4831293
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1016594432) a G...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4831293
		lastStepMessage: 	nil
		lastCycleTime: 	4831293
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	4831293
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4831293
		lastStepMessage: 	nil
		lastCycleTime: 	4831293
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	4831293
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1016594432) a G...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #true
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "true" is nil
30 November 2015 5:43:26.087236 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #true
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	true
		exception: 	MessageNotUnderstood: receiver of "true" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ not true
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(944504832)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (285@31)
		owner: 	a TransformWithLayoutMorph(451149824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1019478016) a RubCursor(31719424...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (348913664) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(412876800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(317194240)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(249036800))
		getMenuPolicy: 	a RubEditingArea(944504832)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4873193
		lastStepMessage: 	nil
		lastCycleTime: 	4873215
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	4873193
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1016594432) a G...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4873193
		lastStepMessage: 	nil
		lastCycleTime: 	4873215
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	4873193
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4873193
		lastStepMessage: 	nil
		lastCycleTime: 	4873215
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	4873193
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1016594432) a G...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #true
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Graph>>names
30 November 2015 5:44:07.807231 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Graph(Object)>>doesNotUnderstand: #names
	Receiver: a Graph
	Arguments and temporary variables: 
		aMessage: 	names
		exception: 	MessageNotUnderstood: Graph>>names
		resumeValue: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ graphObj names: graphObj names not ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:
	Receiver: [ graphObj names: graphObj names not ]
	Arguments and temporary variables: 
		anArg: 	false
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializePresenter
		startpc: 	34
		numArgs: 	0


BlockClosure>>cull:cull:
	Receiver: [ graphObj names: graphObj names not ]
	Arguments and temporary variables: 
		firstArg: 	false
		secondArg: 	true
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializePresenter
		startpc: 	34
		numArgs: 	0


BlockClosure>>cull:cull:cull:
	Receiver: [ graphObj names: graphObj names not ]
	Arguments and temporary variables: 
		firstArg: 	false
		secondArg: 	true
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializePresenter
		startpc: 	34
		numArgs: 	0


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ graphObj names: graphObj names not ]
	Arguments and temporary variables: 
		firstArg: 	false
		secondArg: 	true
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializePresenter
		startpc: 	34
		numArgs: 	0


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ false ]
	Arguments and temporary variables: 
		aBlock: 	[ graphObj names: graphObj names not ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	false


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ false ]
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ false ]
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription)
		startIndex: 	1
		index: 	2
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	2
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		announcement: 	a ValueChanged
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


NewValueHolder>>valueChanged:
	Receiver: a NewValueHolder[ false ]
	Arguments and temporary variables: 
		oldValue: 	true
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	false


[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
	Receiver: a NewValueHolder[ false ]
	Arguments and temporary variables: 
		anObject: 	false
		oldValue: 	true
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	false


BlockClosure>>ensure:
	Receiver: [ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ]
	Arguments and temporary variables: 
		aBlock: 	[ lock := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>value:
		startpc: 	27
		numArgs: 	0


NewValueHolder>>handleCircularReferencesWhile:
	Receiver: a NewValueHolder[ false ]
	Arguments and temporary variables: 
		aBlock: 	[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	false


NewValueHolder>>value:
	Receiver: a NewValueHolder[ false ]
	Arguments and temporary variables: 
		anObject: 	false
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	false


CheckBoxModel>>state:
	Receiver: a CheckBoxModel
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicCheckBoxAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Checkbox Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionWhenActivatedHolder: 	a NewValueHolder[ [  ] ]
		actionWhenDesactivatedHolder: 	a NewValueHolder[ [  ] ]
		stateHolder: 	a NewValueHolder[ false ]
		labelClickableHolder: 	a NewValueHolder[ true ]
		labelHolder: 	a CollectionValueHolder[ 'showName' ]


MorphicCheckBoxAdapter>>state:
	Receiver: a MorphicCheckBoxAdapter
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CheckboxMorph(638058496))
		model: 	a CheckBoxModel
		widget: 	a CheckboxMorph(638058496)
		selector: 	nil


CheckboxMorph>>toggleSelected
	Receiver: a CheckboxMorph(638058496)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1155.0@252.0) corner: (1285.0@273.0)
		owner: 	a PanelMorph(297533440)
		submorphs: 	an Array(3PButton(#toggleSelected 12582912) a LabelMorph(1023410176)...etc...
		fullBounds: 	(1155@252) corner: (1285@273)
		color: 	Color transparent
		extension: 	a MorphExtension (726401024) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	2
		borderColor: 	Color transparent
		model: 	a MorphicCheckBoxAdapter
		buttonMorph: 	3PButton(#toggleSelected 12582912)
		labelMorph: 	a LabelMorph(1023410176)'showName'
		getLabelSelector: 	nil
		setStateSelector: 	#state:
		getStateSelector: 	#state
		enabled: 	true
		getEnabledSelector: 	nil
		labelClickable: 	true


[ target perform: actionSelector withArguments: arguments ] in CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
	Receiver: 3PButton(#toggleSelected 12582912)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1157.0@255.0) corner: (1171.0@269.0)
		owner: 	a CheckboxMorph(638058496)
		submorphs: 	#()
		fullBounds: 	(1157.0@255.0) corner: (1171.0@269.0)
		color: 	Color transparent
		extension: 	a MorphExtension (103546880) [eventHandler = a MorphicEventHandler] ...etc...
		image: 	Form(12x12x32)
		offImage: 	nil
		pressedImage: 	nil
		state: 	#off
		target: 	a CheckboxMorph(638058496)
		actionSelector: 	#toggleSelected
		arguments: 	#()
		actWhen: 	#buttonUp
		repressedImage: 	nil
		enabled: 	true
		isRadioButton: 	false
		images: 	a Dictionary(#off->[ self offImage ] #on->[ self onImage ] #pressed->[ ...etc...


BlockClosure>>ensure:
	Receiver: [ target perform: actionSelector withArguments: arguments ]
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
		startpc: 	64
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ target perform: actionSelector withArguments: arguments ]
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
	Receiver: 3PButton(#toggleSelected 12582912)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1157.0@255.0) corner: (1171.0@269.0)
		owner: 	a CheckboxMorph(638058496)
		submorphs: 	#()
		fullBounds: 	(1157.0@255.0) corner: (1171.0@269.0)
		color: 	Color transparent
		extension: 	a MorphExtension (103546880) [eventHandler = a MorphicEventHandler] ...etc...
		image: 	Form(12x12x32)
		offImage: 	nil
		pressedImage: 	nil
		state: 	#off
		target: 	a CheckboxMorph(638058496)
		actionSelector: 	#toggleSelected
		arguments: 	#()
		actWhen: 	#buttonUp
		repressedImage: 	nil
		enabled: 	true
		isRadioButton: 	false
		images: 	a Dictionary(#off->[ self offImage ] #on->[ self onImage ] #pressed->[ ...etc...


CheckboxMorph>>updateButton:
	Receiver: a CheckboxMorph(638058496)
	Arguments and temporary variables: 
		evt: 	[(1189@266) mouseUp 4914935 nil]
	Receiver's instance variables: 
		bounds: 	(1155.0@252.0) corner: (1285.0@273.0)
		owner: 	a PanelMorph(297533440)
		submorphs: 	an Array(3PButton(#toggleSelected 12582912) a LabelMorph(1023410176)...etc...
		fullBounds: 	(1155@252) corner: (1285@273)
		color: 	Color transparent
		extension: 	a MorphExtension (726401024) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	2
		borderColor: 	Color transparent
		model: 	a MorphicCheckBoxAdapter
		buttonMorph: 	3PButton(#toggleSelected 12582912)
		labelMorph: 	a LabelMorph(1023410176)'showName'
		getLabelSelector: 	nil
		setStateSelector: 	#state:
		getStateSelector: 	#state
		enabled: 	true
		getEnabledSelector: 	nil
		labelClickable: 	true


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(1189@266) mouseUp 4914935 nil]
		sourceMorph: 	a CheckboxMorph(638058496)
		arity: 	1
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#updateButton:
		recipient: 	a CheckboxMorph(638058496)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1189@266) mouseUp 4914935 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a CheckboxMorph(638058496)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#click->a Set(a MorphEventSubscription) #mouseMove-...etc...


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) == tru...etc...
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(1189@266) mouseUp 4914935 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a CheckboxMorph(638058496)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#click->a Set(a MorphEventSubscription) #mouseMove-...etc...


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(1189@266) mouseUp 4914935 nil]
		sourceMorph: 	a CheckboxMorph(638058496)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#click->a Set(a MorphEventSubscription) #mouseMove-...etc...


CheckboxMorph(Morph)>>mouseUp:
	Receiver: a CheckboxMorph(638058496)
	Arguments and temporary variables: 
		evt: 	[(1189@266) mouseUp 4914935 nil]
	Receiver's instance variables: 
		bounds: 	(1155.0@252.0) corner: (1285.0@273.0)
		owner: 	a PanelMorph(297533440)
		submorphs: 	an Array(3PButton(#toggleSelected 12582912) a LabelMorph(1023410176)...etc...
		fullBounds: 	(1155@252) corner: (1285@273)
		color: 	Color transparent
		extension: 	a MorphExtension (726401024) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	2
		borderColor: 	Color transparent
		model: 	a MorphicCheckBoxAdapter
		buttonMorph: 	3PButton(#toggleSelected 12582912)
		labelMorph: 	a LabelMorph(1023410176)'showName'
		getLabelSelector: 	nil
		setStateSelector: 	#state:
		getStateSelector: 	#state
		enabled: 	true
		getEnabledSelector: 	nil
		labelClickable: 	true


CheckboxMorph(Morph)>>handleMouseUp:
	Receiver: a CheckboxMorph(638058496)
	Arguments and temporary variables: 
		anEvent: 	[(1189@266) mouseUp 4914935 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1155.0@252.0) corner: (1285.0@273.0)
		owner: 	a PanelMorph(297533440)
		submorphs: 	an Array(3PButton(#toggleSelected 12582912) a LabelMorph(1023410176)...etc...
		fullBounds: 	(1155@252) corner: (1285@273)
		color: 	Color transparent
		extension: 	a MorphExtension (726401024) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	2
		borderColor: 	Color transparent
		model: 	a MorphicCheckBoxAdapter
		buttonMorph: 	3PButton(#toggleSelected 12582912)
		labelMorph: 	a LabelMorph(1023410176)'showName'
		getLabelSelector: 	nil
		setStateSelector: 	#state:
		getStateSelector: 	#state
		enabled: 	true
		getEnabledSelector: 	nil
		labelClickable: 	true


MouseButtonEvent>>sentTo:
	Receiver: [(1189@266) mouseUp 4914935 nil]
	Arguments and temporary variables: 
		anObject: 	a CheckboxMorph(638058496)
	Receiver's instance variables: 
		timeStamp: 	4914935
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1189@266)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4



--- The full stack ---
Graph(Object)>>doesNotUnderstand: #names
[ graphObj names: graphObj names not ] in RQTGMainWindow>>initializePresenter
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
CheckBoxModel>>state:
MorphicCheckBoxAdapter>>state:
CheckboxMorph>>toggleSelected
[ target perform: actionSelector withArguments: arguments ] in CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
CheckboxMorph>>updateButton:
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
CheckboxMorph(Morph)>>mouseUp:
CheckboxMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CheckboxMorph(Morph)>>handleEvent:
CheckboxMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:02:33.064183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ 
		item show: value.
		self halt ] ] in HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic a Topic a Topic a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ 
		item show: value.
		sel...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(a Topic a Topic a Topic a Topic nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(563609600))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(563609600)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(563609600)
	Arguments and temporary variables: 
		event: 	[(1449@715) mouseUp 629910 nil]
	Receiver's instance variables: 
		bounds: 	(1337.0@689.0) corner: (1532.0@718.0)
		owner: 	a PanelMorph(222560256)
		submorphs: 	an Array(an AlignmentMorph(318242816))
		fullBounds: 	(1337@689) corner: (1532@718)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (630980608) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(400293888)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(563609600)
	Arguments and temporary variables: 
		evt: 	[(1449@715) mouseUp 629910 nil]
		all: 	an Array(a PluggableButtonMorph(773849088) a PluggableButtonMorph(56360960...etc...
		m: 	a PluggableButtonMorph(563609600)
	Receiver's instance variables: 
		bounds: 	(1337.0@689.0) corner: (1532.0@718.0)
		owner: 	a PanelMorph(222560256)
		submorphs: 	an Array(an AlignmentMorph(318242816))
		fullBounds: 	(1337@689) corner: (1532@718)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (630980608) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(400293888)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(773849088) a PluggableButtonMorph(563609600))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(773849088) a PluggableButtonMorph(563609600))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(563609600)
	Arguments and temporary variables: 
		evt: 	[(1449@715) mouseUp 629910 nil]
		all: 	an Array(a PluggableButtonMorph(773849088) a PluggableButtonMorph(56360960...etc...
	Receiver's instance variables: 
		bounds: 	(1337.0@689.0) corner: (1532.0@718.0)
		owner: 	a PanelMorph(222560256)
		submorphs: 	an Array(an AlignmentMorph(318242816))
		fullBounds: 	(1337@689) corner: (1532@718)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (630980608) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(400293888)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(563609600)
	Arguments and temporary variables: 
		anEvent: 	[(1449@715) mouseUp 629910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1337.0@689.0) corner: (1532.0@718.0)
		owner: 	a PanelMorph(222560256)
		submorphs: 	an Array(an AlignmentMorph(318242816))
		fullBounds: 	(1337@689) corner: (1532@718)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (630980608) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(400293888)


MouseButtonEvent>>sentTo:
	Receiver: [(1449@715) mouseUp 629910 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(563609600)
	Receiver's instance variables: 
		timeStamp: 	629910
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1449@715)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(563609600)
	Arguments and temporary variables: 
		anEvent: 	[(1449@715) mouseUp 629910 nil]
	Receiver's instance variables: 
		bounds: 	(1337.0@689.0) corner: (1532.0@718.0)
		owner: 	a PanelMorph(222560256)
		submorphs: 	an Array(an AlignmentMorph(318242816))
		fullBounds: 	(1337@689) corner: (1532@718)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (630980608) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(400293888)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(563609600)
	Arguments and temporary variables: 
		anEvent: 	[(1449@715) mouseUp 629910 nil]
	Receiver's instance variables: 
		bounds: 	(1337.0@689.0) corner: (1532.0@718.0)
		owner: 	a PanelMorph(222560256)
		submorphs: 	an Array(an AlignmentMorph(318242816))
		fullBounds: 	(1337@689) corner: (1532@718)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (630980608) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(400293888)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1449@715) mouseUp 629910 nil]
		focusHolder: 	a PluggableButtonMorph(563609600)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1449@715) corner: (1465@731)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1449@715) corner: (1465@731)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(563609600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1449@715) mouseOver nil nil]
		targetOffset: 	(112.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 629910 1449 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1449@715) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(717225984) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1449@715) mouseUp 629910 nil]
		focusHolder: 	a PluggableButtonMorph(563609600)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1449@715) corner: (1465@731)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1449@715) corner: (1465@731)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(563609600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1449@715) mouseOver nil nil]
		targetOffset: 	(112.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 629910 1449 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1449@715) mouseUp 629910 nil]
		focusHolder: 	a PluggableButtonMorph(563609600)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1449@715) corner: (1465@731)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1449@715) corner: (1465@731)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(563609600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1449@715) mouseOver nil nil]
		targetOffset: 	(112.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 629910 1449 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1449@715) mouseUp 629910 nil]
	Receiver's instance variables: 
		bounds: 	(1449@715) corner: (1465@731)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1449@715) corner: (1465@731)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(563609600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1449@715) mouseOver nil nil]
		targetOffset: 	(112.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 629910 1449 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1449@715) mouseUp 629910 nil]
		evt: 	[(1449@715) mouseUp 629910 nil]
	Receiver's instance variables: 
		bounds: 	(1449@715) corner: (1465@731)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1449@715) corner: (1465@731)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(563609600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1449@715) mouseOver nil nil]
		targetOffset: 	(112.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 629910 1449 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1449@715) mouseUp 629910 nil]
		evtBuf: 	#(1 629910 1449 715 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1449@715) corner: (1465@731)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1449@715) corner: (1465@731)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(563609600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1449@715) mouseOver nil nil]
		targetOffset: 	(112.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 629910 1449 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(56623104))(a TRMorph(5662310...etc...
		lastStepTime: 	629982
		lastStepMessage: 	nil
		lastCycleTime: 	629982
		alarms: 	a Heap()
		lastAlarmTime: 	629982
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(56623104))(a TRMorph(5662310...etc...
		lastStepTime: 	629982
		lastStepMessage: 	nil
		lastCycleTime: 	629982
		alarms: 	a Heap()
		lastAlarmTime: 	629982
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(56623104))(a TRMorph(5662310...etc...
		lastStepTime: 	629982
		lastStepMessage: 	nil
		lastCycleTime: 	629982
		alarms: 	a Heap()
		lastAlarmTime: 	629982
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(56623104))(a TRMorph(5662310...etc...
		lastStepTime: 	629982
		lastStepMessage: 	nil
		lastCycleTime: 	629982
		alarms: 	a Heap()
		lastAlarmTime: 	629982
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(717225984) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ 
		item show: value.
		self halt ] ] in HideWindow>>listChange:with:
OrderedCollection>>do:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:04:46.696183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(610009088))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(610009088)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(610009088)
	Arguments and temporary variables: 
		event: 	[(1469@672) mouseUp 763548 nil]
	Receiver's instance variables: 
		bounds: 	(1301.0@649.0) corner: (1496.0@678.0)
		owner: 	a PanelMorph(17825792)
		submorphs: 	an Array(an AlignmentMorph(364642304))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (677380096) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(446693376)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(610009088)
	Arguments and temporary variables: 
		evt: 	[(1469@672) mouseUp 763548 nil]
		all: 	an Array(a PluggableButtonMorph(814219264) a PluggableButtonMorph(61000908...etc...
		m: 	a PluggableButtonMorph(610009088)
	Receiver's instance variables: 
		bounds: 	(1301.0@649.0) corner: (1496.0@678.0)
		owner: 	a PanelMorph(17825792)
		submorphs: 	an Array(an AlignmentMorph(364642304))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (677380096) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(446693376)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(814219264) a PluggableButtonMorph(610009088))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(814219264) a PluggableButtonMorph(610009088))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(610009088)
	Arguments and temporary variables: 
		evt: 	[(1469@672) mouseUp 763548 nil]
		all: 	an Array(a PluggableButtonMorph(814219264) a PluggableButtonMorph(61000908...etc...
	Receiver's instance variables: 
		bounds: 	(1301.0@649.0) corner: (1496.0@678.0)
		owner: 	a PanelMorph(17825792)
		submorphs: 	an Array(an AlignmentMorph(364642304))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (677380096) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(446693376)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(610009088)
	Arguments and temporary variables: 
		anEvent: 	[(1469@672) mouseUp 763548 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1301.0@649.0) corner: (1496.0@678.0)
		owner: 	a PanelMorph(17825792)
		submorphs: 	an Array(an AlignmentMorph(364642304))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (677380096) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(446693376)


MouseButtonEvent>>sentTo:
	Receiver: [(1469@672) mouseUp 763548 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(610009088)
	Receiver's instance variables: 
		timeStamp: 	763548
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1469@672)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(610009088)
	Arguments and temporary variables: 
		anEvent: 	[(1469@672) mouseUp 763548 nil]
	Receiver's instance variables: 
		bounds: 	(1301.0@649.0) corner: (1496.0@678.0)
		owner: 	a PanelMorph(17825792)
		submorphs: 	an Array(an AlignmentMorph(364642304))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (677380096) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(446693376)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(610009088)
	Arguments and temporary variables: 
		anEvent: 	[(1469@672) mouseUp 763548 nil]
	Receiver's instance variables: 
		bounds: 	(1301.0@649.0) corner: (1496.0@678.0)
		owner: 	a PanelMorph(17825792)
		submorphs: 	an Array(an AlignmentMorph(364642304))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (677380096) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(446693376)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1469@672) mouseUp 763548 nil]
		focusHolder: 	a PluggableButtonMorph(610009088)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1469@672) corner: (1485@688)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1469@672) corner: (1485@688)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(610009088)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1469@672) mouseUp 763548 nil]
		targetOffset: 	(168.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 763548 1469 672 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1469@672) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(697040896) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1469@672) mouseUp 763548 nil]
		focusHolder: 	a PluggableButtonMorph(610009088)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1469@672) corner: (1485@688)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1469@672) corner: (1485@688)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(610009088)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1469@672) mouseUp 763548 nil]
		targetOffset: 	(168.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 763548 1469 672 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1469@672) mouseUp 763548 nil]
		focusHolder: 	a PluggableButtonMorph(610009088)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1469@672) corner: (1485@688)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1469@672) corner: (1485@688)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(610009088)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1469@672) mouseUp 763548 nil]
		targetOffset: 	(168.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 763548 1469 672 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1469@672) mouseUp 763548 nil]
	Receiver's instance variables: 
		bounds: 	(1469@672) corner: (1485@688)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1469@672) corner: (1485@688)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(610009088)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1469@672) mouseUp 763548 nil]
		targetOffset: 	(168.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 763548 1469 672 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1469@672) mouseUp 763548 nil]
		evt: 	[(1469@672) mouseUp 763548 nil]
	Receiver's instance variables: 
		bounds: 	(1469@672) corner: (1485@688)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1469@672) corner: (1485@688)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(610009088)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1469@672) mouseUp 763548 nil]
		targetOffset: 	(168.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 763548 1469 672 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1469@672) mouseUp 763548 nil]
		evtBuf: 	#(1 763548 1469 672 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1469@672) corner: (1485@688)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1469@672) corner: (1485@688)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(610009088)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1469@672) mouseUp 763548 nil]
		targetOffset: 	(168.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 763548 1469 672 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(135004160))(a TRMorph(135004...etc...
		lastStepTime: 	763538
		lastStepMessage: 	nil
		lastCycleTime: 	763558
		alarms: 	a Heap()
		lastAlarmTime: 	763538
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(135004160))(a TRMorph(135004...etc...
		lastStepTime: 	763538
		lastStepMessage: 	nil
		lastCycleTime: 	763558
		alarms: 	a Heap()
		lastAlarmTime: 	763538
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(135004160))(a TRMorph(135004...etc...
		lastStepTime: 	763538
		lastStepMessage: 	nil
		lastCycleTime: 	763558
		alarms: 	a Heap()
		lastAlarmTime: 	763538
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(135004160))(a TRMorph(135004...etc...
		lastStepTime: 	763538
		lastStepMessage: 	nil
		lastCycleTime: 	763558
		alarms: 	a Heap()
		lastAlarmTime: 	763538
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(697040896) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:07:43.324183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(181141504))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(181141504)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		event: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
		m: 	a PluggableButtonMorph(181141504)
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


MouseButtonEvent>>sentTo:
	Receiver: [(1244@895) mouseUp 940178 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(181141504)
	Receiver's instance variables: 
		timeStamp: 	940178
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1244@895)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1244@895) corner: (1260@911)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@895) corner: (1260@911)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(181141504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@895) mouseUp 940178 nil]
		targetOffset: 	(112.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 940178 1244 895 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1244@895) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(180617216) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1244@895) corner: (1260@911)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@895) corner: (1260@911)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(181141504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@895) mouseUp 940178 nil]
		targetOffset: 	(112.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 940178 1244 895 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1244@895) corner: (1260@911)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@895) corner: (1260@911)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(181141504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@895) mouseUp 940178 nil]
		targetOffset: 	(112.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 940178 1244 895 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1244@895) corner: (1260@911)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@895) corner: (1260@911)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(181141504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@895) mouseUp 940178 nil]
		targetOffset: 	(112.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 940178 1244 895 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		evt: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1244@895) corner: (1260@911)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@895) corner: (1260@911)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(181141504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@895) mouseUp 940178 nil]
		targetOffset: 	(112.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 940178 1244 895 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		evtBuf: 	#(1 940178 1244 895 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1244@895) corner: (1260@911)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@895) corner: (1260@911)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(181141504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@895) mouseUp 940178 nil]
		targetOffset: 	(112.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 940178 1244 895 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	940210
		lastStepMessage: 	nil
		lastCycleTime: 	940208
		alarms: 	a Heap()
		lastAlarmTime: 	940210
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	940210
		lastStepMessage: 	nil
		lastCycleTime: 	940208
		alarms: 	a Heap()
		lastAlarmTime: 	940210
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	940210
		lastStepMessage: 	nil
		lastCycleTime: 	940208
		alarms: 	a Heap()
		lastAlarmTime: 	940210
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	940210
		lastStepMessage: 	nil
		lastCycleTime: 	940208
		alarms: 	a Heap()
		lastAlarmTime: 	940210
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(180617216) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:07:44.784183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(181141504))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(181141504)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		event: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
		m: 	a PluggableButtonMorph(181141504)
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


MouseButtonEvent>>sentTo:
	Receiver: [(1244@895) mouseUp 940178 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(181141504)
	Receiver's instance variables: 
		timeStamp: 	940178
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1244@895)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1274@678) corner: (1290@694)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1274@678) corner: (1290@694)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(492306432)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1274@678) mouseUp 941640 nil]
		targetOffset: 	(122.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 941640 1274 678 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1244@895) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(898629632) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1274@678) corner: (1290@694)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1274@678) corner: (1290@694)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(492306432)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1274@678) mouseUp 941640 nil]
		targetOffset: 	(122.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 941640 1274 678 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1274@678) corner: (1290@694)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1274@678) corner: (1290@694)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(492306432)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1274@678) mouseUp 941640 nil]
		targetOffset: 	(122.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 941640 1274 678 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1274@678) corner: (1290@694)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1274@678) corner: (1290@694)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(492306432)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1274@678) mouseUp 941640 nil]
		targetOffset: 	(122.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 941640 1274 678 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		evt: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1274@678) corner: (1290@694)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1274@678) corner: (1290@694)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(492306432)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1274@678) mouseUp 941640 nil]
		targetOffset: 	(122.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 941640 1274 678 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		evtBuf: 	#(1 940178 1244 895 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1274@678) corner: (1290@694)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1274@678) corner: (1290@694)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(492306432)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1274@678) mouseUp 941640 nil]
		targetOffset: 	(122.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 941640 1274 678 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	941630
		lastStepMessage: 	nil
		lastCycleTime: 	941650
		alarms: 	a Heap()
		lastAlarmTime: 	941630
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	941678
		lastStepMessage: 	nil
		lastCycleTime: 	941672
		alarms: 	a Heap()
		lastAlarmTime: 	941678
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	941678
		lastStepMessage: 	nil
		lastCycleTime: 	941672
		alarms: 	a Heap()
		lastAlarmTime: 	941678
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	941678
		lastStepMessage: 	nil
		lastCycleTime: 	941672
		alarms: 	a Heap()
		lastAlarmTime: 	941678
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(180617216) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:07:45.548183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(181141504))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(181141504)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		event: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
		m: 	a PluggableButtonMorph(181141504)
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


MouseButtonEvent>>sentTo:
	Receiver: [(1244@895) mouseUp 940178 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(181141504)
	Receiver's instance variables: 
		timeStamp: 	940178
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1244@895)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1260@687) corner: (1276@703)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1260@687) corner: (1276@703)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(372506624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1260@687) mouseUp 942410 nil]
		targetOffset: 	(102.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 942410 1260 687 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1244@895) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(342097920) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1260@687) corner: (1276@703)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1260@687) corner: (1276@703)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(372506624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1260@687) mouseUp 942410 nil]
		targetOffset: 	(102.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 942410 1260 687 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1260@687) corner: (1276@703)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1260@687) corner: (1276@703)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(372506624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1260@687) mouseUp 942410 nil]
		targetOffset: 	(102.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 942410 1260 687 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1260@687) corner: (1276@703)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1260@687) corner: (1276@703)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(372506624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1260@687) mouseUp 942410 nil]
		targetOffset: 	(102.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 942410 1260 687 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		evt: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1260@687) corner: (1276@703)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1260@687) corner: (1276@703)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(372506624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1260@687) mouseUp 942410 nil]
		targetOffset: 	(102.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 942410 1260 687 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		evtBuf: 	#(1 940178 1244 895 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1260@687) corner: (1276@703)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1260@687) corner: (1276@703)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(372506624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1260@687) mouseUp 942410 nil]
		targetOffset: 	(102.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 942410 1260 687 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	942394
		lastStepMessage: 	nil
		lastCycleTime: 	942414
		alarms: 	a Heap()
		lastAlarmTime: 	942394
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	942394
		lastStepMessage: 	nil
		lastCycleTime: 	942436
		alarms: 	a Heap()
		lastAlarmTime: 	942442
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	942442
		lastStepMessage: 	nil
		lastCycleTime: 	942436
		alarms: 	a Heap()
		lastAlarmTime: 	942442
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	942442
		lastStepMessage: 	nil
		lastCycleTime: 	942436
		alarms: 	a Heap()
		lastAlarmTime: 	942442
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(180617216) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:07:46.154183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(181141504))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(181141504)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		event: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
		m: 	a PluggableButtonMorph(181141504)
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


MouseButtonEvent>>sentTo:
	Receiver: [(1244@895) mouseUp 940178 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(181141504)
	Receiver's instance variables: 
		timeStamp: 	940178
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1244@895)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(181141504)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1132.0@881.0) corner: (1327.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(1003487232))
		fullBounds: 	(1132@881) corner: (1327@910)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (248512512) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(11796480)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1250@722) corner: (1266@738)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1250@722) corner: (1266@738)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(432799744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1250@722) mouseUp 943004 nil]
		targetOffset: 	(92.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 943004 1250 722 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1244@895) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(393478144) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1250@722) corner: (1266@738)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1250@722) corner: (1266@738)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(432799744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1250@722) mouseUp 943004 nil]
		targetOffset: 	(92.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 943004 1250 722 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		focusHolder: 	a PluggableButtonMorph(181141504)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1250@722) corner: (1266@738)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1250@722) corner: (1266@738)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(432799744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1250@722) mouseUp 943004 nil]
		targetOffset: 	(92.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 943004 1250 722 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1250@722) corner: (1266@738)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1250@722) corner: (1266@738)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(432799744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1250@722) mouseUp 943004 nil]
		targetOffset: 	(92.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 943004 1250 722 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@895) mouseUp 940178 nil]
		evt: 	[(1244@895) mouseUp 940178 nil]
	Receiver's instance variables: 
		bounds: 	(1250@722) corner: (1266@738)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1250@722) corner: (1266@738)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(432799744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1250@722) mouseUp 943004 nil]
		targetOffset: 	(92.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 943004 1250 722 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1244@895) mouseUp 940178 nil]
		evtBuf: 	#(1 940178 1244 895 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1250@722) corner: (1266@738)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1250@722) corner: (1266@738)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(432799744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1250@722) mouseUp 943004 nil]
		targetOffset: 	(92.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 943004 1250 722 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	942998
		lastStepMessage: 	nil
		lastCycleTime: 	943018
		alarms: 	a Heap()
		lastAlarmTime: 	942998
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	943046
		lastStepMessage: 	nil
		lastCycleTime: 	943040
		alarms: 	a Heap()
		lastAlarmTime: 	943046
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	943046
		lastStepMessage: 	nil
		lastCycleTime: 	943040
		alarms: 	a Heap()
		lastAlarmTime: 	943046
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	943046
		lastStepMessage: 	nil
		lastCycleTime: 	943040
		alarms: 	a Heap()
		lastAlarmTime: 	943046
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(180617216) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:07:52.168184 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	true
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(323485696))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(323485696)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(323485696)
	Arguments and temporary variables: 
		event: 	[(1358@894) mouseUp 949010 nil]
	Receiver's instance variables: 
		bounds: 	(1331.0@881.0) corner: (1522.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(132382720))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (390856704) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(214433792)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(323485696)
	Arguments and temporary variables: 
		evt: 	[(1358@894) mouseUp 949010 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
		m: 	a PluggableButtonMorph(323485696)
	Receiver's instance variables: 
		bounds: 	(1331.0@881.0) corner: (1522.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(132382720))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (390856704) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(214433792)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(181141504))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(323485696)
	Arguments and temporary variables: 
		evt: 	[(1358@894) mouseUp 949010 nil]
		all: 	an Array(a PluggableButtonMorph(323485696) a PluggableButtonMorph(18114150...etc...
	Receiver's instance variables: 
		bounds: 	(1331.0@881.0) corner: (1522.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(132382720))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (390856704) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(214433792)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(323485696)
	Arguments and temporary variables: 
		anEvent: 	[(1358@894) mouseUp 949010 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1331.0@881.0) corner: (1522.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(132382720))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (390856704) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(214433792)


MouseButtonEvent>>sentTo:
	Receiver: [(1358@894) mouseUp 949010 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(323485696)
	Receiver's instance variables: 
		timeStamp: 	949010
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1358@894)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(323485696)
	Arguments and temporary variables: 
		anEvent: 	[(1358@894) mouseUp 949010 nil]
	Receiver's instance variables: 
		bounds: 	(1331.0@881.0) corner: (1522.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(132382720))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (390856704) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(214433792)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(323485696)
	Arguments and temporary variables: 
		anEvent: 	[(1358@894) mouseUp 949010 nil]
	Receiver's instance variables: 
		bounds: 	(1331.0@881.0) corner: (1522.0@910.0)
		owner: 	a PanelMorph(913833984)
		submorphs: 	an Array(an AlignmentMorph(132382720))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (390856704) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(214433792)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1358@894) mouseUp 949010 nil]
		focusHolder: 	a PluggableButtonMorph(323485696)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1358@894) corner: (1374@910)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1358@894) corner: (1374@910)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(323485696)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1358@894) mouseUp 949010 nil]
		targetOffset: 	(27.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 949010 1358 894 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1358@894) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(180617216) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1358@894) mouseUp 949010 nil]
		focusHolder: 	a PluggableButtonMorph(323485696)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1358@894) corner: (1374@910)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1358@894) corner: (1374@910)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(323485696)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1358@894) mouseUp 949010 nil]
		targetOffset: 	(27.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 949010 1358 894 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1358@894) mouseUp 949010 nil]
		focusHolder: 	a PluggableButtonMorph(323485696)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1358@894) corner: (1374@910)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1358@894) corner: (1374@910)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(323485696)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1358@894) mouseUp 949010 nil]
		targetOffset: 	(27.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 949010 1358 894 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1358@894) mouseUp 949010 nil]
	Receiver's instance variables: 
		bounds: 	(1358@894) corner: (1374@910)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1358@894) corner: (1374@910)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(323485696)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1358@894) mouseUp 949010 nil]
		targetOffset: 	(27.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 949010 1358 894 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1358@894) mouseUp 949010 nil]
		evt: 	[(1358@894) mouseUp 949010 nil]
	Receiver's instance variables: 
		bounds: 	(1358@894) corner: (1374@910)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1358@894) corner: (1374@910)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(323485696)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1358@894) mouseUp 949010 nil]
		targetOffset: 	(27.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 949010 1358 894 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(1358@894) mouseUp 949010 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(1358@894) mouseUp 949010 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a SpecWindow(180617216)
		clickState: 	#firstClickUp
		firstClickDown: 	[(1358@894) mouseDown red 948948 nil]
		firstClickUp: 	[(1358@894) mouseUp 949010 nil]
		firstClickTime: 	948948
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	#doubleClickTimeout:
		dragSelector: 	#startDrag:
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1358@894) mouseUp 949010 nil]
		evt: 	[(1358@894) mouseUp 949010 nil]
	Receiver's instance variables: 
		bounds: 	(1357@894) corner: (1373@910)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1357@894) corner: (1373@910)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(323485696)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1357@894) mouseOver nil nil]
		targetOffset: 	(27.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 949058 1357 894 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1358@894) mouseUp 949010 nil]
		evtBuf: 	#(1 949010 1358 894 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1357@894) corner: (1373@910)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1357@894) corner: (1373@910)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(323485696)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1357@894) mouseOver nil nil]
		targetOffset: 	(27.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 949058 1357 894 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	949058
		lastStepMessage: 	nil
		lastCycleTime: 	949058
		alarms: 	a Heap()
		lastAlarmTime: 	949058
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	949058
		lastStepMessage: 	nil
		lastCycleTime: 	949058
		alarms: 	a Heap()
		lastAlarmTime: 	949058
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	949058
		lastStepMessage: 	nil
		lastCycleTime: 	949058
		alarms: 	a Heap()
		lastAlarmTime: 	949058
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(529268736))(a TRMorph(529268...etc...
		lastStepTime: 	949058
		lastStepMessage: 	nil
		lastCycleTime: 	949058
		alarms: 	a Heap()
		lastAlarmTime: 	949058
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(180617216) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:11:06.372183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Topic nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(304087040))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(304087040)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		event: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		all: 	an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(30408704...etc...
		m: 	a PluggableButtonMorph(304087040)
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(304087040))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(304087040))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		all: 	an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(30408704...etc...
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


MouseButtonEvent>>sentTo:
	Receiver: [(1507@715) mouseUp 1143228 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(304087040)
	Receiver's instance variables: 
		timeStamp: 	1143228
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1507@715)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1507@715.0) corner: (1523@731.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1507@715.0) corner: (1523@731.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(304087040)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1507@715) mouseOver nil nil]
		targetOffset: 	(180.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1143228 1507 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1507@715) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(168558592) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1507@715.0) corner: (1523@731.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1507@715.0) corner: (1523@731.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(304087040)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1507@715) mouseOver nil nil]
		targetOffset: 	(180.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1143228 1507 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1507@715.0) corner: (1523@731.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1507@715.0) corner: (1523@731.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(304087040)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1507@715) mouseOver nil nil]
		targetOffset: 	(180.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1143228 1507 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1507@715.0) corner: (1523@731.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1507@715.0) corner: (1523@731.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(304087040)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1507@715) mouseOver nil nil]
		targetOffset: 	(180.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1143228 1507 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		evt: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1507@715.0) corner: (1523@731.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1507@715.0) corner: (1523@731.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(304087040)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1507@715) mouseOver nil nil]
		targetOffset: 	(180.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1143228 1507 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		evtBuf: 	#(1 1143228 1507 715 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1507@715.0) corner: (1523@731.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1507@715.0) corner: (1523@731.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(304087040)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1507@715) mouseOver nil nil]
		targetOffset: 	(180.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1143228 1507 715 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	1143254
		lastStepMessage: 	nil
		lastCycleTime: 	1143254
		alarms: 	a Heap()
		lastAlarmTime: 	1143254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	1143254
		lastStepMessage: 	nil
		lastCycleTime: 	1143254
		alarms: 	a Heap()
		lastAlarmTime: 	1143254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	1143254
		lastStepMessage: 	nil
		lastCycleTime: 	1143254
		alarms: 	a Heap()
		lastAlarmTime: 	1143254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	1143254
		lastStepMessage: 	nil
		lastCycleTime: 	1143254
		alarms: 	a Heap()
		lastAlarmTime: 	1143254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(168558592) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:11:07.928183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic a Topic a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Topic a Topic a Topic nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(304087040))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(304087040)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		event: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		all: 	an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(30408704...etc...
		m: 	a PluggableButtonMorph(304087040)
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(304087040))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(304087040))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		all: 	an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(30408704...etc...
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


MouseButtonEvent>>sentTo:
	Receiver: [(1507@715) mouseUp 1143228 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(304087040)
	Receiver's instance variables: 
		timeStamp: 	1143228
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1507@715)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1263@495.0) corner: (1279@511.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@495.0) corner: (1279@511.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(421265408)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@495) mouseUp 1144788 nil]
		targetOffset: 	(105.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1144788 1263 495 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1507@715) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(622592000) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1263@495.0) corner: (1279@511.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@495.0) corner: (1279@511.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(421265408)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@495) mouseUp 1144788 nil]
		targetOffset: 	(105.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1144788 1263 495 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1263@495.0) corner: (1279@511.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@495.0) corner: (1279@511.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(421265408)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@495) mouseOver nil nil]
		targetOffset: 	(105.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1144788 1263 495 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1263@495.0) corner: (1279@511.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@495.0) corner: (1279@511.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(421265408)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@495) mouseOver nil nil]
		targetOffset: 	(105.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1144788 1263 495 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		evt: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1263@495.0) corner: (1279@511.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@495.0) corner: (1279@511.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(421265408)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@495) mouseOver nil nil]
		targetOffset: 	(105.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1144788 1263 495 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		evtBuf: 	#(1 1143228 1507 715 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1263@495.0) corner: (1279@511.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@495.0) corner: (1279@511.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(421265408)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@495) mouseOver nil nil]
		targetOffset: 	(105.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1144788 1263 495 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1144820
		lastStepMessage: 	nil
		lastCycleTime: 	1144814
		alarms: 	a Heap()
		lastAlarmTime: 	1144820
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1144820
		lastStepMessage: 	nil
		lastCycleTime: 	1144814
		alarms: 	a Heap()
		lastAlarmTime: 	1144820
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1144820
		lastStepMessage: 	nil
		lastCycleTime: 	1144814
		alarms: 	a Heap()
		lastAlarmTime: 	1144820
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1144820
		lastStepMessage: 	nil
		lastCycleTime: 	1144814
		alarms: 	a Heap()
		lastAlarmTime: 	1144820
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(168558592) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:11:08.622183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic a Topic a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Topic a Topic a Topic nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(304087040))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(304087040)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		event: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		all: 	an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(30408704...etc...
		m: 	a PluggableButtonMorph(304087040)
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(304087040))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(304087040))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		all: 	an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(30408704...etc...
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


MouseButtonEvent>>sentTo:
	Receiver: [(1507@715) mouseUp 1143228 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(304087040)
	Receiver's instance variables: 
		timeStamp: 	1143228
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1507@715)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1263@531.0) corner: (1279@547.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@531.0) corner: (1279@547.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(974651392)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@531) mouseUp 1145484 nil]
		targetOffset: 	(105.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1145484 1263 531 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1507@715) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(963641344) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1263@531.0) corner: (1279@547.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@531.0) corner: (1279@547.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(974651392)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@531) mouseUp 1145484 nil]
		targetOffset: 	(105.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1145484 1263 531 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1263@531.0) corner: (1279@547.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@531.0) corner: (1279@547.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(974651392)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@531) mouseOver nil nil]
		targetOffset: 	(105.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1145484 1263 531 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1263@531.0) corner: (1279@547.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@531.0) corner: (1279@547.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(974651392)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@531) mouseOver nil nil]
		targetOffset: 	(105.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1145484 1263 531 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		evt: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1263@531.0) corner: (1279@547.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@531.0) corner: (1279@547.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(974651392)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@531) mouseOver nil nil]
		targetOffset: 	(105.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1145484 1263 531 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		evtBuf: 	#(1 1143228 1507 715 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1263@531.0) corner: (1279@547.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@531.0) corner: (1279@547.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(974651392)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@531) mouseOver nil nil]
		targetOffset: 	(105.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1145484 1263 531 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1145512
		lastStepMessage: 	nil
		lastCycleTime: 	1145508
		alarms: 	a Heap()
		lastAlarmTime: 	1145512
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1145512
		lastStepMessage: 	nil
		lastCycleTime: 	1145508
		alarms: 	a Heap()
		lastAlarmTime: 	1145512
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1145512
		lastStepMessage: 	nil
		lastCycleTime: 	1145508
		alarms: 	a Heap()
		lastAlarmTime: 	1145512
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1145512
		lastStepMessage: 	nil
		lastCycleTime: 	1145508
		alarms: 	a Heap()
		lastAlarmTime: 	1145512
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(168558592) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:11:09.224183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic a Topic a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Topic a Topic a Topic nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(304087040))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(304087040)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		event: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		all: 	an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(30408704...etc...
		m: 	a PluggableButtonMorph(304087040)
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(304087040))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(304087040))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		all: 	an Array(a PluggableButtonMorph(617873408) a PluggableButtonMorph(30408704...etc...
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


MouseButtonEvent>>sentTo:
	Receiver: [(1507@715) mouseUp 1143228 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(304087040)
	Receiver's instance variables: 
		timeStamp: 	1143228
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1507@715)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(304087040)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1327.0@706.0) corner: (1522.0@735.0)
		owner: 	a PanelMorph(1036779520)
		submorphs: 	an Array(an AlignmentMorph(52690944))
		fullBounds: 	(1327@706) corner: (1522@735)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (371458048) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(134742016)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1263@545.0) corner: (1279@561.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@545.0) corner: (1279@561.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(315883520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@545) mouseUp 1146080 nil]
		targetOffset: 	(105.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1146080 1263 545 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1507@715) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(103546880) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1263@545.0) corner: (1279@561.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@545.0) corner: (1279@561.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(315883520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@545) mouseUp 1146080 nil]
		targetOffset: 	(105.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1146080 1263 545 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		focusHolder: 	a PluggableButtonMorph(304087040)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1263@545.0) corner: (1279@561.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@545.0) corner: (1279@561.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(315883520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@545) mouseOver nil nil]
		targetOffset: 	(105.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1146080 1263 545 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1263@545.0) corner: (1279@561.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@545.0) corner: (1279@561.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(315883520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@545) mouseOver nil nil]
		targetOffset: 	(105.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1146080 1263 545 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1507@715) mouseUp 1143228 nil]
		evt: 	[(1507@715) mouseUp 1143228 nil]
	Receiver's instance variables: 
		bounds: 	(1263@545.0) corner: (1279@561.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@545.0) corner: (1279@561.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(315883520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@545) mouseOver nil nil]
		targetOffset: 	(105.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1146080 1263 545 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1507@715) mouseUp 1143228 nil]
		evtBuf: 	#(1 1143228 1507 715 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1263@545.0) corner: (1279@561.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1263@545.0) corner: (1279@561.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(315883520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1263@545) mouseOver nil nil]
		targetOffset: 	(105.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1146080 1263 545 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1146116
		lastStepMessage: 	nil
		lastCycleTime: 	1146110
		alarms: 	a Heap()
		lastAlarmTime: 	1146116
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1146116
		lastStepMessage: 	nil
		lastCycleTime: 	1146110
		alarms: 	a Heap()
		lastAlarmTime: 	1146116
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1146116
		lastStepMessage: 	nil
		lastCycleTime: 	1146110
		alarms: 	a Heap()
		lastAlarmTime: 	1146116
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(878968832))(a TRMorph(878968...etc...
		lastStepTime: 	1146116
		lastStepMessage: 	nil
		lastCycleTime: 	1146110
		alarms: 	a Heap()
		lastAlarmTime: 	1146116
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(168558592) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:11:53.170183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic show.
self halt ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
		topic: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
[ :topic | 
topic show.
self halt ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:11:57.858189 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:11:58.582189 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...


--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:11:59.122183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:11:59.670183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:12:00.268187 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:12:01.070185 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:12:01.834185 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:12:02.512185 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(94371840)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:12:18.964183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Topic nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(532414464))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(532414464)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(532414464)
	Arguments and temporary variables: 
		event: 	[(1513@637) mouseUp 1215816 nil]
	Receiver's instance variables: 
		bounds: 	(1437.0@613.0) corner: (1632.0@642.0)
		owner: 	a PanelMorph(191365120)
		submorphs: 	an Array(an AlignmentMorph(281018368))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (599785472) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(363069440)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(532414464)
	Arguments and temporary variables: 
		evt: 	[(1513@637) mouseUp 1215816 nil]
		all: 	an Array(a PluggableButtonMorph(775684096) a PluggableButtonMorph(53241446...etc...
		m: 	a PluggableButtonMorph(532414464)
	Receiver's instance variables: 
		bounds: 	(1437.0@613.0) corner: (1632.0@642.0)
		owner: 	a PanelMorph(191365120)
		submorphs: 	an Array(an AlignmentMorph(281018368))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (599785472) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(363069440)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(775684096) a PluggableButtonMorph(532414464))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(775684096) a PluggableButtonMorph(532414464))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(532414464)
	Arguments and temporary variables: 
		evt: 	[(1513@637) mouseUp 1215816 nil]
		all: 	an Array(a PluggableButtonMorph(775684096) a PluggableButtonMorph(53241446...etc...
	Receiver's instance variables: 
		bounds: 	(1437.0@613.0) corner: (1632.0@642.0)
		owner: 	a PanelMorph(191365120)
		submorphs: 	an Array(an AlignmentMorph(281018368))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (599785472) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(363069440)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(532414464)
	Arguments and temporary variables: 
		anEvent: 	[(1513@637) mouseUp 1215816 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1437.0@613.0) corner: (1632.0@642.0)
		owner: 	a PanelMorph(191365120)
		submorphs: 	an Array(an AlignmentMorph(281018368))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (599785472) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(363069440)


MouseButtonEvent>>sentTo:
	Receiver: [(1513@637) mouseUp 1215816 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(532414464)
	Receiver's instance variables: 
		timeStamp: 	1215816
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1513@637)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(532414464)
	Arguments and temporary variables: 
		anEvent: 	[(1513@637) mouseUp 1215816 nil]
	Receiver's instance variables: 
		bounds: 	(1437.0@613.0) corner: (1632.0@642.0)
		owner: 	a PanelMorph(191365120)
		submorphs: 	an Array(an AlignmentMorph(281018368))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (599785472) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(363069440)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(532414464)
	Arguments and temporary variables: 
		anEvent: 	[(1513@637) mouseUp 1215816 nil]
	Receiver's instance variables: 
		bounds: 	(1437.0@613.0) corner: (1632.0@642.0)
		owner: 	a PanelMorph(191365120)
		submorphs: 	an Array(an AlignmentMorph(281018368))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (599785472) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(363069440)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1513@637) mouseUp 1215816 nil]
		focusHolder: 	a PluggableButtonMorph(532414464)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1513@637.0) corner: (1529@653.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1513@637.0) corner: (1529@653.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(532414464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1513@637) mouseUp 1215816 nil]
		targetOffset: 	(76.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1215816 1513 637 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1513@637) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(821821440) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1513@637) mouseUp 1215816 nil]
		focusHolder: 	a PluggableButtonMorph(532414464)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1513@637.0) corner: (1529@653.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1513@637.0) corner: (1529@653.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(532414464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1513@637) mouseUp 1215816 nil]
		targetOffset: 	(76.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1215816 1513 637 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1513@637) mouseUp 1215816 nil]
		focusHolder: 	a PluggableButtonMorph(532414464)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1513@637.0) corner: (1529@653.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1513@637.0) corner: (1529@653.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(532414464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1513@637) mouseUp 1215816 nil]
		targetOffset: 	(76.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1215816 1513 637 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1513@637) mouseUp 1215816 nil]
	Receiver's instance variables: 
		bounds: 	(1513@637.0) corner: (1529@653.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1513@637.0) corner: (1529@653.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(532414464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1513@637) mouseUp 1215816 nil]
		targetOffset: 	(76.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1215816 1513 637 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1513@637) mouseUp 1215816 nil]
		evt: 	[(1513@637) mouseUp 1215816 nil]
	Receiver's instance variables: 
		bounds: 	(1513@637.0) corner: (1529@653.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1513@637.0) corner: (1529@653.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(532414464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1513@637) mouseUp 1215816 nil]
		targetOffset: 	(76.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1215816 1513 637 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1513@637) mouseUp 1215816 nil]
		evtBuf: 	#(1 1215816 1513 637 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1513@637.0) corner: (1529@653.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1513@637.0) corner: (1529@653.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(532414464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1513@637) mouseUp 1215816 nil]
		targetOffset: 	(76.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1215816 1513 637 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(653787136))(a TRMorph(653787...etc...
		lastStepTime: 	1215808
		lastStepMessage: 	nil
		lastCycleTime: 	1215828
		alarms: 	a Heap()
		lastAlarmTime: 	1215808
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(653787136))(a TRMorph(653787...etc...
		lastStepTime: 	1215808
		lastStepMessage: 	nil
		lastCycleTime: 	1215828
		alarms: 	a Heap()
		lastAlarmTime: 	1215808
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(653787136))(a TRMorph(653787...etc...
		lastStepTime: 	1215808
		lastStepMessage: 	nil
		lastCycleTime: 	1215828
		alarms: 	a Heap()
		lastAlarmTime: 	1215808
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(653787136))(a TRMorph(653787...etc...
		lastStepTime: 	1215808
		lastStepMessage: 	nil
		lastCycleTime: 	1215828
		alarms: 	a Heap()
		lastAlarmTime: 	1215808
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(821821440) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ item show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:12:50.604183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ topic show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ topic show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ topic show: value ].
sel...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Topic nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ topic show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(623902720))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(623902720)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		event: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		evt: 	[(813@635) mouseUp 1247456 nil]
		all: 	an Array(a PluggableButtonMorph(850657280) a PluggableButtonMorph(62390272...etc...
		m: 	a PluggableButtonMorph(623902720)
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(850657280) a PluggableButtonMorph(623902720))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(850657280) a PluggableButtonMorph(623902720))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		evt: 	[(813@635) mouseUp 1247456 nil]
		all: 	an Array(a PluggableButtonMorph(850657280) a PluggableButtonMorph(62390272...etc...
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


MouseButtonEvent>>sentTo:
	Receiver: [(813@635) mouseUp 1247456 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(623902720)
	Receiver's instance variables: 
		timeStamp: 	1247456
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(813@635)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		focusHolder: 	a PluggableButtonMorph(623902720)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(813@635.0) corner: (829@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(813@635.0) corner: (829@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(623902720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(813@635) mouseUp 1247456 nil]
		targetOffset: 	(67.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1247456 813 635 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(813@635) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(889716736) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		focusHolder: 	a PluggableButtonMorph(623902720)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(813@635.0) corner: (829@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(813@635.0) corner: (829@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(623902720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(813@635) mouseOver nil nil]
		targetOffset: 	(67.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1247456 813 635 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		focusHolder: 	a PluggableButtonMorph(623902720)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(813@635.0) corner: (829@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(813@635.0) corner: (829@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(623902720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(813@635) mouseOver nil nil]
		targetOffset: 	(67.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1247456 813 635 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(813@635.0) corner: (829@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(813@635.0) corner: (829@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(623902720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(813@635) mouseOver nil nil]
		targetOffset: 	(67.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1247456 813 635 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		evt: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(813@635.0) corner: (829@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(813@635.0) corner: (829@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(623902720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(813@635) mouseOver nil nil]
		targetOffset: 	(67.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1247456 813 635 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(813@635) mouseUp 1247456 nil]
		evtBuf: 	#(1 1247456 813 635 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(813@635.0) corner: (829@651.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(813@635.0) corner: (829@651.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(623902720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(813@635) mouseOver nil nil]
		targetOffset: 	(67.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1247456 813 635 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	1247490
		lastStepMessage: 	nil
		lastCycleTime: 	1247490
		alarms: 	a Heap()
		lastAlarmTime: 	1247490
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	1247490
		lastStepMessage: 	nil
		lastCycleTime: 	1247490
		alarms: 	a Heap()
		lastAlarmTime: 	1247490
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	1247490
		lastStepMessage: 	nil
		lastCycleTime: 	1247490
		alarms: 	a Heap()
		lastAlarmTime: 	1247490
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	1247490
		lastStepMessage: 	nil
		lastCycleTime: 	1247490
		alarms: 	a Heap()
		lastAlarmTime: 	1247490
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(889716736) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ topic show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ topic show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ topic show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:13:46.734185 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ topic show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ topic show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic a Topic a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ topic show: value ].
sel...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Topic a Topic a Topic nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ topic show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(623902720))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(623902720)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		event: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	(746@615) corner: (941@644)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		evt: 	[(813@635) mouseUp 1247456 nil]
		all: 	an Array(a PluggableButtonMorph(850657280) a PluggableButtonMorph(62390272...etc...
		m: 	a PluggableButtonMorph(623902720)
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	(746@615) corner: (941@644)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(850657280) a PluggableButtonMorph(623902720))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(850657280) a PluggableButtonMorph(623902720))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		evt: 	[(813@635) mouseUp 1247456 nil]
		all: 	an Array(a PluggableButtonMorph(850657280) a PluggableButtonMorph(62390272...etc...
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	(746@615) corner: (941@644)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	(746@615) corner: (941@644)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


MouseButtonEvent>>sentTo:
	Receiver: [(813@635) mouseUp 1247456 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(623902720)
	Receiver's instance variables: 
		timeStamp: 	1247456
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(813@635)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	(746@615) corner: (941@644)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(623902720)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(746.0@615.0) corner: (941.0@644.0)
		owner: 	a PanelMorph(282853376)
		submorphs: 	an Array(an AlignmentMorph(372506624))
		fullBounds: 	(746@615) corner: (941@644)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (691273728) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(454557696)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		focusHolder: 	a PluggableButtonMorph(623902720)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(720@419.0) corner: (736@435.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(258211840)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(720@419) mouseUp 1303580 nil]
		targetOffset: 	(98.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1303580 720 419 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(813@635) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(855375872) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		focusHolder: 	a PluggableButtonMorph(623902720)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(720@419.0) corner: (736@435.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(258211840)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(720@419) mouseUp 1303580 nil]
		targetOffset: 	(98.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1303580 720 419 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		focusHolder: 	a PluggableButtonMorph(623902720)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(720@419.0) corner: (736@435.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(258211840)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(720@419) mouseUp 1303580 nil]
		targetOffset: 	(98.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1303580 720 419 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(720@419.0) corner: (736@435.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(258211840)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(720@419) mouseOver nil nil]
		targetOffset: 	(98.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1303580 720 419 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(813@635) mouseUp 1247456 nil]
		evt: 	[(813@635) mouseUp 1247456 nil]
	Receiver's instance variables: 
		bounds: 	(720@419.0) corner: (736@435.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(258211840)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(720@419) mouseOver nil nil]
		targetOffset: 	(98.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1303580 720 419 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(813@635) mouseUp 1247456 nil]
		evtBuf: 	#(1 1247456 813 635 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(720@419.0) corner: (736@435.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(258211840)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(720@419) mouseOver nil nil]
		targetOffset: 	(98.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1303580 720 419 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseInstVars 675020800))(3...etc...
		lastStepTime: 	1303638
		lastStepMessage: 	nil
		lastCycleTime: 	1303628
		alarms: 	a Heap()
		lastAlarmTime: 	1303638
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseInstVars 675020800))(3...etc...
		lastStepTime: 	1303638
		lastStepMessage: 	nil
		lastCycleTime: 	1303628
		alarms: 	a Heap()
		lastAlarmTime: 	1303638
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseInstVars 675020800))(3...etc...
		lastStepTime: 	1303638
		lastStepMessage: 	nil
		lastCycleTime: 	1303628
		alarms: 	a Heap()
		lastAlarmTime: 	1303638
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseInstVars 675020800))(3...etc...
		lastStepTime: 	1303638
		lastStepMessage: 	nil
		lastCycleTime: 	1303628
		alarms: 	a Heap()
		lastAlarmTime: 	1303638
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(889716736) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ topic show: value ].
self halt ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ topic show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ topic show: value ].
		self halt ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:14:31.446183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		self halt ] ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ] ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Topic nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ] ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(6029312))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(6029312)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		event: 	[(1272@822) mouseUp 1348308 nil]
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		evt: 	[(1272@822) mouseUp 1348308 nil]
		all: 	an Array(a PluggableButtonMorph(148373504) a PluggableButtonMorph(6029312)...etc...
		m: 	a PluggableButtonMorph(6029312)
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(148373504) a PluggableButtonMorph(6029312))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(148373504) a PluggableButtonMorph(6029312))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		evt: 	[(1272@822) mouseUp 1348308 nil]
		all: 	an Array(a PluggableButtonMorph(148373504) a PluggableButtonMorph(6029312)...etc...
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		anEvent: 	[(1272@822) mouseUp 1348308 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


MouseButtonEvent>>sentTo:
	Receiver: [(1272@822) mouseUp 1348308 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(6029312)
	Receiver's instance variables: 
		timeStamp: 	1348308
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1272@822)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		anEvent: 	[(1272@822) mouseUp 1348308 nil]
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		anEvent: 	[(1272@822) mouseUp 1348308 nil]
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1272@822) mouseUp 1348308 nil]
		focusHolder: 	a PluggableButtonMorph(6029312)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1272@822.0) corner: (1288@838.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1272@822.0) corner: (1288@838.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1272@822) mouseUp 1348308 nil]
		targetOffset: 	(76.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1348308 1272 822 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1272@822) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(541327360) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1272@822) mouseUp 1348308 nil]
		focusHolder: 	a PluggableButtonMorph(6029312)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1272@822.0) corner: (1288@838.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1272@822.0) corner: (1288@838.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1272@822) mouseUp 1348308 nil]
		targetOffset: 	(76.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1348308 1272 822 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1272@822) mouseUp 1348308 nil]
		focusHolder: 	a PluggableButtonMorph(6029312)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1272@822.0) corner: (1288@838.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1272@822.0) corner: (1288@838.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1272@822) mouseUp 1348308 nil]
		targetOffset: 	(76.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1348308 1272 822 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1272@822) mouseUp 1348308 nil]
	Receiver's instance variables: 
		bounds: 	(1272@822.0) corner: (1288@838.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1272@822.0) corner: (1288@838.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1272@822) mouseUp 1348308 nil]
		targetOffset: 	(76.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1348308 1272 822 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1272@822) mouseUp 1348308 nil]
		evt: 	[(1272@822) mouseUp 1348308 nil]
	Receiver's instance variables: 
		bounds: 	(1272@822.0) corner: (1288@838.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1272@822.0) corner: (1288@838.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1272@822) mouseUp 1348308 nil]
		targetOffset: 	(76.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1348308 1272 822 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1272@822) mouseUp 1348308 nil]
		evtBuf: 	#(1 1348308 1272 822 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1272@822.0) corner: (1288@838.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1272@822.0) corner: (1288@838.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1272@822) mouseUp 1348308 nil]
		targetOffset: 	(76.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1348308 1272 822 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(657457152))(a TRMorph(657457...etc...
		lastStepTime: 	1348290
		lastStepMessage: 	nil
		lastCycleTime: 	1348310
		alarms: 	a Heap()
		lastAlarmTime: 	1348290
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(657457152))(a TRMorph(657457...etc...
		lastStepTime: 	1348290
		lastStepMessage: 	nil
		lastCycleTime: 	1348310
		alarms: 	a Heap()
		lastAlarmTime: 	1348290
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(657457152))(a TRMorph(657457...etc...
		lastStepTime: 	1348290
		lastStepMessage: 	nil
		lastCycleTime: 	1348310
		alarms: 	a Heap()
		lastAlarmTime: 	1348290
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(657457152))(a TRMorph(657457...etc...
		lastStepTime: 	1348290
		lastStepMessage: 	nil
		lastCycleTime: 	1348310
		alarms: 	a Heap()
		lastAlarmTime: 	1348290
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(541327360) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		self halt ] ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ] ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ] ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:14:45.124183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		self halt ] ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ] ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Topic nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ] ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(6029312))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(6029312)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		event: 	[(1314@812) mouseUp 1361980 nil]
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		evt: 	[(1314@812) mouseUp 1361980 nil]
		all: 	an Array(a PluggableButtonMorph(148373504) a PluggableButtonMorph(6029312)...etc...
		m: 	a PluggableButtonMorph(6029312)
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(148373504) a PluggableButtonMorph(6029312))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(148373504) a PluggableButtonMorph(6029312))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		evt: 	[(1314@812) mouseUp 1361980 nil]
		all: 	an Array(a PluggableButtonMorph(148373504) a PluggableButtonMorph(6029312)...etc...
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


MouseButtonEvent>>sentTo:
	Receiver: [(1314@812) mouseUp 1361980 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(6029312)
	Receiver's instance variables: 
		timeStamp: 	1361980
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1314@812)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(6029312)
	Arguments and temporary variables: 
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
	Receiver's instance variables: 
		bounds: 	(1196.0@809.0) corner: (1391.0@838.0)
		owner: 	a PanelMorph(738721792)
		submorphs: 	an Array(an AlignmentMorph(828375040))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (73400320) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(910426112)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
		focusHolder: 	a PluggableButtonMorph(6029312)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1314@812.0) corner: (1330@828.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1314@812.0) corner: (1330@828.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1314@812) mouseUp 1361980 nil]
		targetOffset: 	(118.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1361980 1314 812 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1314@812) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(541327360) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
		focusHolder: 	a PluggableButtonMorph(6029312)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1314@812.0) corner: (1330@828.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1314@812.0) corner: (1330@828.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1314@812) mouseOver nil nil]
		targetOffset: 	(118.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1361980 1314 812 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
		focusHolder: 	a PluggableButtonMorph(6029312)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1314@812.0) corner: (1330@828.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1314@812.0) corner: (1330@828.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1314@812) mouseOver nil nil]
		targetOffset: 	(118.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1361980 1314 812 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
	Receiver's instance variables: 
		bounds: 	(1314@812.0) corner: (1330@828.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1314@812.0) corner: (1330@828.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1314@812) mouseOver nil nil]
		targetOffset: 	(118.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1361980 1314 812 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
		evt: 	[(1314@812) mouseUp 1361980 nil]
	Receiver's instance variables: 
		bounds: 	(1314@812.0) corner: (1330@828.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1314@812.0) corner: (1330@828.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1314@812) mouseOver nil nil]
		targetOffset: 	(118.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1361980 1314 812 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(1314@812) mouseUp 1361980 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(1314@812) mouseUp 1361980 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a SpecWindow(541327360)
		clickState: 	#firstClickUp
		firstClickDown: 	[(1314@812) mouseDown red 1361916 nil]
		firstClickUp: 	[(1314@812) mouseUp 1361980 nil]
		firstClickTime: 	1361916
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	#doubleClickTimeout:
		dragSelector: 	#startDrag:
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1314@812) mouseUp 1361980 nil]
		evt: 	[(1314@812) mouseUp 1361980 nil]
	Receiver's instance variables: 
		bounds: 	(1314@812.0) corner: (1330@828.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1314@812.0) corner: (1330@828.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1314@812) mouseOver nil nil]
		targetOffset: 	(118.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1361980 1314 812 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1314@812) mouseUp 1361980 nil]
		evtBuf: 	#(1 1361980 1314 812 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1314@812.0) corner: (1330@828.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1314@812.0) corner: (1330@828.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(6029312)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1314@812) mouseOver nil nil]
		targetOffset: 	(118.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1361980 1314 812 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(657457152))(a TRMorph(657457...etc...
		lastStepTime: 	1362012
		lastStepMessage: 	nil
		lastCycleTime: 	1362010
		alarms: 	a Heap()
		lastAlarmTime: 	1362012
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(657457152))(a TRMorph(657457...etc...
		lastStepTime: 	1362012
		lastStepMessage: 	nil
		lastCycleTime: 	1362010
		alarms: 	a Heap()
		lastAlarmTime: 	1362012
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(657457152))(a TRMorph(657457...etc...
		lastStepTime: 	1362012
		lastStepMessage: 	nil
		lastCycleTime: 	1362010
		alarms: 	a Heap()
		lastAlarmTime: 	1362012
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(657457152))(a TRMorph(657457...etc...
		lastStepTime: 	1362012
		lastStepMessage: 	nil
		lastCycleTime: 	1362010
		alarms: 	a Heap()
		lastAlarmTime: 	1362012
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(541327360) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		self halt ] ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ] ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ] ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:28:08.408183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		self halt ].
topic isOnGraph: false ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ].
		topic isOnGraph: false ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Topic nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ].
		topic isOnGraph: false ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(113246208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(113246208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(113246208)
	Arguments and temporary variables: 
		event: 	[(1278@524) mouseUp 2165260 nil]
	Receiver's instance variables: 
		bounds: 	(1157.0@513.0) corner: (1352.0@542.0)
		owner: 	a PanelMorph(845938688)
		submorphs: 	an Array(an AlignmentMorph(935591936))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (180617216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1017643008)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(113246208)
	Arguments and temporary variables: 
		evt: 	[(1278@524) mouseUp 2165260 nil]
		all: 	an Array(a PluggableButtonMorph(273678336) a PluggableButtonMorph(11324620...etc...
		m: 	a PluggableButtonMorph(113246208)
	Receiver's instance variables: 
		bounds: 	(1157.0@513.0) corner: (1352.0@542.0)
		owner: 	a PanelMorph(845938688)
		submorphs: 	an Array(an AlignmentMorph(935591936))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (180617216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1017643008)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(273678336) a PluggableButtonMorph(113246208))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(273678336) a PluggableButtonMorph(113246208))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(113246208)
	Arguments and temporary variables: 
		evt: 	[(1278@524) mouseUp 2165260 nil]
		all: 	an Array(a PluggableButtonMorph(273678336) a PluggableButtonMorph(11324620...etc...
	Receiver's instance variables: 
		bounds: 	(1157.0@513.0) corner: (1352.0@542.0)
		owner: 	a PanelMorph(845938688)
		submorphs: 	an Array(an AlignmentMorph(935591936))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (180617216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1017643008)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(113246208)
	Arguments and temporary variables: 
		anEvent: 	[(1278@524) mouseUp 2165260 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1157.0@513.0) corner: (1352.0@542.0)
		owner: 	a PanelMorph(845938688)
		submorphs: 	an Array(an AlignmentMorph(935591936))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (180617216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1017643008)


MouseButtonEvent>>sentTo:
	Receiver: [(1278@524) mouseUp 2165260 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(113246208)
	Receiver's instance variables: 
		timeStamp: 	2165260
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1278@524)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(113246208)
	Arguments and temporary variables: 
		anEvent: 	[(1278@524) mouseUp 2165260 nil]
	Receiver's instance variables: 
		bounds: 	(1157.0@513.0) corner: (1352.0@542.0)
		owner: 	a PanelMorph(845938688)
		submorphs: 	an Array(an AlignmentMorph(935591936))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (180617216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1017643008)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(113246208)
	Arguments and temporary variables: 
		anEvent: 	[(1278@524) mouseUp 2165260 nil]
	Receiver's instance variables: 
		bounds: 	(1157.0@513.0) corner: (1352.0@542.0)
		owner: 	a PanelMorph(845938688)
		submorphs: 	an Array(an AlignmentMorph(935591936))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (180617216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(1017643008)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1278@524) mouseUp 2165260 nil]
		focusHolder: 	a PluggableButtonMorph(113246208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1278@524.0) corner: (1294@540.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1278@524.0) corner: (1294@540.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(113246208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1278@524) mouseUp 2165260 nil]
		targetOffset: 	(121.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2165260 1278 524 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1278@524) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(161218560) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1278@524) mouseUp 2165260 nil]
		focusHolder: 	a PluggableButtonMorph(113246208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1278@524.0) corner: (1294@540.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1278@524.0) corner: (1294@540.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(113246208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1278@524) mouseOver nil nil]
		targetOffset: 	(121.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2165260 1278 524 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1278@524) mouseUp 2165260 nil]
		focusHolder: 	a PluggableButtonMorph(113246208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1278@524.0) corner: (1294@540.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1278@524.0) corner: (1294@540.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(113246208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1278@524) mouseOver nil nil]
		targetOffset: 	(121.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2165260 1278 524 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1278@524) mouseUp 2165260 nil]
	Receiver's instance variables: 
		bounds: 	(1278@524.0) corner: (1294@540.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1278@524.0) corner: (1294@540.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(113246208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1278@524) mouseOver nil nil]
		targetOffset: 	(121.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2165260 1278 524 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1278@524) mouseUp 2165260 nil]
		evt: 	[(1278@524) mouseUp 2165260 nil]
	Receiver's instance variables: 
		bounds: 	(1278@524.0) corner: (1294@540.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1278@524.0) corner: (1294@540.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(113246208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1278@524) mouseOver nil nil]
		targetOffset: 	(121.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2165260 1278 524 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1278@524) mouseUp 2165260 nil]
		evtBuf: 	#(1 2165260 1278 524 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1278@524.0) corner: (1294@540.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1278@524.0) corner: (1294@540.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(113246208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1278@524) mouseOver nil nil]
		targetOffset: 	(121.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2165260 1278 524 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(980680704))(a TRMorph(980680...etc...
		lastStepTime: 	2165294
		lastStepMessage: 	nil
		lastCycleTime: 	2165292
		alarms: 	a Heap()
		lastAlarmTime: 	2165294
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(980680704))(a TRMorph(980680...etc...
		lastStepTime: 	2165294
		lastStepMessage: 	nil
		lastCycleTime: 	2165292
		alarms: 	a Heap()
		lastAlarmTime: 	2165294
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(980680704))(a TRMorph(980680...etc...
		lastStepTime: 	2165294
		lastStepMessage: 	nil
		lastCycleTime: 	2165292
		alarms: 	a Heap()
		lastAlarmTime: 	2165294
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(980680704))(a TRMorph(980680...etc...
		lastStepTime: 	2165294
		lastStepMessage: 	nil
		lastCycleTime: 	2165292
		alarms: 	a Heap()
		lastAlarmTime: 	2165294
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(161218560) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		self halt ].
topic isOnGraph: false ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ].
		topic isOnGraph: false ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ].
		topic isOnGraph: false ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:29:16.370183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic show.
self halt ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
		topic: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
[ :topic | 
topic show.
self halt ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:29:18.146189 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:29:20.74819 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...


--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:29:25.754188 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 4
1 December 2015 5:29:26.448186 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

Array(Object)>>at:
	Receiver: #(#selectBlock #newCollection #element)
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
#(#selectBlock #newCollection #element)

DebuggerMethodMapOpal>>namedTempAt:in:
	Receiver: a DebuggerMethodMapOpal
	Arguments and temporary variables: 
		index: 	4
		aContext: 	OrderedCollection>>select:
		name: 	nil
	Receiver's instance variables: 
		methodNode: 	select: selectBlock
	"Optimized version of Collection>>#select: "

...etc...


Context>>namedTempAt:
	Receiver: OrderedCollection>>select:
	Arguments and temporary variables: 
		index: 	4
	Receiver's instance variables: 
		sender: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self ...etc...
		pc: 	36
		stackp: 	5
		method: 	OrderedCollection>>#select:
		closureOrNil: 	nil
		receiver: 	an OrderedCollection(a Node a Node a Node)


OrderedCollection>>ExecuteUnOptimizedIn:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		t1: 	OrderedCollection>>select:
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Graph(Object)>>mustBeBooleanInMagic:
	Receiver: a Graph
	Arguments and temporary variables: 
		context: 	OrderedCollection>>select:
		sendNode: 	RBMessageNode((selectBlock value: (element := array at: index))
	ifTr...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ ((ThisContext namedTempAt: 1) ...etc...
		method: 	OrderedCollection>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph(Object)>>mustBeBoolean
	Receiver: a Graph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
topic show.
self halt ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show...etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(245366784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
Array(Object)>>at:
DebuggerMethodMapOpal>>namedTempAt:in:
Context>>namedTempAt:
OrderedCollection>>ExecuteUnOptimizedIn:
Graph(Object)>>mustBeBooleanInMagic:
Graph(Object)>>mustBeBoolean
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		topic show.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:29:41.628182 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
		topic: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
self halt.
topic show ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:29:42.716187 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
		topic: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
self halt.
topic show ]
		newCollection: 	an OrderedCollection(a Node)
		element: 	a Node
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:29:43.740189 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
		topic: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
self halt.
topic show ]
		newCollection: 	an OrderedCollection(a Node a Node)
		element: 	a Node
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:29:44.378183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
		topic: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
self halt.
topic show ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup(a RTEdge a RTEdge a RTEdge)
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement)
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement)
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup(a RTEdge a RTEdge a RTEdge)
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:29:54.640183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		self halt ].
topic isOnGraph: false ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ].
		topic isOnGraph: false ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
		topic: 	a Topic
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Topic)
	Arguments and temporary variables: 
		aBlock: 	[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Topic nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ].
		topic isOnGraph: false ] ] in RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTru...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChangeTopics:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'Bye'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


Array(SequenceableCollection)>>do:
	Receiver: #('Bye')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('Bye')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('Bye')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Topic a Topic a Topic a Topic)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'topic'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(653000704))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(653000704)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(653000704)
	Arguments and temporary variables: 
		event: 	[(1371@604) mouseUp 2271496 nil]
	Receiver's instance variables: 
		bounds: 	(1198.0@593.0) corner: (1393.0@622.0)
		owner: 	a PanelMorph(311951360)
		submorphs: 	an Array(an AlignmentMorph(413663232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (720371712) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(495714304)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(653000704)
	Arguments and temporary variables: 
		evt: 	[(1371@604) mouseUp 2271496 nil]
		all: 	an Array(a PluggableButtonMorph(875298816) a PluggableButtonMorph(65300070...etc...
		m: 	a PluggableButtonMorph(653000704)
	Receiver's instance variables: 
		bounds: 	(1198.0@593.0) corner: (1393.0@622.0)
		owner: 	a PanelMorph(311951360)
		submorphs: 	an Array(an AlignmentMorph(413663232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (720371712) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(495714304)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(875298816) a PluggableButtonMorph(653000704))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(875298816) a PluggableButtonMorph(653000704))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(653000704)
	Arguments and temporary variables: 
		evt: 	[(1371@604) mouseUp 2271496 nil]
		all: 	an Array(a PluggableButtonMorph(875298816) a PluggableButtonMorph(65300070...etc...
	Receiver's instance variables: 
		bounds: 	(1198.0@593.0) corner: (1393.0@622.0)
		owner: 	a PanelMorph(311951360)
		submorphs: 	an Array(an AlignmentMorph(413663232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (720371712) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(495714304)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(653000704)
	Arguments and temporary variables: 
		anEvent: 	[(1371@604) mouseUp 2271496 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1198.0@593.0) corner: (1393.0@622.0)
		owner: 	a PanelMorph(311951360)
		submorphs: 	an Array(an AlignmentMorph(413663232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (720371712) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(495714304)


MouseButtonEvent>>sentTo:
	Receiver: [(1371@604) mouseUp 2271496 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(653000704)
	Receiver's instance variables: 
		timeStamp: 	2271496
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1371@604)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(653000704)
	Arguments and temporary variables: 
		anEvent: 	[(1371@604) mouseUp 2271496 nil]
	Receiver's instance variables: 
		bounds: 	(1198.0@593.0) corner: (1393.0@622.0)
		owner: 	a PanelMorph(311951360)
		submorphs: 	an Array(an AlignmentMorph(413663232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (720371712) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(495714304)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(653000704)
	Arguments and temporary variables: 
		anEvent: 	[(1371@604) mouseUp 2271496 nil]
	Receiver's instance variables: 
		bounds: 	(1198.0@593.0) corner: (1393.0@622.0)
		owner: 	a PanelMorph(311951360)
		submorphs: 	an Array(an AlignmentMorph(413663232))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (720371712) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(495714304)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1371@604) mouseUp 2271496 nil]
		focusHolder: 	a PluggableButtonMorph(653000704)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1371@604.0) corner: (1387@620.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1371@604.0) corner: (1387@620.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(653000704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1371@604) mouseUp 2271496 nil]
		targetOffset: 	(173.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2271496 1371 604 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1371@604) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(992215040) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1371@604) mouseUp 2271496 nil]
		focusHolder: 	a PluggableButtonMorph(653000704)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1371@604.0) corner: (1387@620.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1371@604.0) corner: (1387@620.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(653000704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1371@604) mouseOver nil nil]
		targetOffset: 	(173.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2271496 1371 604 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1371@604) mouseUp 2271496 nil]
		focusHolder: 	a PluggableButtonMorph(653000704)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1371@604.0) corner: (1387@620.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1371@604.0) corner: (1387@620.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(653000704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1371@604) mouseOver nil nil]
		targetOffset: 	(173.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2271496 1371 604 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1371@604) mouseUp 2271496 nil]
	Receiver's instance variables: 
		bounds: 	(1371@604.0) corner: (1387@620.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1371@604.0) corner: (1387@620.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(653000704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1371@604) mouseOver nil nil]
		targetOffset: 	(173.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2271496 1371 604 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1371@604) mouseUp 2271496 nil]
		evt: 	[(1371@604) mouseUp 2271496 nil]
	Receiver's instance variables: 
		bounds: 	(1371@604.0) corner: (1387@620.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1371@604.0) corner: (1387@620.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(653000704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1371@604) mouseOver nil nil]
		targetOffset: 	(173.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2271496 1371 604 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1371@604) mouseUp 2271496 nil]
		evtBuf: 	#(1 2271496 1371 604 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1371@604.0) corner: (1387@620.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1371@604.0) corner: (1387@620.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(653000704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1371@604) mouseOver nil nil]
		targetOffset: 	(173.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2271496 1371 604 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 30146560))(3...etc...
		lastStepTime: 	2271524
		lastStepMessage: 	nil
		lastCycleTime: 	2271524
		alarms: 	a Heap()
		lastAlarmTime: 	2271524
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 30146560))(3...etc...
		lastStepTime: 	2271524
		lastStepMessage: 	nil
		lastCycleTime: 	2271524
		alarms: 	a Heap()
		lastAlarmTime: 	2271524
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 30146560))(3...etc...
		lastStepTime: 	2271524
		lastStepMessage: 	nil
		lastCycleTime: 	2271524
		alarms: 	a Heap()
		lastAlarmTime: 	2271524
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#browseClassVars 30146560))(3...etc...
		lastStepTime: 	2271524
		lastStepMessage: 	nil
		lastCycleTime: 	2271524
		alarms: 	a Heap()
		lastAlarmTime: 	2271524
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(992215040) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :topic | 
topic objName = nameObj
	ifTrue: [ 
		topic show: value.
		self halt ].
topic isOnGraph: false ] in [ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ].
		topic isOnGraph: false ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
[ :item | 
item sub
	do: [ :topic | 
		topic objName = nameObj
			ifTrue: [ 
				topic show: value.
				self halt ].
		topic isOnGraph: false ] ] in RQTGMainWindow>>listChangeTopics:with:
OrderedCollection>>do:
RQTGMainWindow>>listChangeTopics:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:30:17.456186 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
		topic: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
self halt.
topic show ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		announcement: 	a ValueChanged
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


NewValueHolder>>valueChanged:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		oldValue: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGrap...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...


[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		anObject: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
		oldValue: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGrap...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...


BlockClosure>>ensure:
	Receiver: [ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ]
	Arguments and temporary variables: 
		aBlock: 	[ lock := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>value:
		startpc: 	27
		numArgs: 	0


NewValueHolder>>handleCircularReferencesWhile:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...


NewValueHolder>>value:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		anObject: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...



--- The full stack ---
[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 5:31:02.736189 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
		topic: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		view: 	a RTViewForSpec
		names: 	true


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :topic | 
self halt.
topic show ]
		newCollection: 	an OrderedCollection(a Node)
		element: 	a Node
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		sub: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>rtValue:
	Receiver: [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	145
		numArgs: 	1


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
		fromElement: 	a RTElement
		toElements: 	nil
		e: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	nil
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt....etc...
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(821297152)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		announcement: 	a ValueChanged
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


NewValueHolder>>valueChanged:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		oldValue: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGrap...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...


[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		anObject: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
		oldValue: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGrap...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...


BlockClosure>>ensure:
	Receiver: [ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ]
	Arguments and temporary variables: 
		aBlock: 	[ lock := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>value:
		startpc: 	27
		numArgs: 	0


NewValueHolder>>handleCircularReferencesWhile:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...


NewValueHolder>>value:
	Receiver: a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...
	Arguments and temporary variables: 
		anObject: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGrap...etc...
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: ...etc...



--- The full stack ---
[ :topic | 
self halt.
topic show ] in [ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
OrderedCollection>>select:
[ :sub | 
(self getSub: sub)
	select: [ :topic | 
		self halt.
		topic show ] ] in Graph>>createGraph:withView:
BlockClosure>>rtValue:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: True>>and
1 December 2015 5:36:09.176183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

True(Object)>>doesNotUnderstand: #and
	Receiver: true
	Arguments and temporary variables: 
		aMessage: 	and
		exception: 	MessageNotUnderstood: True>>and
		resumeValue: 	nil
	Receiver's instance variables: 
true

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'true and false'
		itsSelection: 	a Text for 'true and false'
		itsSelectionString: 	'true and false'
	Receiver's instance variables: 
		ast: 	DoIt
	^ true and false
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	2646036
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 
		anArgument: 	2646042
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	2646036
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	2646042
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(846200832))(a TRMorph(846200...etc...
		lastStepTime: 	2646022
		lastStepMessage: 	nil
		lastCycleTime: 	2646042
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	2646022
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		now: 	2646042
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(846200832))(a TRMorph(846200...etc...
		lastStepTime: 	2646062
		lastStepMessage: 	nil
		lastCycleTime: 	2646062
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	2646062
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(846200832))(a TRMorph(846200...etc...
		lastStepTime: 	2646062
		lastStepMessage: 	nil
		lastCycleTime: 	2646062
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	2646062
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(846200832))(a TRMorph(846200...etc...
		lastStepTime: 	2646062
		lastStepMessage: 	nil
		lastCycleTime: 	2646062
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	2646062
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1853@1028)
		canvas: 	a FormCanvas on: DisplayScreen(1853x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(846200832))(a TRMorph(846200...etc...
		lastStepTime: 	2646062
		lastStepMessage: 	nil
		lastCycleTime: 	2646062
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	2646062
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1853@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1853@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
True(Object)>>doesNotUnderstand: #and
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: TextModel>>isEnabled:
1 December 2015 6:02:20.95019 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

TextModel(Object)>>doesNotUnderstand: #isEnabled:
	Receiver: a TextModel
	Arguments and temporary variables: 
		aMessage: 	isEnabled: false
		exception: 	MessageNotUnderstood: TextModel>>isEnabled:
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Text' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		aboutToStyleHolder: 	a NewValueHolder[ [ false ] ]
		behaviorHolder: 	a NewValueHolder[ nil ]
		textHolder: 	a CollectionValueHolder[ '' ]
		actionToPerformHolder: 	a NewValueHolder[ [ :text |  ] ]
		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]
		actionPerformedHolder: 	a CollectionValueHolder[ '' ]
		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]
		doItContext: 	a NewValueHolder[ nil ]
		doItReceiver: 	a NewValueHolder[ nil ]
		hasUnacceptedEdits: 	a NewValueHolder[ false ]
		selection: 	a CollectionValueHolder[ (1 to: 0) ]
		scrollValue: 	a NewValueHolder[ (0@0) ]
		menuHolder: 	a NewValueHolder[ [ :menu :shifted | 
shifted
	ifTrue: [ SmalltalkE...etc...
		autoAccept: 	a NewValueHolder[ false ]
		wantsVisualFeedback: 	a NewValueHolder[ true ]
		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'TextModel new isEnabled: false; text: ''asdf''; openWithSpec ....etc...
		itsSelection: 	a Text for 'TextModel new isEnabled: false; text: ''asdf''; openW...etc...
		itsSelectionString: 	'TextModel new isEnabled: false; text: ''asdf''; openWithSp...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	^ TextModel new
		isEnabled: false;
		text: 'asdf';
		openWithSpec
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(250347520)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(250347520)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(308543488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(250347520)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (292@50)
		owner: 	a TransformWithLayoutMorph(430440448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(732168192) a RubCursor(671875072...etc...
		fullBounds: 	(0@0) corner: (292@50)
		color: 	Color transparent
		extension: 	a MorphExtension (745799680) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(392167424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(671875072)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(262930432))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(308543488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(482869248))(a DropList...etc...
		lastStepTime: 	4217856
		lastStepMessage: 	nil
		lastCycleTime: 	4217852
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(671875072)))
		lastAlarmTime: 	4217856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(140247040) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(482869248))(a DropList...etc...
		lastStepTime: 	4217856
		lastStepMessage: 	nil
		lastCycleTime: 	4217852
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(671875072)))
		lastAlarmTime: 	4217856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(482869248))(a DropList...etc...
		lastStepTime: 	4217856
		lastStepMessage: 	nil
		lastCycleTime: 	4217852
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(671875072)))
		lastAlarmTime: 	4217856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(140247040) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
TextModel(Object)>>doesNotUnderstand: #isEnabled:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
1 December 2015 6:03:03.818186 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	DataWindow>>#initializeWidgets
	Receiver's instance variables: 
#()

[ 
(item methodClass notNil and: [ item methodClass isObsolete not ])
	ifTrue: [ 
		| sel text boolean |
		boolean := textModel hasUnacceptedEdits.
		boolean
			ifTrue: [ text := textModel pendingText ].
		sel := listModel selectedItem.
		self
			messages:
				(listModel listItems
					add: item asFullRingDefinition;
					yourself).
		listModel setSelectedItem: sel.
		boolean
			ifTrue: [ textModel pendingText: text ] ] ] in MessageBrowser>>methodAdded:
	Receiver: a MessageBrowser
	Arguments and temporary variables: 
		anAnnouncement: 	a MethodAdded
		item: 	DataWindow>>#initializeWidgets
		sel: 	nil
		text: 	nil
		boolean: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection(a MultiColumnListModel a MethodToolbar a TextM...etc...
		owner: 	a TextFieldExample
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ ColorForm(16x16x8) ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ true ]
		titleHolder: 	a CollectionValueHolder[ 'Message Browser' ]
		listModel: 	a MultiColumnListModel
		textModel: 	a TextModel
		toolbarModel: 	a MethodToolbar
		refreshingBlockHolder: 	a NewValueHolder[ [ :item | true ] ]
		cachedHierarchy: 	nil
		model: 	an AbstractTool
		topologicSortHolder: 	a NewValueHolder[ true ]
		textConverterHolder: 	a NewValueHolder[ a SourceMethodConverter ]
		browsedEnvironment: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ 
(item methodClass notNil and: [ item methodClass isObsolete not...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4260566
		lastStepMessage: 	nil
		lastCycleTime: 	4260588
		alarms: 	a Heap()
		lastAlarmTime: 	4260566
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(644612096) a GLM...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4260566
		lastStepMessage: 	nil
		lastCycleTime: 	4260588
		alarms: 	a Heap()
		lastAlarmTime: 	4260566
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(658505728))(a DropList...etc...
		lastStepTime: 	4260566
		lastStepMessage: 	nil
		lastCycleTime: 	4260588
		alarms: 	a Heap()
		lastAlarmTime: 	4260566
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(644612096) a GLM...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
[ 
(item methodClass notNil and: [ item methodClass isObsolete not ])
	ifTrue: [ 
		| sel text boolean |
		boolean := textModel hasUnacceptedEdits.
		boolean
			ifTrue: [ text := textModel pendingText ].
		sel := listModel selectedItem.
		self
			messages:
				(listModel listItems
					add: item asFullRingDefinition;
					yourself).
		listModel setSelectedItem: sel.
		boolean
			ifTrue: [ textModel pendingText: text ] ] ] in MessageBrowser>>methodAdded:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: TextModel>>enable:
1 December 2015 6:06:43.502191 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

TextModel(Object)>>doesNotUnderstand: #enable:
	Receiver: a TextModel
	Arguments and temporary variables: 
		aMessage: 	enable: false
		exception: 	MessageNotUnderstood: TextModel>>enable:
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	a DataWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Text' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		aboutToStyleHolder: 	a NewValueHolder[ [ false ] ]
		behaviorHolder: 	a NewValueHolder[ nil ]
		textHolder: 	a CollectionValueHolder[ 'Holi' ]
		actionToPerformHolder: 	a NewValueHolder[ [ :text |  ] ]
		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]
		actionPerformedHolder: 	a CollectionValueHolder[ '' ]
		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]
		doItContext: 	a NewValueHolder[ nil ]
		doItReceiver: 	a NewValueHolder[ nil ]
		hasUnacceptedEdits: 	a NewValueHolder[ false ]
		selection: 	a CollectionValueHolder[ (1 to: 0) ]
		scrollValue: 	a NewValueHolder[ (0@0) ]
		menuHolder: 	a NewValueHolder[ [ :menu :shifted | 
shifted
	ifTrue: [ SmalltalkE...etc...
		autoAccept: 	a NewValueHolder[ false ]
		wantsVisualFeedback: 	a NewValueHolder[ true ]
		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]


DataWindow>>initializeWidgets
	Receiver: a DataWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	nil


DataWindow(ComposableModel)>>initialize
	Receiver: a DataWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	nil


DataWindow class(Behavior)>>new
	Receiver: DataWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ComposableModel
		methodDict: 	a MethodDictionary(#initializeWidgets->DataWindow>>#initializeWidge...etc...
		format: 	166
		layout: 	a FixedLayout
		instanceVariables: 	#(#data #dataType #dataDetail)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#DataWindow
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ DataWindow new openWithSpec
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(231473152)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(231473152)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(689963008)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(231473152)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (292@31)
		owner: 	a TransformWithLayoutMorph(811859968)
		submorphs: 	an Array(a RubCursor(683933696) a RubPrimarySelectionMorph(837287936...etc...
		fullBounds: 	(0@0) corner: (292@31)
		color: 	Color transparent
		extension: 	a MorphExtension (709623808) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(773586944)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(683933696)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(682360832))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(689963008)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(880541696))(a SearchMorp...etc...
		lastStepTime: 	4480428
		lastStepMessage: 	nil
		lastCycleTime: 	4480426
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(683933696)))
		lastAlarmTime: 	4480428
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1034944512) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(880541696))(a SearchMorp...etc...
		lastStepTime: 	4480428
		lastStepMessage: 	nil
		lastCycleTime: 	4480426
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(683933696)))
		lastAlarmTime: 	4480428
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(880541696))(a SearchMorp...etc...
		lastStepTime: 	4480428
		lastStepMessage: 	nil
		lastCycleTime: 	4480426
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(683933696)))
		lastAlarmTime: 	4480428
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1034944512) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
TextModel(Object)>>doesNotUnderstand: #enable:
DataWindow>>initializeWidgets
DataWindow(ComposableModel)>>initialize
DataWindow class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: DataWindow>>dataType
1 December 2015 6:09:27.200183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

DataWindow(Object)>>doesNotUnderstand: #dataType
	Receiver: a DataWindow
	Arguments and temporary variables: 
		aMessage: 	dataType
		exception: 	MessageNotUnderstood: DataWindow>>dataType
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	a TextModel


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#dataType
		args: 	#()
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#dataType
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #dataType)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #top...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFr...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #righ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #righ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #top...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFram...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction:...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType)...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) ...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spec...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType)...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a DataWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a DataWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
DataWindow(Object)>>doesNotUnderstand: #dataType
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
DataWindow(ComposableModel)>>adapterFrom:model:
DataWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
DataWindow(ComposableModel)>>openWithSpecLayout:
DataWindow(ComposableModel)>>openWithSpec:
DataWindow(ComposableModel)>>openWithSpec
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: DataWindow>>dataType
1 December 2015 6:09:40.912185 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

DataWindow(Object)>>doesNotUnderstand: #dataType
	Receiver: a DataWindow
	Arguments and temporary variables: 
		aMessage: 	dataType
		exception: 	MessageNotUnderstood: DataWindow>>dataType
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	a TextModel


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#dataType
		args: 	#()
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#dataType
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #dataType)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #top...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFr...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #righ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #righ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #top...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFram...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction:...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType)...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) ...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spec...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType)...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a DataWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a DataWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
DataWindow(Object)>>doesNotUnderstand: #dataType
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
DataWindow(ComposableModel)>>adapterFrom:model:
DataWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
DataWindow(ComposableModel)>>openWithSpecLayout:
DataWindow(ComposableModel)>>openWithSpec:
DataWindow(ComposableModel)>>openWithSpec
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: DataWindow>>dataType
1 December 2015 6:10:24.766184 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

DataWindow(Object)>>doesNotUnderstand: #dataType
	Receiver: a DataWindow
	Arguments and temporary variables: 
		aMessage: 	dataType
		exception: 	MessageNotUnderstood: DataWindow>>dataType
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	a TextModel


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#dataType
		args: 	#()
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#dataType
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #dataType)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #top...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFr...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #righ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #righ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #top...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFram...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction:...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType)...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) ...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spec...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType)...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a DataWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a DataWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
DataWindow(Object)>>doesNotUnderstand: #dataType
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
DataWindow(ComposableModel)>>adapterFrom:model:
DataWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
DataWindow(ComposableModel)>>openWithSpecLayout:
DataWindow(ComposableModel)>>openWithSpec:
DataWindow(ComposableModel)>>openWithSpec
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: DataWindow>>dataType
1 December 2015 6:12:22.054188 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

DataWindow(Object)>>doesNotUnderstand: #dataType
	Receiver: a DataWindow
	Arguments and temporary variables: 
		aMessage: 	dataType
		exception: 	MessageNotUnderstood: DataWindow>>dataType
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	a TextModel


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#dataType
		args: 	#()
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#dataType
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #dataType)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #dataType)
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #dataType)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFracti...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 ...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #top...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFr...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #righ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #righ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction: 0 #top...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spe...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayou...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Sp...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayo...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFram...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFrame #leftFraction:...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model ...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataT...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #data...etc...
		aModel: 	a DataWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType)...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) ...etc...
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType) #layout: #(#Spec...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#ContainerModel #add: #(#(#model #dataType)...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a DataWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a DataWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#Contai...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a DataWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
DataWindow(Object)>>doesNotUnderstand: #dataType
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
DataWindow(ComposableModel)>>adapterFrom:model:
DataWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
DataWindow(ComposableModel)>>openWithSpecLayout:
DataWindow(ComposableModel)>>openWithSpec:
DataWindow(ComposableModel)>>openWithSpec
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: DataWindow>>label:
1 December 2015 6:13:47.516185 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

DataWindow(Object)>>doesNotUnderstand: #label:
	Receiver: a DataWindow
	Arguments and temporary variables: 
		aMessage: 	label: 'Info Node/Topics'
		exception: 	MessageNotUnderstood: DataWindow>>label:
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	a TextModel


DataWindow>>initializeWidgets
	Receiver: a DataWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	a TextModel


DataWindow(ComposableModel)>>initialize
	Receiver: a DataWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		data: 	nil
		dataType: 	a TextModel
		dataDetail: 	a TextModel


DataWindow class(Behavior)>>new
	Receiver: DataWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ComposableModel
		methodDict: 	a MethodDictionary(#data->DataWindow>>#data #data:->DataWindow>>#da...etc...
		format: 	166
		layout: 	a FixedLayout
		instanceVariables: 	#(#data #dataType #dataDetail)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#DataWindow
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'DataWindow new openWithSpec .'
		itsSelection: 	a Text for 'DataWindow new openWithSpec .'
		itsSelectionString: 	'DataWindow new openWithSpec .'
	Receiver's instance variables: 
		ast: 	DoIt
	^ DataWindow new openWithSpec
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(231473152)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(231473152)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(689963008)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(231473152)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (141@50)
		owner: 	a TransformWithLayoutMorph(811859968)
		submorphs: 	an Array(a RubCursor(683933696) a RubPrimarySelectionMorph(837287936...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (709623808) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(773586944)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(683933696)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(409468928))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(689963008)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(482869248))(a DropList...etc...
		lastStepTime: 	4904330
		lastStepMessage: 	nil
		lastCycleTime: 	4904348
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(683933696)))
		lastAlarmTime: 	4904330
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1034944512) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(482869248))(a DropList...etc...
		lastStepTime: 	4904330
		lastStepMessage: 	nil
		lastCycleTime: 	4904348
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(683933696)))
		lastAlarmTime: 	4904330
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(482869248))(a DropList...etc...
		lastStepTime: 	4904330
		lastStepMessage: 	nil
		lastCycleTime: 	4904348
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(683933696)))
		lastAlarmTime: 	4904330
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1034944512) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
DataWindow(Object)>>doesNotUnderstand: #label:
DataWindow>>initializeWidgets
DataWindow(ComposableModel)>>initialize
DataWindow class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTCompositeShape>>elementsOn:triggerEvent:
1 December 2015 6:21:54.028184 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTCompositeShape(Object)>>doesNotUnderstand: #elementsOn:triggerEvent:
	Receiver: a RTCompositeShape
	Arguments and temporary variables: 
		aMessage: 	elementsOn: an OrderedCollection(a Node a Node a Node a Node) trigger...etc...
		exception: 	MessageNotUnderstood: RTCompositeShape>>elementsOn:triggerEvent:
		resumeValue: 	nil
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		shapes: 	an OrderedCollection(an Array(a RTEllipse (0@0)) an Array(a RTLabel (0@...etc...
		layout: 	#noLayout
		automaticallyUpdateLayout: 	false


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(754188288)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(754188288)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #showN...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
RTCompositeShape(Object)>>doesNotUnderstand: #elementsOn:triggerEvent:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>asSymbol
1 December 2015 6:22:48.466185 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [ :ev | DataWindow new openWithSpec ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	MessageNotUnderstood: BlockClosure>>asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	129
		numArgs: 	1


RTCompositeShape(Object)>>actionForEvent:
	Receiver: a RTCompositeShape
	Arguments and temporary variables: 
		anEventSelector: 	[ :ev | DataWindow new openWithSpec ]
		actions: 	nil
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		shapes: 	an OrderedCollection(an Array(a RTEllipse (0@0)) an Array(a RTLabel (0@...etc...
		layout: 	#noLayout
		automaticallyUpdateLayout: 	false


RTCompositeShape(Object)>>triggerEvent:
	Receiver: a RTCompositeShape
	Arguments and temporary variables: 
		anEventSelector: 	[ :ev | DataWindow new openWithSpec ]
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		shapes: 	an OrderedCollection(an Array(a RTEllipse (0@0)) an Array(a RTLabel (0@...etc...
		layout: 	#noLayout
		automaticallyUpdateLayout: 	false


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(432799744)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(432799744)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...


--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #asSymbol
RTCompositeShape(Object)>>actionForEvent:
RTCompositeShape(Object)>>triggerEvent:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>asSymbol
1 December 2015 6:23:16.666182 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [ DataWindow new openWithSpec ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	MessageNotUnderstood: BlockClosure>>asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	129
		numArgs: 	0


RTCompositeShape(Object)>>actionForEvent:
	Receiver: a RTCompositeShape
	Arguments and temporary variables: 
		anEventSelector: 	[ DataWindow new openWithSpec ]
		actions: 	nil
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		shapes: 	an OrderedCollection(an Array(a RTEllipse (0@0)) an Array(a RTLabel (0@...etc...
		layout: 	#noLayout
		automaticallyUpdateLayout: 	false


RTCompositeShape(Object)>>triggerEvent:
	Receiver: a RTCompositeShape
	Arguments and temporary variables: 
		anEventSelector: 	[ DataWindow new openWithSpec ]
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		shapes: 	an OrderedCollection(an Array(a RTEllipse (0@0)) an Array(a RTLabel (0@...etc...
		layout: 	#noLayout
		automaticallyUpdateLayout: 	false


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(851705856)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(851705856)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...


--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #asSymbol
RTCompositeShape(Object)>>actionForEvent:
RTCompositeShape(Object)>>triggerEvent:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>asSymbol
1 December 2015 6:24:52.398183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [ DataWindow new openWithSpec ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	MessageNotUnderstood: BlockClosure>>asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element triggerEvent: [ Data...etc...
		startpc: 	174
		numArgs: 	0


RTElement(Object)>>actionForEvent:
	Receiver: a RTElement
	Arguments and temporary variables: 
		anEventSelector: 	[ DataWindow new openWithSpec ]
		actions: 	nil
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge)
		shouldUpdateEdges: 	true


RTElement(Object)>>triggerEvent:
	Receiver: a RTElement
	Arguments and temporary variables: 
		anEventSelector: 	[ DataWindow new openWithSpec ]
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge)
		shouldUpdateEdges: 	true


[ :element | 
element @ RTDraggable.
element triggerEvent: [ DataWindow new openWithSpec ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :element | 
element @ RTDraggable.
element triggerEvent: [ DataWindow...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement)
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(65273856)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(65273856)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #asSymbol
RTElement(Object)>>actionForEvent:
RTElement(Object)>>triggerEvent:
[ :element | 
element @ RTDraggable.
element triggerEvent: [ DataWindow new openWithSpec ] ] in Graph>>createGraph:withView:
RTGroup(OrderedCollection)>>do:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 6:36:30.708183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


Array(SequenceableCollection)>>do:
	Receiver: #('B')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('B')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('B')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(596639744))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(596639744)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		event: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
		m: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


MouseButtonEvent>>sentTo:
	Receiver: [(976@475) mouseUp 6267554 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		timeStamp: 	6267554
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(976@475)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(976@475.0) corner: (992@491.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(976@475.0) corner: (992@491.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(976@475) mouseOver nil nil]
		targetOffset: 	(118.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6267554 976 475 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(976@475) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(976@475.0) corner: (992@491.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(976@475.0) corner: (992@491.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(976@475) mouseOver nil nil]
		targetOffset: 	(118.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6267554 976 475 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(976@475.0) corner: (992@491.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(976@475.0) corner: (992@491.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(976@475) mouseOver nil nil]
		targetOffset: 	(118.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6267554 976 475 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(976@475.0) corner: (992@491.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(976@475.0) corner: (992@491.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(976@475) mouseOver nil nil]
		targetOffset: 	(118.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6267554 976 475 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		evt: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(976@475.0) corner: (992@491.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(976@475.0) corner: (992@491.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(976@475) mouseOver nil nil]
		targetOffset: 	(118.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6267554 976 475 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		evtBuf: 	#(1 6267554 976 475 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(976@475.0) corner: (992@491.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(976@475.0) corner: (992@491.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(976@475) mouseOver nil nil]
		targetOffset: 	(118.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6267554 976 475 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6267614
		lastStepMessage: 	nil
		lastCycleTime: 	6267614
		alarms: 	a Heap()
		lastAlarmTime: 	6267614
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6267614
		lastStepMessage: 	nil
		lastCycleTime: 	6267614
		alarms: 	a Heap()
		lastAlarmTime: 	6267614
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6267614
		lastStepMessage: 	nil
		lastCycleTime: 	6267614
		alarms: 	a Heap()
		lastAlarmTime: 	6267614
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6267614
		lastStepMessage: 	nil
		lastCycleTime: 	6267614
		alarms: 	a Heap()
		lastAlarmTime: 	6267614
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 6:36:33.486183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


Array(SequenceableCollection)>>do:
	Receiver: #('B')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('B')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('B')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(596639744))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(596639744)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		event: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
		m: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


MouseButtonEvent>>sentTo:
	Receiver: [(976@475) mouseUp 6267554 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		timeStamp: 	6267554
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(976@475)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1023@250.0) corner: (1039@266.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1023@250.0) corner: (1039@266.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(264503296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1023@250) mouseUp 6270346 nil]
		targetOffset: 	(145.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6270346 1023 250 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(976@475) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1023@250.0) corner: (1039@266.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1023@250.0) corner: (1039@266.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(264503296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1023@250) mouseOver nil nil]
		targetOffset: 	(145.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6270346 1023 250 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1023@250.0) corner: (1039@266.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1023@250.0) corner: (1039@266.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(264503296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1023@250) mouseOver nil nil]
		targetOffset: 	(145.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6270346 1023 250 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(1023@250.0) corner: (1039@266.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1023@250.0) corner: (1039@266.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(264503296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1023@250) mouseOver nil nil]
		targetOffset: 	(145.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6270346 1023 250 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		evt: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(1023@250.0) corner: (1039@266.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1023@250.0) corner: (1039@266.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(264503296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1023@250) mouseOver nil nil]
		targetOffset: 	(145.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6270346 1023 250 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		evtBuf: 	#(1 6267554 976 475 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1023@250.0) corner: (1039@266.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1023@250.0) corner: (1039@266.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(264503296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1023@250) mouseOver nil nil]
		targetOffset: 	(145.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6270346 1023 250 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6270330
		lastStepMessage: 	nil
		lastCycleTime: 	6270370
		alarms: 	a Heap()
		lastAlarmTime: 	6270330
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6270330
		lastStepMessage: 	nil
		lastCycleTime: 	6270370
		alarms: 	a Heap()
		lastAlarmTime: 	6270330
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6270330
		lastStepMessage: 	nil
		lastCycleTime: 	6270370
		alarms: 	a Heap()
		lastAlarmTime: 	6270330
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6270330
		lastStepMessage: 	nil
		lastCycleTime: 	6270370
		alarms: 	a Heap()
		lastAlarmTime: 	6270330
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 6:36:34.228183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


Array(SequenceableCollection)>>do:
	Receiver: #('B')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('B')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('B')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(596639744))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(596639744)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		event: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
		m: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


MouseButtonEvent>>sentTo:
	Receiver: [(976@475) mouseUp 6267554 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		timeStamp: 	6267554
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(976@475)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1022@265.0) corner: (1038@281.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1022@265.0) corner: (1038@281.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(355205120)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1022@265) mouseUp 6271082 nil]
		targetOffset: 	(124.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271082 1022 265 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(976@475) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1022@265.0) corner: (1038@281.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1022@265.0) corner: (1038@281.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(355205120)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1022@265) mouseOver nil nil]
		targetOffset: 	(124.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271082 1022 265 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1022@265.0) corner: (1038@281.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1022@265.0) corner: (1038@281.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(355205120)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1022@265) mouseOver nil nil]
		targetOffset: 	(124.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271082 1022 265 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(1022@265.0) corner: (1038@281.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1022@265.0) corner: (1038@281.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(355205120)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1022@265) mouseOver nil nil]
		targetOffset: 	(124.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271082 1022 265 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		evt: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(1022@265.0) corner: (1038@281.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1022@265.0) corner: (1038@281.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(355205120)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1022@265) mouseOver nil nil]
		targetOffset: 	(124.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271082 1022 265 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		evtBuf: 	#(1 6267554 976 475 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1022@265.0) corner: (1038@281.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1022@265.0) corner: (1038@281.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(355205120)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1022@265) mouseOver nil nil]
		targetOffset: 	(124.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271082 1022 265 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6271072
		lastStepMessage: 	nil
		lastCycleTime: 	6271112
		alarms: 	a Heap()
		lastAlarmTime: 	6271072
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6271072
		lastStepMessage: 	nil
		lastCycleTime: 	6271112
		alarms: 	a Heap()
		lastAlarmTime: 	6271072
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6271072
		lastStepMessage: 	nil
		lastCycleTime: 	6271112
		alarms: 	a Heap()
		lastAlarmTime: 	6271072
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6271072
		lastStepMessage: 	nil
		lastCycleTime: 	6271112
		alarms: 	a Heap()
		lastAlarmTime: 	6271072
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 6:36:34.750183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'B'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


Array(SequenceableCollection)>>do:
	Receiver: #('B')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('B')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('B')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(596639744))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(596639744)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		event: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
		m: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


MouseButtonEvent>>sentTo:
	Receiver: [(976@475) mouseUp 6267554 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		timeStamp: 	6267554
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(976@475)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1002@297.0) corner: (1018@313.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1002@297.0) corner: (1018@313.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(37748736)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1002@297) mouseOver nil nil]
		targetOffset: 	(84.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271610 1002 297 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(976@475) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1002@297.0) corner: (1018@313.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1002@297.0) corner: (1018@313.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(37748736)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1002@297) mouseOver nil nil]
		targetOffset: 	(84.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271610 1002 297 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1002@297.0) corner: (1018@313.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1002@297.0) corner: (1018@313.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(37748736)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1002@297) mouseOver nil nil]
		targetOffset: 	(84.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271610 1002 297 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(1002@297.0) corner: (1018@313.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1002@297.0) corner: (1018@313.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(37748736)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1002@297) mouseOver nil nil]
		targetOffset: 	(84.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271610 1002 297 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(976@475) mouseUp 6267554 nil]
		evt: 	[(976@475) mouseUp 6267554 nil]
	Receiver's instance variables: 
		bounds: 	(1002@297.0) corner: (1018@313.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1002@297.0) corner: (1018@313.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(37748736)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1002@297) mouseOver nil nil]
		targetOffset: 	(84.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271610 1002 297 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(976@475) mouseUp 6267554 nil]
		evtBuf: 	#(1 6267554 976 475 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1002@297.0) corner: (1018@313.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1002@297.0) corner: (1018@313.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(37748736)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1002@297) mouseOver nil nil]
		targetOffset: 	(84.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6271610 1002 297 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6271594
		lastStepMessage: 	nil
		lastCycleTime: 	6271634
		alarms: 	a Heap()
		lastAlarmTime: 	6271594
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6271594
		lastStepMessage: 	nil
		lastCycleTime: 	6271634
		alarms: 	a Heap()
		lastAlarmTime: 	6271594
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6271594
		lastStepMessage: 	nil
		lastCycleTime: 	6271634
		alarms: 	a Heap()
		lastAlarmTime: 	6271594
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6271594
		lastStepMessage: 	nil
		lastCycleTime: 	6271634
		alarms: 	a Heap()
		lastAlarmTime: 	6271594
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 6:36:40.800184 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


Array(SequenceableCollection)>>do:
	Receiver: #('D')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('D')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('D')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(596639744))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(596639744)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		event: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(960@471) mouseUp 6277658 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
		m: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(960@471) mouseUp 6277658 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


MouseButtonEvent>>sentTo:
	Receiver: [(960@471) mouseUp 6277658 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		timeStamp: 	6277658
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(960@471)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(960@471.0) corner: (976@487.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(960@471.0) corner: (976@487.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(960@471) mouseUp 6277658 nil]
		targetOffset: 	(102.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6277658 960 471 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(960@471) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(960@471.0) corner: (976@487.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(960@471.0) corner: (976@487.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(960@471) mouseUp 6277658 nil]
		targetOffset: 	(102.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6277658 960 471 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(960@471.0) corner: (976@487.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(960@471.0) corner: (976@487.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(960@471) mouseUp 6277658 nil]
		targetOffset: 	(102.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6277658 960 471 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(960@471.0) corner: (976@487.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(960@471.0) corner: (976@487.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(960@471) mouseUp 6277658 nil]
		targetOffset: 	(102.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6277658 960 471 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		evt: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(960@471.0) corner: (976@487.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(960@471.0) corner: (976@487.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(960@471) mouseUp 6277658 nil]
		targetOffset: 	(102.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6277658 960 471 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(960@471) mouseUp 6277658 nil]
		evtBuf: 	#(1 6277658 960 471 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(960@471.0) corner: (976@487.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(960@471.0) corner: (976@487.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(596639744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(960@471) mouseUp 6277658 nil]
		targetOffset: 	(102.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6277658 960 471 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6277644
		lastStepMessage: 	nil
		lastCycleTime: 	6277664
		alarms: 	a Heap()
		lastAlarmTime: 	6277644
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6277644
		lastStepMessage: 	nil
		lastCycleTime: 	6277664
		alarms: 	a Heap()
		lastAlarmTime: 	6277644
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6277644
		lastStepMessage: 	nil
		lastCycleTime: 	6277664
		alarms: 	a Heap()
		lastAlarmTime: 	6277644
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(46399488))(a TRMorph(4639948...etc...
		lastStepTime: 	6277690
		lastStepMessage: 	nil
		lastCycleTime: 	6277690
		alarms: 	a Heap()
		lastAlarmTime: 	6277690
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
1 December 2015 6:36:41.868183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	false
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self h...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


Array(SequenceableCollection)>>do:
	Receiver: #('D')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('D')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('D')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow
		nodeOrTopic: 	'node'


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(596639744))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(596639744)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		event: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(960@471) mouseUp 6277658 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
		m: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(596639744))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		evt: 	[(960@471) mouseUp 6277658 nil]
		all: 	an Array(a PluggableButtonMorph(829423616) a PluggableButtonMorph(59663974...etc...
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


MouseButtonEvent>>sentTo:
	Receiver: [(960@471) mouseUp 6277658 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(596639744)
	Receiver's instance variables: 
		timeStamp: 	6277658
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(960@471)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(596639744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(858.0@455.0) corner: (1053.0@484.0)
		owner: 	a PanelMorph(255590400)
		submorphs: 	an Array(an AlignmentMorph(345243648))
		fullBounds: 	(858@455) corner: (1053@484)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (664010752) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(427294720)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(995@261.0) corner: (1011@277.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(995@261.0) corner: (1011@277.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(51642368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(995@261) mouseOver nil nil]
		targetOffset: 	(117.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6278722 995 261 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(960@471) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(995@261.0) corner: (1011@277.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(995@261.0) corner: (1011@277.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(51642368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(995@261) mouseOver nil nil]
		targetOffset: 	(117.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6278722 995 261 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		focusHolder: 	a PluggableButtonMorph(596639744)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(995@261.0) corner: (1011@277.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(995@261.0) corner: (1011@277.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(51642368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(995@261) mouseOver nil nil]
		targetOffset: 	(117.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6278722 995 261 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(995@261.0) corner: (1011@277.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(995@261.0) corner: (1011@277.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(51642368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(995@261) mouseOver nil nil]
		targetOffset: 	(117.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6278722 995 261 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(960@471) mouseUp 6277658 nil]
		evt: 	[(960@471) mouseUp 6277658 nil]
	Receiver's instance variables: 
		bounds: 	(995@261.0) corner: (1011@277.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(995@261.0) corner: (1011@277.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(51642368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(995@261) mouseOver nil nil]
		targetOffset: 	(117.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6278722 995 261 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(960@471) mouseUp 6277658 nil]
		evtBuf: 	#(1 6277658 960 471 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(995@261.0) corner: (1011@277.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(995@261.0) corner: (1011@277.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(51642368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(995@261) mouseOver nil nil]
		targetOffset: 	(117.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6278722 995 261 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(328728576))(a SearchMorp...etc...
		lastStepTime: 	6278712
		lastStepMessage: 	nil
		lastCycleTime: 	6278752
		alarms: 	a Heap()
		lastAlarmTime: 	6278712
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(328728576))(a SearchMorp...etc...
		lastStepTime: 	6278712
		lastStepMessage: 	nil
		lastCycleTime: 	6278752
		alarms: 	a Heap()
		lastAlarmTime: 	6278712
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(328728576))(a SearchMorp...etc...
		lastStepTime: 	6278712
		lastStepMessage: 	nil
		lastCycleTime: 	6278752
		alarms: 	a Heap()
		lastAlarmTime: 	6278712
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(328728576))(a SearchMorp...etc...
		lastStepTime: 	6278712
		lastStepMessage: 	nil
		lastCycleTime: 	6278752
		alarms: 	a Heap()
		lastAlarmTime: 	6278712
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1023672320) a SpecWi...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :item | 
item objName = nameObj
	ifTrue: [ item show: value ].
self halt ] in RQTGMainWindow>>listChange:with:
OrderedCollection>>do:
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>view
3 December 2015 4:19:21.994709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #view
	Receiver: [ :element | element @ RTDraggable @ RTEventForwarder	"AGREGAR DO" ]
	Arguments and temporary variables: 
		aMessage: 	view
		exception: 	MessageNotUnderstood: BlockClosure>>view
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	165
		numArgs: 	1


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(61341696)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(61341696)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #showN...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #view
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>view
3 December 2015 4:24:23.976713 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #view
	Receiver: [ :element | element @ RTDraggable @ RTMenuActivable new action: DataWindow new openWithSp...etc...
	Arguments and temporary variables: 
		aMessage: 	view
		exception: 	MessageNotUnderstood: BlockClosure>>view
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Graph>>createGraph:withView:
		startpc: 	177
		numArgs: 	1


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(477364224)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(477364224)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #showN...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #view
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTElement>>action:
3 December 2015 4:24:43.176712 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTElement(Object)>>doesNotUnderstand: #action:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aMessage: 	action: a WindowModel
		exception: 	MessageNotUnderstood: RTElement>>action:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :element | element @ RTDraggable @ RTMenuActivable new action: DataWindow new openWithSpec ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :element | element @ RTDraggable @ RTMenuActivable new action: DataWi...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	8
		attributes: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(477364224)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(477364224)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...


--- The full stack ---
RTElement(Object)>>doesNotUnderstand: #action:
[ :element | element @ RTDraggable @ RTMenuActivable new action: DataWindow new openWithSpec ] in Graph>>createGraph:withView:
RTGroup(OrderedCollection)>>do:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTElement>>action:
3 December 2015 4:25:41.386712 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTElement(Object)>>doesNotUnderstand: #action:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aMessage: 	action: a WindowModel
		exception: 	MessageNotUnderstood: RTElement>>action:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :element | element @ RTMenuActivable new action: DataWindow new openWithSpec	"@ RTDraggable" ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :element | element @ RTMenuActivable new action: DataWindow new openW...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	12
		attributes: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(477364224)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(477364224)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...


--- The full stack ---
RTElement(Object)>>doesNotUnderstand: #action:
[ :element | element @ RTMenuActivable new action: DataWindow new openWithSpec	"@ RTDraggable" ] in Graph>>createGraph:withView:
RTGroup(OrderedCollection)>>do:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
3 December 2015 4:26:23.370708 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SmallInteger>>*
	Receiver: 55
	Arguments and temporary variables: 
		aNumber: 	(-0.8983843609192008@0.4392101320049426)
	Receiver's instance variables: 
55

RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
		indexOfEdge: 	11
		multipleEdges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdg...etc...
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint>>startingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTLine(RTAbstractLine)>>updateFor:trachelShape:
	Receiver: a RTLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRLineShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	2
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint


RTArrowedLine>>updateFor:trachelShape:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRCompositeShape
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTArrowedLine(RTShape)>>updateFor:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edgeOrElement: 	a RTEdge
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdge(RTShapedObject)>>update
	Receiver: a RTEdge
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTArrowedLine
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		from: 	a RTElement
		to: 	a RTElement
		shouldBeUsedInLayout: 	true


[ :edge | edge update ] in RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 
		edge: 	a RTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :edge | edge update ]
		index: 	14
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	16
		attributes: 	nil


RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement>>translateTo:
	Receiver: a RTElement
	Arguments and temporary variables: 
		newPosition: 	(165.0014997832327@46.0030677384305)
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	nil
		x: 	0.003499494209612931
		len: 	7.953395930938479e-5
		k: 	(3/7)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(165@46)
		y: 	0.007158056337844631
		old: 	nil
		tp: 	(209@136)
		e: 	a RTEdge
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to posit...etc...
		index: 	13
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	16


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	0.003499494209612931
		len: 	7.953395930938479e-5
		k: 	(3/7)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(165@46)
		y: 	0.007158056337844631
		old: 	nil
		tp: 	(209@136)
		quad: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9552476786236189
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in SmallInteger>>*


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9552476786236189
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in SmallInteger>>*


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9552476786236189
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in SmallInteger>>*


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(392@249) a RTElement->(244@389) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.044304798162617266
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(477364224)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(477364224)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil



--- The full stack ---
SmallInteger>>*
RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
RTShorterDistanceWithOffsetAttachPoint>>startingPointOf:
RTLine(RTAbstractLine)>>updateFor:trachelShape:
RTArrowedLine>>updateFor:trachelShape:
RTArrowedLine(RTShape)>>updateFor:
RTEdge(RTShapedObject)>>update
[ :edge | edge update ] in RTElement>>updateConnectedEdges
RTGroup(OrderedCollection)>>do:
RTElement>>updateConnectedEdges
RTElement>>translateTo:
[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
Graph>>addLayout:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 4:41:42.482709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :element | 
self halt.
element
	@
		(RTMenuActivable new
			item: #yourself
			action: [ :e | 
				self halt.
				DataWindow new openWithSpec ])	"@ RTDraggable" ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :element | 
self halt.
element
	@
		(RTMenuActivable new
			item: #yo...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement)
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(676069376)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(676069376)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
[ :element | 
self halt.
element
	@
		(RTMenuActivable new
			item: #yourself
			action: [ :e | 
				self halt.
				DataWindow new openWithSpec ])	"@ RTDraggable" ] in Graph>>createGraph:withView:
RTGroup(OrderedCollection)>>do:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: TextModel>>enable:
3 December 2015 4:49:42.194712 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

TextModel(Object)>>doesNotUnderstand: #enable:
	Receiver: a TextModel
	Arguments and temporary variables: 
		aMessage: 	enable: false
		exception: 	MessageNotUnderstood: TextModel>>enable:
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Text' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		aboutToStyleHolder: 	a NewValueHolder[ [ false ] ]
		behaviorHolder: 	a NewValueHolder[ nil ]
		textHolder: 	a CollectionValueHolder[ 'asdfasdfa' ]
		actionToPerformHolder: 	a NewValueHolder[ [ :text |  ] ]
		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]
		actionPerformedHolder: 	a CollectionValueHolder[ '' ]
		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]
		doItContext: 	a NewValueHolder[ nil ]
		doItReceiver: 	a NewValueHolder[ nil ]
		hasUnacceptedEdits: 	a NewValueHolder[ false ]
		selection: 	a CollectionValueHolder[ (1 to: 0) ]
		scrollValue: 	a NewValueHolder[ (0@0) ]
		menuHolder: 	a NewValueHolder[ [ :menu :shifted | 
shifted
	ifTrue: [ SmalltalkE...etc...
		autoAccept: 	a NewValueHolder[ false ]
		wantsVisualFeedback: 	a NewValueHolder[ true ]
		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'TextModel new text:''asdfasdfa''; enable:false'
		itsSelection: 	a Text for 'TextModel new text:''asdfasdfa''; enable:false'
		itsSelectionString: 	'TextModel new text:''asdfasdfa''; enable:false'
	Receiver's instance variables: 
		ast: 	DoIt
	^ TextModel new
		text: 'asdfasdfa';
		enable: false
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(734527488)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(734527488)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(137363456)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(734527488)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (292@50)
		owner: 	a TransformWithLayoutMorph(259260416)
		submorphs: 	an Array(a RubPrimarySelectionMorph(455081984) a RubCursor(167510016...etc...
		fullBounds: 	(0@0) corner: (292@50)
		color: 	Color transparent
		extension: 	a MorphExtension (138936320) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(220987392)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(167510016)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(10485760))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(137363456)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(292552704))(a DropList...etc...
		lastStepTime: 	1923834
		lastStepMessage: 	nil
		lastCycleTime: 	1923830
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(167510016)))
		lastAlarmTime: 	1923834
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(890503168) a Na...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(292552704))(a DropList...etc...
		lastStepTime: 	1923834
		lastStepMessage: 	nil
		lastCycleTime: 	1923830
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(167510016)))
		lastAlarmTime: 	1923834
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(292552704))(a DropList...etc...
		lastStepTime: 	1923834
		lastStepMessage: 	nil
		lastCycleTime: 	1923830
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(167510016)))
		lastAlarmTime: 	1923834
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(890503168) a Na...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
TextModel(Object)>>doesNotUnderstand: #enable:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 4:50:04.244709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :element | 
self halt.
element
	@
		(RTMenuActivable new
			action: [ :e | 
				self halt.
				DataWindow new ])	"@ RTDraggable" ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :element | 
self halt.
element
	@
		(RTMenuActivable new
			action: [...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement)
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(110624768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(110624768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
[ :element | 
self halt.
element
	@
		(RTMenuActivable new
			action: [ :e | 
				self halt.
				DataWindow new ])	"@ RTDraggable" ] in Graph>>createGraph:withView:
RTGroup(OrderedCollection)>>do:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
3 December 2015 4:50:29.026709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Fraction(Number)>>adaptToFloat:andSend:
	Receiver: (-21/2)
	Arguments and temporary variables: 
		rcvr: 	1.0
		selector: 	#*
	Receiver's instance variables: 
		numerator: 	-21
		denominator: 	2


Float>>*
	Receiver: 1.0
	Arguments and temporary variables: 
		aNumber: 	(-21/2)
	Receiver's instance variables: 
1.0

AthensAffineTransform>>transform:
	Receiver: an AthensAffineTransform
	Arguments and temporary variables: 
		aPoint: 	((-11/2)@ (-21/2))
		px: 	(-11/2)
		py: 	(-21/2)
	Receiver's instance variables: 
		sx: 	1.0
		shx: 	0.0
		x: 	188.0606817100607
		shy: 	0.0
		sy: 	1.0
		y: 	242.9662235959969


TRLabelShape(TRShape)>>transformedEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		basicRectangle: 	((-11/2)@ (-21/2)) corner: ((11/2)@(21/2))
		rotatedRectangle: 	nil
		topLeft: 	nil
		topRight: 	nil
		bottomRight: 	nil
		bottomLeft: 	nil
		p1: 	nil
		p2: 	nil
		p3: 	nil
		p4: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'A'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>encompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'A'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


ByteSymbol(Symbol)>>value:
	Receiver: #encompassingRectangle
	Arguments and temporary variables: 
		anObject: 	a TRLabelShape
	Receiver's instance variables: 
#encompassingRectangle

OrderedCollection>>collect:
	Receiver: an OrderedCollection(a TREllipseShape a TRLabelShape)
	Arguments and temporary variables: 
		aBlock: 	#encompassingRectangle
		newCollection: 	an OrderedCollection((163.0606817100607@217.9662235959969) corne...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a TREllipseShape a TRLabelShape)
		firstIndex: 	1
		lastIndex: 	2


TRCompositeShape>>position
	Receiver: a TRCompositeShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	nil
		color: 	Color gray
		path: 	nil
		strokePaint: 	Color black
		announcer: 	nil
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		shapeAndOffsets: 	an OrderedCollection(an Array(a TREllipseShape (0@0)) an Array...etc...


RTElement>>position
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup()
		shouldUpdateEdges: 	true


RTForceBasedLayout>>repulse:from:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		aNode: 	a RTElement
		aQuad: 	a RTQuadTree
		dx: 	nil
		dy: 	nil
		dn: 	nil
		k: 	nil
		p: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :e | 
e isNil
	ifFalse: [ self repulse: aNode from: e ] ] in RTForceBasedLayout>>repulse:from:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		aNode: 	a RTElement
		aQuad: 	a RTQuadTree
		dx: 	-33.5
		dy: 	38.0
		dn: 	0.01974015319898841
		k: 	nil
		p: 	(187.9778902764575@241.83381611473325)
		e: 	a RTQuadTree
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(nil a RTQuadTree a RTQuadTree nil)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
e isNil
	ifFalse: [ self repulse: aNode from: e ] ]
		index: 	3
	Receiver's instance variables: 
an Array(nil a RTQuadTree a RTQuadTree nil)

RTForceBasedLayout>>repulse:from:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		aNode: 	a RTElement
		aQuad: 	a RTQuadTree
		dx: 	-33.5
		dy: 	38.0
		dn: 	0.01974015319898841
		k: 	nil
		p: 	(187.9778902764575@241.83381611473325)
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :e | 
e isNil
	ifFalse: [ self repulse: aNode from: e ] ] in RTForceBasedLayout>>repulse:from:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		aNode: 	a RTElement
		aQuad: 	a RTQuadTree
		dx: 	10.375000000000028
		dy: 	-42.125
		dn: 	0.023050065450573688
		k: 	nil
		p: 	(188@242)
		e: 	a RTQuadTree
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(a RTQuadTree a RTQuadTree a RTQuadTree a RTQuadTree)
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
e isNil
	ifFalse: [ self repulse: aNode from: e ] ]
		index: 	3
	Receiver's instance variables: 
an Array(a RTQuadTree a RTQuadTree a RTQuadTree a RTQuadTree)

RTForceBasedLayout>>repulse:from:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		aNode: 	a RTElement
		aQuad: 	a RTQuadTree
		dx: 	10.375000000000028
		dy: 	-42.125
		dn: 	0.023050065450573688
		k: 	nil
		p: 	(188@242)
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :e | 
(self isFixed: e)
	ifFalse: [ self repulse: e from: quad ]
	ifTrue: [ translator translateTopLeftOf: e to: (fixedNodes at: e) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a RTElement a RTEleme...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
(self isFixed: e)
	ifFalse: [ self repulse: e from: quad ]
	ifT...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	8


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	200
		len: 	0.00017460871444153345
		k: 	0.0015577974928671192
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(236@63)
		y: 	200
		old: 	nil
		tp: 	(144@105)
		quad: 	a RTQuadTree
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9842646717892211
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Fraction(Number)>>adaptToFloat:andSend:


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9842646717892211
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Fraction(Number)>>adaptToFloat:andSend:


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9842646717892211
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Fraction(Number)>>adaptToFloat:andSend:


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(65.23166628926222@192.00623900467988) ...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.015577974928671192
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(110624768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(110624768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4



--- The full stack ---
Fraction(Number)>>adaptToFloat:andSend:
Float>>*
AthensAffineTransform>>transform:
TRLabelShape(TRShape)>>transformedEncompassingRectangle
TRLabelShape>>encompassingRectangle
ByteSymbol(Symbol)>>value:
OrderedCollection>>collect:
TRCompositeShape>>position
RTElement>>position
RTForceBasedLayout>>repulse:from:
[ :e | 
e isNil
	ifFalse: [ self repulse: aNode from: e ] ] in RTForceBasedLayout>>repulse:from:
Array(SequenceableCollection)>>do:
RTForceBasedLayout>>repulse:from:
[ :e | 
e isNil
	ifFalse: [ self repulse: aNode from: e ] ] in RTForceBasedLayout>>repulse:from:
Array(SequenceableCollection)>>do:
RTForceBasedLayout>>repulse:from:
[ :e | 
(self isFixed: e)
	ifFalse: [ self repulse: e from: quad ]
	ifTrue: [ translator translateTopLeftOf: e to: (fixedNodes at: e) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
Graph>>addLayout:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 4:51:21.280708 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :element | 
element @ RTDraggable @ (RTMenuActivable new action: [ :e | DataWindow new ]).
self halt ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :element | 
element @ RTDraggable @ (RTMenuActivable new action: [ :e...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement)
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(509870080)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(509870080)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
[ :element | 
element @ RTDraggable @ (RTMenuActivable new action: [ :e | DataWindow new ]).
self halt ] in Graph>>createGraph:withView:
RTGroup(OrderedCollection)>>do:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
TestingGraph>>testMainWindow2
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 4:56:28.726709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :e | 
self halt.
element DataWindow new ] in [ :element | 
element @ RTDraggable
	@
		(RTMenuActivable new
			action: [ :e | 
				self halt.
				element DataWindow new ]) ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
		e: 	a RTElement
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>cull:
	Receiver: [ :e | 
self halt.
element DataWindow new ]
	Arguments and temporary variables: 
		anArg: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable
	@
		(RTMenuActivable new
			...etc...
		startpc: 	179
		numArgs: 	1


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		evt: 	[(1396@156) mouseUp 2330310 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		owner: 	a MenuMorph(388759552)
		submorphs: 	#()
		fullBounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		color: 	Color black
		extension: 	a MorphExtension (731119616)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		evt: 	[(1396@156) mouseUp 2330310 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		owner: 	a MenuMorph(388759552)
		submorphs: 	#()
		fullBounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		color: 	Color black
		extension: 	a MorphExtension (731119616)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		evt: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		bounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		owner: 	a MenuMorph(388759552)
		submorphs: 	#()
		fullBounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		color: 	Color black
		extension: 	a MorphExtension (731119616)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		bounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		owner: 	a MenuMorph(388759552)
		submorphs: 	#()
		fullBounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		color: 	Color black
		extension: 	a MorphExtension (731119616)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1396@156) mouseUp 2330310 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindo...etc...
	Receiver's instance variables: 
		timeStamp: 	2330310
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1396@156)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		bounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		owner: 	a MenuMorph(388759552)
		submorphs: 	#()
		fullBounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		color: 	Color black
		extension: 	a MorphExtension (731119616)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		aMorph: 	a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow ...etc...
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1396@156) mouseUp 2330310 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2330310
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1396@156)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		aMorph: 	a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow ...etc...
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		aMorph: 	a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow ...etc...
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		owner: 	a MenuMorph(388759552)
		submorphs: 	#()
		fullBounds: 	(1379.0@142.0) corner: (1616.0@159.0)
		color: 	Color black
		extension: 	a MorphExtension (731119616)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		aMorph: 	a MenuMorph(388759552)
		localEvt: 	[(1396@156) mouseUp 2330310 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataWindow n...etc...
		morphs: 	an Array(a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element Da...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1396@156) mouseUp 2330310 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2330310
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1396@156)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		aMorph: 	a MenuMorph(388759552)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		aMorph: 	a MenuMorph(388759552)
	Receiver's instance variables: 
		morph: 	nil


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(388759552)
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1374.0@137.0) corner: (1621.0@164.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element...etc...
		fullBounds: 	(1374.0@137.0) corner: (1621.0@164.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (455868416) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataW...etc...
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(681836544)'[ :e | 
self h...etc...
		basicColor: 	nil


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(388759552)
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		bounds: 	(1374.0@137.0) corner: (1621.0@164.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element...etc...
		fullBounds: 	(1374.0@137.0) corner: (1621.0@164.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (455868416) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataW...etc...
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(681836544)'[ :e | 
self h...etc...
		basicColor: 	nil


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(388759552)
	Arguments and temporary variables: 
		evt: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		bounds: 	(1374.0@137.0) corner: (1621.0@164.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element...etc...
		fullBounds: 	(1374.0@137.0) corner: (1621.0@164.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (455868416) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(681836544)'[ :e | 
self halt.
element DataW...etc...
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(681836544)'[ :e | 
self h...etc...
		basicColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		focusHolder: 	a MenuMorph(388759552)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1396@156.0) corner: (1412@172.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1396@156.0) corner: (1412@172.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1396@156) mouseOver nil nil]
		targetOffset: 	(17.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2330310 1396 156 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1396@156) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(391380992) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		focusHolder: 	a MenuMorph(388759552)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1396@156.0) corner: (1412@172.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1396@156.0) corner: (1412@172.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1396@156) mouseOver nil nil]
		targetOffset: 	(17.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2330310 1396 156 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		focusHolder: 	a MenuMorph(388759552)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1396@156.0) corner: (1412@172.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1396@156.0) corner: (1412@172.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1396@156) mouseOver nil nil]
		targetOffset: 	(17.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2330310 1396 156 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		bounds: 	(1396@156.0) corner: (1412@172.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1396@156.0) corner: (1412@172.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1396@156) mouseOver nil nil]
		targetOffset: 	(17.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2330310 1396 156 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1396@156) mouseUp 2330310 nil]
		evt: 	[(1396@156) mouseUp 2330310 nil]
	Receiver's instance variables: 
		bounds: 	(1396@156.0) corner: (1412@172.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1396@156.0) corner: (1412@172.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1396@156) mouseOver nil nil]
		targetOffset: 	(17.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2330310 1396 156 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1396@156) mouseUp 2330310 nil]
		evtBuf: 	#(1 2330310 1396 156 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1396@156.0) corner: (1412@172.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1396@156.0) corner: (1412@172.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1396@156) mouseOver nil nil]
		targetOffset: 	(17.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2330310 1396 156 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(305922048))(a TRMorph(305922...etc...
		lastStepTime: 	2330342
		lastStepMessage: 	nil
		lastCycleTime: 	2330340
		alarms: 	a Heap()
		lastAlarmTime: 	2330342
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(305922048))(a TRMorph(305922...etc...
		lastStepTime: 	2330342
		lastStepMessage: 	nil
		lastCycleTime: 	2330340
		alarms: 	a Heap()
		lastAlarmTime: 	2330342
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(305922048))(a TRMorph(305922...etc...
		lastStepTime: 	2330342
		lastStepMessage: 	nil
		lastCycleTime: 	2330340
		alarms: 	a Heap()
		lastAlarmTime: 	2330342
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(305922048))(a TRMorph(305922...etc...
		lastStepTime: 	2330342
		lastStepMessage: 	nil
		lastCycleTime: 	2330340
		alarms: 	a Heap()
		lastAlarmTime: 	2330342
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
[ :e | 
self halt.
element DataWindow new ] in [ :element | 
element @ RTDraggable
	@
		(RTMenuActivable new
			action: [ :e | 
				self halt.
				element DataWindow new ]) ] in Graph>>createGraph:withView:
BlockClosure>>cull:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 4:57:22.114711 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :e | 
self halt.
element DataWindow new ] in [ :element | 
element @ RTDraggable
	@
		(RTMenuActivable new
			action: [ :e | 
				self halt.
				element DataWindow new ]) ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
		e: 	a RTElement
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>cull:
	Receiver: [ :e | 
self halt.
element DataWindow new ]
	Arguments and temporary variables: 
		anArg: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable
	@
		(RTMenuActivable new
			...etc...
		startpc: 	179
		numArgs: 	1


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		evt: 	[(1387@157) mouseUp 2383662 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		owner: 	a MenuMorph(909377536)
		submorphs: 	#()
		fullBounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		color: 	Color black
		extension: 	a MorphExtension (190054400)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		evt: 	[(1387@157) mouseUp 2383662 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		owner: 	a MenuMorph(909377536)
		submorphs: 	#()
		fullBounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		color: 	Color black
		extension: 	a MorphExtension (190054400)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		evt: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		bounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		owner: 	a MenuMorph(909377536)
		submorphs: 	#()
		fullBounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		color: 	Color black
		extension: 	a MorphExtension (190054400)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		bounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		owner: 	a MenuMorph(909377536)
		submorphs: 	#()
		fullBounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		color: 	Color black
		extension: 	a MorphExtension (190054400)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1387@157) mouseUp 2383662 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindo...etc...
	Receiver's instance variables: 
		timeStamp: 	2383662
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1387@157)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		bounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		owner: 	a MenuMorph(909377536)
		submorphs: 	#()
		fullBounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		color: 	Color black
		extension: 	a MorphExtension (190054400)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		aMorph: 	a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow ...etc...
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1387@157) mouseUp 2383662 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2383662
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1387@157)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		aMorph: 	a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow ...etc...
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		aMorph: 	a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow ...etc...
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow new ]'
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		owner: 	a MenuMorph(909377536)
		submorphs: 	#()
		fullBounds: 	(1366.0@151.0) corner: (1603.0@168.0)
		color: 	Color black
		extension: 	a MorphExtension (190054400)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'[ :e | 
self halt.
element DataWindow new ]'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ :e | 
self halt.
element DataWindow new ]
		selector: 	#cull:
		arguments: 	an Array(a RTElement)
		icon: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		aMorph: 	a MenuMorph(909377536)
		localEvt: 	[(1387@157) mouseUp 2383662 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataWindow n...etc...
		morphs: 	an Array(a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element Da...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1387@157) mouseUp 2383662 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2383662
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1387@157)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		aMorph: 	a MenuMorph(909377536)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		aMorph: 	a MenuMorph(909377536)
	Receiver's instance variables: 
		morph: 	nil


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(909377536)
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1361.0@146.0) corner: (1608.0@173.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element...etc...
		fullBounds: 	(1361.0@146.0) corner: (1608.0@173.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (982515712) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataW...etc...
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(140771328)'[ :e | 
self h...etc...
		basicColor: 	nil


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(909377536)
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		bounds: 	(1361.0@146.0) corner: (1608.0@173.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element...etc...
		fullBounds: 	(1361.0@146.0) corner: (1608.0@173.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (982515712) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataW...etc...
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(140771328)'[ :e | 
self h...etc...
		basicColor: 	nil


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(909377536)
	Arguments and temporary variables: 
		evt: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		bounds: 	(1361.0@146.0) corner: (1608.0@173.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element...etc...
		fullBounds: 	(1361.0@146.0) corner: (1608.0@173.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (982515712) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(140771328)'[ :e | 
self halt.
element DataW...etc...
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(140771328)'[ :e | 
self h...etc...
		basicColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		focusHolder: 	a MenuMorph(909377536)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1375@159.0) corner: (1391@175.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1375@159.0) corner: (1391@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(75497472)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1375@159) mouseOver nil nil]
		targetOffset: 	(21.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2383742 1386 158 0 0 0 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1387@157) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(427556864) a Spe...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		focusHolder: 	a MenuMorph(909377536)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1375@159.0) corner: (1391@175.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1375@159.0) corner: (1391@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(75497472)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1375@159) mouseOver nil nil]
		targetOffset: 	(21.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2383742 1386 158 0 0 0 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		focusHolder: 	a MenuMorph(909377536)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1375@159.0) corner: (1391@175.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1375@159.0) corner: (1391@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(75497472)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1375@159) mouseOver nil nil]
		targetOffset: 	(21.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2383742 1386 158 0 0 0 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		bounds: 	(1375@159.0) corner: (1391@175.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1375@159.0) corner: (1391@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(75497472)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1375@159) mouseOver nil nil]
		targetOffset: 	(21.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2383742 1386 158 0 0 0 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1387@157) mouseUp 2383662 nil]
		evt: 	[(1387@157) mouseUp 2383662 nil]
	Receiver's instance variables: 
		bounds: 	(1375@159.0) corner: (1391@175.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1375@159.0) corner: (1391@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(75497472)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1375@159) mouseOver nil nil]
		targetOffset: 	(21.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2383742 1386 158 0 0 0 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1387@157) mouseUp 2383662 nil]
		evtBuf: 	#(1 2383662 1387 157 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1375@159.0) corner: (1391@175.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1375@159.0) corner: (1391@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(75497472)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1375@159) mouseOver nil nil]
		targetOffset: 	(21.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2383742 1386 158 0 0 0 1)
		lastKeyScanCode: 	13
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(305922048))(a TRMorph(305922...etc...
		lastStepTime: 	2383762
		lastStepMessage: 	nil
		lastCycleTime: 	2383762
		alarms: 	a Heap()
		lastAlarmTime: 	2383762
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(305922048))(a TRMorph(305922...etc...
		lastStepTime: 	2383762
		lastStepMessage: 	nil
		lastCycleTime: 	2383762
		alarms: 	a Heap()
		lastAlarmTime: 	2383762
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(305922048))(a TRMorph(305922...etc...
		lastStepTime: 	2383762
		lastStepMessage: 	nil
		lastCycleTime: 	2383762
		alarms: 	a Heap()
		lastAlarmTime: 	2383762
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(305922048))(a TRMorph(305922...etc...
		lastStepTime: 	2383762
		lastStepMessage: 	nil
		lastCycleTime: 	2383762
		alarms: 	a Heap()
		lastAlarmTime: 	2383762
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
[ :e | 
self halt.
element DataWindow new ] in [ :element | 
element @ RTDraggable
	@
		(RTMenuActivable new
			action: [ :e | 
				self halt.
				element DataWindow new ]) ] in Graph>>createGraph:withView:
BlockClosure>>cull:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Node>>key
3 December 2015 5:03:34.436709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node(Object)>>doesNotUnderstand: #key
	Receiver: a Node
	Arguments and temporary variables: 
		aMessage: 	key
		exception: 	MessageNotUnderstood: Node>>key
		resumeValue: 	nil
	Receiver's instance variables: 
		sub: 	an OrderedCollection()
		pub: 	an OrderedCollection(a Topic)
		show: 	true
		nodeName: 	'B'


[ :e | 
DataWindow new data: element model key openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		DataWindow new data: element model key openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
		e: 	a TRMouseLeftClick
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>cull:
	Receiver: [ :e | 
DataWindow new data: element model key openWithSpec.
self halt ]
	Arguments and temporary variables: 
		anArg: 	a TRMouseLeftClick
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	196
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :e | 
DataWindow new data: element model key openWithSpec.
self halt ]
	Arguments and temporary variables: 
		firstArg: 	a TRMouseLeftClick
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	196
		numArgs: 	1


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | 
DataWindow new data: element model key openWithSpec.
self halt ...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		copy: 	nil
		onDoCtx: 	nil
		process: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
Node(Object)>>doesNotUnderstand: #key
[ :e | 
DataWindow new data: element model key openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		DataWindow new data: element model key openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Node>>openWithSpec
3 December 2015 5:04:15.056708 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node(Object)>>doesNotUnderstand: #openWithSpec
	Receiver: a Node
	Arguments and temporary variables: 
		aMessage: 	openWithSpec
		exception: 	MessageNotUnderstood: Node>>openWithSpec
		resumeValue: 	nil
	Receiver's instance variables: 
		sub: 	an OrderedCollection()
		pub: 	an OrderedCollection(a Topic)
		show: 	true
		nodeName: 	'B'


[ :e | 
DataWindow new data: element model openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		DataWindow new data: element model openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
		e: 	a TRMouseLeftClick
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>cull:
	Receiver: [ :e | 
DataWindow new data: element model openWithSpec.
self halt ]
	Arguments and temporary variables: 
		anArg: 	a TRMouseLeftClick
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	192
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :e | 
DataWindow new data: element model openWithSpec.
self halt ]
	Arguments and temporary variables: 
		firstArg: 	a TRMouseLeftClick
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	192
		numArgs: 	1


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | 
DataWindow new data: element model openWithSpec.
self halt ]


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		copy: 	nil
		onDoCtx: 	nil
		process: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
Node(Object)>>doesNotUnderstand: #openWithSpec
[ :e | 
DataWindow new data: element model openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		DataWindow new data: element model openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 5:04:33.160709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		(DataWindow new data: element model) openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
		e: 	a TRMouseLeftClick
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>cull:
	Receiver: [ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]
	Arguments and temporary variables: 
		anArg: 	a TRMouseLeftClick
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	192
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]
	Arguments and temporary variables: 
		firstArg: 	a TRMouseLeftClick
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	192
		numArgs: 	1


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		announcement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


TREllipseShape(TRShape)>>announce:
	Receiver: a TREllipseShape
	Arguments and temporary variables: 
		anEvent: 	a TRMouseLeftClick
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color cyan
		path: 	an AthensCairoPath( 0x91E6D30 )
		strokePaint: 	nil
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		rectangle: 	(-25@ -25) corner: (25@25)
		strokeWidth: 	1


TRMorph>>rtMouseClick:
	Receiver: a TRMorph(799539200)
	Arguments and temporary variables: 
		evt: 	[(1378@129) mouseDown red 2814650 nil]
		relativePosition: 	(202.0@21.0)
		ev: 	a TRMouseLeftClick
		shape: 	a TREllipseShape
	Receiver's instance variables: 
		bounds: 	(1176.0@108.0) corner: (1566.0@342.0)
		owner: 	a PanelMorph(475791360)
		submorphs: 	#()
		fullBounds: 	(1176.0@108.0) corner: (1566.0@342.0)
		color: 	Color blue
		extension: 	a MorphExtension (1026293760) [other:  (model -> a MorphicRoassalAda...etc...
		trachelCanvas: 	a TRCanvas
		surface: 	an AthensCairoSurface
		eventBeginingDragging: 	nil
		shapeBeingPointed: 	a TREllipseShape
		shouldRefresh: 	false
		session: 	a Session


MouseClickState>>click
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		clickClient: 	a TRMorph(799539200)
		clickState: 	#firstClickUp
		firstClickDown: 	[(1378@129) mouseDown red 2814650 nil]
		firstClickUp: 	[(1378@129) mouseUp 2814730 nil]
		firstClickTime: 	2814650
		clickSelector: 	#rtMouseClick:
		dblClickSelector: 	#rtMouseDoubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	#rtMouseDragBegin:
		dragThreshold: 	5


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(1378@129) mouseUp 2814730 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(1378@129) mouseUp 2814730 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a TRMorph(799539200)
		clickState: 	#firstClickUp
		firstClickDown: 	[(1378@129) mouseDown red 2814650 nil]
		firstClickUp: 	[(1378@129) mouseUp 2814730 nil]
		firstClickTime: 	2814650
		clickSelector: 	#rtMouseClick:
		dblClickSelector: 	#rtMouseDoubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	#rtMouseDragBegin:
		dragThreshold: 	5


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@129) mouseUp 2814730 nil]
		evt: 	[(1378@129) mouseUp 2814730 nil]
	Receiver's instance variables: 
		bounds: 	(1378@129.0) corner: (1394@145.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	a TRMorph(799539200)
		keyboardFocus: 	a PanelMorph(956039168)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@129) mouseOver nil nil]
		targetOffset: 	(202.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2814730 1378 129 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1378@129) mouseUp 2814730 nil]
		evtBuf: 	#(1 2814730 1378 129 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1378@129.0) corner: (1394@145.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	a TRMorph(799539200)
		keyboardFocus: 	a PanelMorph(956039168)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@129) mouseOver nil nil]
		targetOffset: 	(202.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2814730 1378 129 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(799539200))(a TRMorph(799539...etc...
		lastStepTime: 	2814800
		lastStepMessage: 	nil
		lastCycleTime: 	2814798
		alarms: 	a Heap()
		lastAlarmTime: 	2814800
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(799539200))(a TRMorph(799539...etc...
		lastStepTime: 	2814800
		lastStepMessage: 	nil
		lastCycleTime: 	2814798
		alarms: 	a Heap()
		lastAlarmTime: 	2814800
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(799539200))(a TRMorph(799539...etc...
		lastStepTime: 	2814800
		lastStepMessage: 	nil
		lastCycleTime: 	2814798
		alarms: 	a Heap()
		lastAlarmTime: 	2814800
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(799539200))(a TRMorph(799539...etc...
		lastStepTime: 	2814800
		lastStepMessage: 	nil
		lastCycleTime: 	2814798
		alarms: 	a Heap()
		lastAlarmTime: 	2814800
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(999817216) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		(DataWindow new data: element model) openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
TREllipseShape(TRShape)>>announce:
TRMorph>>rtMouseClick:
MouseClickState>>click
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 5:04:41.528708 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		(DataWindow new data: element model) openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
		e: 	a TRMouseLeftClick
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>cull:
	Receiver: [ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]
	Arguments and temporary variables: 
		anArg: 	a TRMouseLeftClick
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	192
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]
	Arguments and temporary variables: 
		firstArg: 	a TRMouseLeftClick
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	192
		numArgs: 	1


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		announcement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


TRLabelShape(TRShape)>>announce:
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		anEvent: 	a TRMouseLeftClick
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'B'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRMorph>>rtMouseClick:
	Receiver: a TRMorph(799539200)
	Arguments and temporary variables: 
		evt: 	[(1375@153) mouseDown red 2823044 nil]
		relativePosition: 	(199.0@45.0)
		ev: 	a TRMouseLeftClick
		shape: 	a TRLabelShape
	Receiver's instance variables: 
		bounds: 	(1176.0@108.0) corner: (1566.0@342.0)
		owner: 	a PanelMorph(475791360)
		submorphs: 	#()
		fullBounds: 	(1176.0@108.0) corner: (1566.0@342.0)
		color: 	Color blue
		extension: 	a MorphExtension (1026293760) [other:  (model -> a MorphicRoassalAda...etc...
		trachelCanvas: 	a TRCanvas
		surface: 	an AthensCairoSurface
		eventBeginingDragging: 	nil
		shapeBeingPointed: 	a TRLabelShape
		shouldRefresh: 	false
		session: 	a Session


MouseClickState>>click
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		clickClient: 	a TRMorph(799539200)
		clickState: 	#firstClickUp
		firstClickDown: 	[(1375@153) mouseDown red 2823044 nil]
		firstClickUp: 	[(1375@153) mouseUp 2823104 nil]
		firstClickTime: 	2823044
		clickSelector: 	#rtMouseClick:
		dblClickSelector: 	#rtMouseDoubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	#rtMouseDragBegin:
		dragThreshold: 	5


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(1375@153) mouseUp 2823104 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(1375@153) mouseUp 2823104 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a TRMorph(799539200)
		clickState: 	#firstClickUp
		firstClickDown: 	[(1375@153) mouseDown red 2823044 nil]
		firstClickUp: 	[(1375@153) mouseUp 2823104 nil]
		firstClickTime: 	2823044
		clickSelector: 	#rtMouseClick:
		dblClickSelector: 	#rtMouseDoubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	#rtMouseDragBegin:
		dragThreshold: 	5


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1375@153) mouseUp 2823104 nil]
		evt: 	[(1375@153) mouseUp 2823104 nil]
	Receiver's instance variables: 
		bounds: 	(1375@153.0) corner: (1391@169.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	a TRMorph(799539200)
		keyboardFocus: 	a PanelMorph(143654912)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1375@153) mouseOver nil nil]
		targetOffset: 	(199.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2823104 1375 153 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1375@153) mouseUp 2823104 nil]
		evtBuf: 	#(1 2823104 1375 153 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1375@153.0) corner: (1391@169.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	a TRMorph(799539200)
		keyboardFocus: 	a PanelMorph(143654912)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1375@153) mouseOver nil nil]
		targetOffset: 	(199.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2823104 1375 153 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(799539200))(a TRMorph(799539...etc...
		lastStepTime: 	2823164
		lastStepMessage: 	nil
		lastCycleTime: 	2823162
		alarms: 	a Heap()
		lastAlarmTime: 	2823164
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(799539200))(a TRMorph(799539...etc...
		lastStepTime: 	2823164
		lastStepMessage: 	nil
		lastCycleTime: 	2823162
		alarms: 	a Heap()
		lastAlarmTime: 	2823164
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(799539200))(a TRMorph(799539...etc...
		lastStepTime: 	2823164
		lastStepMessage: 	nil
		lastCycleTime: 	2823162
		alarms: 	a Heap()
		lastAlarmTime: 	2823164
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(799539200))(a TRMorph(799539...etc...
		lastStepTime: 	2823164
		lastStepMessage: 	nil
		lastCycleTime: 	2823162
		alarms: 	a Heap()
		lastAlarmTime: 	2823164
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(247988224) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		(DataWindow new data: element model) openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
TRLabelShape(TRShape)>>announce:
TRMorph>>rtMouseClick:
MouseClickState>>click
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 5:07:22.592709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		(DataWindow new data: element model) openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		element: 	a RTElement
		e: 	a TRMouseLeftClick
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>cull:
	Receiver: [ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]
	Arguments and temporary variables: 
		anArg: 	a TRMouseLeftClick
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	192
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]
	Arguments and temporary variables: 
		firstArg: 	a TRMouseLeftClick
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	[ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
...etc...
		startpc: 	192
		numArgs: 	1


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ]


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
		announcement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


TREllipseShape(TRShape)>>announce:
	Receiver: a TREllipseShape
	Arguments and temporary variables: 
		anEvent: 	a TRMouseLeftClick
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color cyan
		path: 	an AthensCairoPath( 0x9C6A0A0 )
		strokePaint: 	nil
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		rectangle: 	(-25@ -25) corner: (25@25)
		strokeWidth: 	1


TRMorph>>rtMouseClick:
	Receiver: a TRMorph(595591168)
	Arguments and temporary variables: 
		evt: 	[(1370@140) mouseDown red 2984102 nil]
		relativePosition: 	(194.0@32.0)
		ev: 	a TRMouseLeftClick
		shape: 	a TREllipseShape
	Receiver's instance variables: 
		bounds: 	(1176.0@108.0) corner: (1566.0@342.0)
		owner: 	a PanelMorph(271843328)
		submorphs: 	#()
		fullBounds: 	(1176.0@108.0) corner: (1566.0@342.0)
		color: 	Color blue
		extension: 	a MorphExtension (822345728) [other:  (model -> a MorphicRoassalAdap...etc...
		trachelCanvas: 	a TRCanvas
		surface: 	an AthensCairoSurface
		eventBeginingDragging: 	nil
		shapeBeingPointed: 	a TREllipseShape
		shouldRefresh: 	false
		session: 	a Session


MouseClickState>>click
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		clickClient: 	a TRMorph(595591168)
		clickState: 	#firstClickUp
		firstClickDown: 	[(1370@140) mouseDown red 2984102 nil]
		firstClickUp: 	[(1370@140) mouseUp 2984166 nil]
		firstClickTime: 	2984102
		clickSelector: 	#rtMouseClick:
		dblClickSelector: 	#rtMouseDoubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	#rtMouseDragBegin:
		dragThreshold: 	5


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(1370@140) mouseUp 2984166 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(1370@140) mouseUp 2984166 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a TRMorph(595591168)
		clickState: 	#firstClickUp
		firstClickDown: 	[(1370@140) mouseDown red 2984102 nil]
		firstClickUp: 	[(1370@140) mouseUp 2984166 nil]
		firstClickTime: 	2984102
		clickSelector: 	#rtMouseClick:
		dblClickSelector: 	#rtMouseDoubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	#rtMouseDragBegin:
		dragThreshold: 	5


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1370@140) mouseUp 2984166 nil]
		evt: 	[(1370@140) mouseUp 2984166 nil]
	Receiver's instance variables: 
		bounds: 	(1370@140.0) corner: (1386@156.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	a TRMorph(595591168)
		keyboardFocus: 	a PanelMorph(380633088)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1370@140) mouseUp 2984166 nil]
		targetOffset: 	(194.0@32.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2984166 1370 140 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1370@140) mouseUp 2984166 nil]
		evtBuf: 	#(1 2984166 1370 140 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1370@140.0) corner: (1386@156.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	a TRMorph(595591168)
		keyboardFocus: 	a PanelMorph(380633088)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1370@140) mouseUp 2984166 nil]
		targetOffset: 	(194.0@32.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2984166 1370 140 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(595591168))(a TRMorph(595591...etc...
		lastStepTime: 	2984152
		lastStepMessage: 	nil
		lastCycleTime: 	2984172
		alarms: 	a Heap()
		lastAlarmTime: 	2984152
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(595591168))(a TRMorph(595591...etc...
		lastStepTime: 	2984152
		lastStepMessage: 	nil
		lastCycleTime: 	2984172
		alarms: 	a Heap()
		lastAlarmTime: 	2984152
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(595591168))(a TRMorph(595591...etc...
		lastStepTime: 	2984152
		lastStepMessage: 	nil
		lastCycleTime: 	2984172
		alarms: 	a Heap()
		lastAlarmTime: 	2984152
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(595591168))(a TRMorph(595591...etc...
		lastStepTime: 	2984152
		lastStepMessage: 	nil
		lastCycleTime: 	2984172
		alarms: 	a Heap()
		lastAlarmTime: 	2984152
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(535560192) a SpecWin...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :e | 
(DataWindow new data: element model) openWithSpec.
self halt ] in [ :element | 
element @ RTDraggable.
element
	when: TRMouseClick
	do: [ :e | 
		(DataWindow new data: element model) openWithSpec.
		self halt ] ] in Graph>>createGraph:withView:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
TREllipseShape(TRShape)>>announce:
TRMorph>>rtMouseClick:
MouseClickState>>click
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Association>>objName
3 December 2015 5:10:00.970709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Association(Object)>>doesNotUnderstand: #objName
	Receiver: a Node->a Node
	Arguments and temporary variables: 
		aMessage: 	objName
		exception: 	MessageNotUnderstood: Association>>objName
		resumeValue: 	nil
	Receiver's instance variables: 
		key: 	a Node
		value: 	a Node


DataWindow>>data:
	Receiver: a DataWindow
	Arguments and temporary variables: 
		anObject: 	a Node->a Node
	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Info Node/Topics' ]
		data: 	a Node->a Node
		dataType: 	a TextModel
		dataDetail: 	a TextModel


[ :e | (DataWindow new data: edge model) openWithSpec ] in [ :edge | 
self withNameTopic: edge.
edge when: TRMouseClick do: [ :e | (DataWindow new data: edge model) openWithSpec ] ] in Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		aView: 	a RTViewForSpec
		edge: 	a RTEdge
		e: 	a TRMouseLeftClick
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


BlockClosure>>cull:
	Receiver: [ :e | (DataWindow new data: edge model) openWithSpec ]
	Arguments and temporary variables: 
		anArg: 	a TRMouseLeftClick
	Receiver's instance variables: 
		outerContext: 	[ :edge | 
self withNameTopic: edge.
edge when: TRMouseClick do: ...etc...
		startpc: 	222
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :e | (DataWindow new data: edge model) openWithSpec ]
	Arguments and temporary variables: 
		firstArg: 	a TRMouseLeftClick
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	[ :edge | 
self withNameTopic: edge.
edge when: TRMouseClick do: ...etc...
		startpc: 	222
		numArgs: 	1


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseClick
		subscriber: 	a Graph
		action: 	[ :e | (DataWindow new data: edge model) openWithSpec ]


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		copy: 	nil
		onDoCtx: 	nil
		process: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
Association(Object)>>doesNotUnderstand: #objName
DataWindow>>data:
[ :e | (DataWindow new data: edge model) openWithSpec ] in [ :edge | 
self withNameTopic: edge.
edge when: TRMouseClick do: [ :e | (DataWindow new data: edge model) openWithSpec ] ] in Graph>>createGraph:withView:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: SmallInteger>>collect:
3 December 2015 5:27:04.028712 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SmallInteger(Object)>>doesNotUnderstand: #collect:
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	collect: [ :e | self halt ]
		exception: 	MessageNotUnderstood: SmallInteger>>collect:
		resumeValue: 	nil
	Receiver's instance variables: 
1

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://lo...etc...
		itsSelection: 	a Text for '| proxy systemState |
proxy := XMLRPCProxy withUrl:''...etc...
		itsSelectionString: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http:...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(494403584))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(551813120))(a DropList...etc...
		lastStepTime: 	4165580
		lastStepMessage: 	nil
		lastCycleTime: 	4165600
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	4165580
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(551813120))(a DropList...etc...
		lastStepTime: 	4165580
		lastStepMessage: 	nil
		lastCycleTime: 	4165600
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	4165580
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(551813120))(a DropList...etc...
		lastStepTime: 	4165580
		lastStepMessage: 	nil
		lastCycleTime: 	4165600
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	4165580
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: SmallInteger>>first
3 December 2015 5:27:46.752715 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SmallInteger(Object)>>doesNotUnderstand: #first
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	first
		exception: 	MessageNotUnderstood: SmallInteger>>first
		resumeValue: 	nil
	Receiver's instance variables: 
1

[ :item | item first ] in Array>>DoIt
	Receiver: #(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosout' #('/rosout')))...etc...
	Arguments and temporary variables: 
		item: 	1
	Receiver's instance variables: 
#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosout' #('/rosout')))...etc...

Array(SequenceableCollection)>>collect:
	Receiver: #(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosout' #('/rosout')))...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :item | item first ]
		newCollection: 	#(nil nil nil)
		index: 	1
	Receiver's instance variables: 
#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosout' #('/rosout')))...etc...

Array>>DoIt
	Receiver: #(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosout' #('/rosout')))...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosout' #('/rosout')))...etc...

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self collect: [ :item | item first ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/r...etc...
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#('/rosou...etc...
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(943194112)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(943194112)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(424411136)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	4208314
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 
		anArgument: 	4208324
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	4208314
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	4208324
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(210239488)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(318504960))(a DropList...etc...
		lastStepTime: 	4208366
		lastStepMessage: 	nil
		lastCycleTime: 	4208362
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(210239488)))
		lastAlarmTime: 	4208366
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		now: 	4208324
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(318504960))(a DropList...etc...
		lastStepTime: 	4208366
		lastStepMessage: 	nil
		lastCycleTime: 	4208362
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(210239488)))
		lastAlarmTime: 	4208366
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(318504960))(a DropList...etc...
		lastStepTime: 	4208366
		lastStepMessage: 	nil
		lastCycleTime: 	4208362
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(210239488)))
		lastAlarmTime: 	4208366
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(651165696) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(318504960))(a DropList...etc...
		lastStepTime: 	4208366
		lastStepMessage: 	nil
		lastCycleTime: 	4208362
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(210239488)))
		lastAlarmTime: 	4208366
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(318504960))(a DropList...etc...
		lastStepTime: 	4208366
		lastStepMessage: 	nil
		lastCycleTime: 	4208362
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(210239488)))
		lastAlarmTime: 	4208366
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(651165696) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #first
[ :item | item first ] in Array>>DoIt
Array(SequenceableCollection)>>collect:
Array>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 5:31:51.626713 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :e | self halt ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
		e: 	#('/rosout_agg' #('/rosout'))
	Receiver's instance variables: 
nil

Array(SequenceableCollection)>>collect:
	Receiver: #(#('/rosout_agg' #('/rosout')))
	Arguments and temporary variables: 
		aBlock: 	[ :e | self halt ]
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#('/rosout_agg' #('/rosout')))

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://lo...etc...
		itsSelection: 	a Text for '| proxy systemState |
proxy := XMLRPCProxy withUrl:''...etc...
		itsSelectionString: 	'| proxy systemState |
proxy := XMLRPCProxy withUrl:''http:...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	(0@0) corner: (442@259)
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(841744384))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4430462
		lastStepMessage: 	nil
		lastCycleTime: 	4453274
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	4453274
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Sy...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4430462
		lastStepMessage: 	nil
		lastCycleTime: 	4453274
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	4453274
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4430462
		lastStepMessage: 	nil
		lastCycleTime: 	4453274
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	4453274
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Sy...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :e | self halt ] in UndefinedObject>>DoIt
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: PharoTutorial class>>back
3 December 2015 5:54:35.298712 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

PharoTutorial class(Object)>>doesNotUnderstand: #back
	Receiver: PharoTutorial
	Arguments and temporary variables: 
		aMessage: 	back
		exception: 	MessageNotUnderstood: PharoTutorial class>>back
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#close->PharoTutorial>>#close #first->PharoTutor...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#lessonView #player)
		organization: 	a ClassOrganization
		subclasses: 	{ProfStef}
		name: 	#PharoTutorial
		classPool: 	a Dictionary(#Instance->a PharoTutorial )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ProfStef-Core'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'3 = 3 ifTrue: [PharoTutorial back].'
		itsSelection: 	a Text for '3 = 3 ifTrue: [PharoTutorial back].'
		itsSelectionString: 	'3 = 3 ifTrue: [PharoTutorial back].'
	Receiver's instance variables: 
		ast: 	DoIt
	^ 3 = 3
		ifTrue: [ PharoTutorial back ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(11534336)
		selectionShowing: 	true
		model: 	a LessonView
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(11534336)
		selectionShowing: 	true
		model: 	a LessonView
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1037565952)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(102.0@301.0) corner: (1013.0@782.0)
		owner: 	a SystemWindow(846725120)
		submorphs: 	an Array(a TransformMorph(59244544))
		fullBounds: 	(102@301) corner: (1013@782)
		color: 	Color white
		extension: 	a MorphExtension (190840832) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a LessonView
		scrollBar: 	a ScrollBar(28835840)
		scroller: 	a TransformMorph(59244544)
		getMenuSelector: 	#shoutMorphFillMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(633339904)
		textMorph: 	a TextMorphForEditView(11534336)
		getTextSelector: 	nil
		setTextSelector: 	nil
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(319 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1037565952)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(102.0@301.0) corner: (1013.0@782.0)
		owner: 	a SystemWindow(846725120)
		submorphs: 	an Array(a TransformMorph(59244544))
		fullBounds: 	(102@301) corner: (1013@782)
		color: 	Color white
		extension: 	a MorphExtension (190840832) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a LessonView
		scrollBar: 	a ScrollBar(28835840)
		scroller: 	a TransformMorph(59244544)
		getMenuSelector: 	#shoutMorphFillMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(633339904)
		textMorph: 	a TextMorphForEditView(11534336)
		getTextSelector: 	nil
		setTextSelector: 	nil
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(319 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1037565952)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(102.0@301.0) corner: (1013.0@782.0)
		owner: 	a SystemWindow(846725120)
		submorphs: 	an Array(a TransformMorph(59244544))
		fullBounds: 	(102@301) corner: (1013@782)
		color: 	Color white
		extension: 	a MorphExtension (190840832) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a LessonView
		scrollBar: 	a ScrollBar(28835840)
		scroller: 	a TransformMorph(59244544)
		getMenuSelector: 	#shoutMorphFillMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(633339904)
		textMorph: 	a TextMorphForEditView(11534336)
		getTextSelector: 	nil
		setTextSelector: 	nil
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(319 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1037565952)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(102.0@301.0) corner: (1013.0@782.0)
		owner: 	a SystemWindow(846725120)
		submorphs: 	an Array(a TransformMorph(59244544))
		fullBounds: 	(102@301) corner: (1013@782)
		color: 	Color white
		extension: 	a MorphExtension (190840832) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a LessonView
		scrollBar: 	a ScrollBar(28835840)
		scroller: 	a TransformMorph(59244544)
		getMenuSelector: 	#shoutMorphFillMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(633339904)
		textMorph: 	a TextMorphForEditView(11534336)
		getTextSelector: 	nil
		setTextSelector: 	nil
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(319 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1037565952)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1037565952)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	121
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1037565952)
		secondArg: 	a PluggableTextMorph(1037565952)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	121
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1037565952)
		secondArg: 	a PluggableTextMorph(1037565952)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	121
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Ctrl + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1037565952)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1037565952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Ctrl + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Ctrl + D
		defaultShortcut: 	Ctrl + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Ctrl + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Ctrl + D
		defaultShortcut: 	Ctrl + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Ctrl + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Ctrl + D
		defaultShortcut: 	Ctrl + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Ctrl + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]
 #doIt on Ctrl + D do [ :morp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	6
		each: 	#doIt on Ctrl + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]
 nil nil...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1037565952)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1037565952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#ScrollPane) aKMCategoryTarget(#TextEditor) aK...etc...
		morph: 	a PluggableTextMorph(1037565952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#ScrollPane) aKMCategoryTarg...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#ScrollPane) aKMCatego...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#ScrollPane) aKMCategoryTarget(#TextEditor) aK...etc...
		morph: 	a PluggableTextMorph(1037565952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1037565952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(11534336)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(11534336)
	Receiver's instance variables: 
		timeStamp: 	5816850
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(272@258.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	4
		charCode: 	100
		scanCode: 	4


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a TextMorphForEditView(11534336)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(370@551.0) corner: (386@567.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(370@551.0) corner: (386@567.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(378@560) mouseOver nil nil]
		targetOffset: 	(187.0@338.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5810290 377 561 0 0 0 1)
		lastKeyScanCode: 	4
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(846725120) a Nauti...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil



--- The full stack ---
PharoTutorial class(Object)>>doesNotUnderstand: #back
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: PharoTutorial class>>prev
3 December 2015 5:54:42.094709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

PharoTutorial class(Object)>>doesNotUnderstand: #prev
	Receiver: PharoTutorial
	Arguments and temporary variables: 
		aMessage: 	prev
		exception: 	MessageNotUnderstood: PharoTutorial class>>prev
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#close->PharoTutorial>>#close #first->PharoTutor...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#lessonView #player)
		organization: 	a ClassOrganization
		subclasses: 	{ProfStef}
		name: 	#PharoTutorial
		classPool: 	a Dictionary(#Instance->a PharoTutorial )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ProfStef-Core'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'3 = 3 ifTrue: [PharoTutorial prev].'
		itsSelection: 	a Text for '3 = 3 ifTrue: [PharoTutorial prev].'
		itsSelectionString: 	'3 = 3 ifTrue: [PharoTutorial prev].'
	Receiver's instance variables: 
		ast: 	DoIt
	^ 3 = 3
		ifTrue: [ PharoTutorial prev ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(11534336)
		selectionShowing: 	true
		model: 	a LessonView
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(11534336)
		selectionShowing: 	true
		model: 	a LessonView
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1037565952)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(102.0@301.0) corner: (1013.0@782.0)
		owner: 	a SystemWindow(846725120)
		submorphs: 	an Array(a TransformMorph(59244544))
		fullBounds: 	(102@301) corner: (1013@782)
		color: 	Color white
		extension: 	a MorphExtension (190840832) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a LessonView
		scrollBar: 	a ScrollBar(28835840)
		scroller: 	a TransformMorph(59244544)
		getMenuSelector: 	#shoutMorphFillMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(633339904)
		textMorph: 	a TextMorphForEditView(11534336)
		getTextSelector: 	nil
		setTextSelector: 	nil
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(319 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1037565952)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(102.0@301.0) corner: (1013.0@782.0)
		owner: 	a SystemWindow(846725120)
		submorphs: 	an Array(a TransformMorph(59244544))
		fullBounds: 	(102@301) corner: (1013@782)
		color: 	Color white
		extension: 	a MorphExtension (190840832) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a LessonView
		scrollBar: 	a ScrollBar(28835840)
		scroller: 	a TransformMorph(59244544)
		getMenuSelector: 	#shoutMorphFillMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(633339904)
		textMorph: 	a TextMorphForEditView(11534336)
		getTextSelector: 	nil
		setTextSelector: 	nil
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(319 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1037565952)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(102.0@301.0) corner: (1013.0@782.0)
		owner: 	a SystemWindow(846725120)
		submorphs: 	an Array(a TransformMorph(59244544))
		fullBounds: 	(102@301) corner: (1013@782)
		color: 	Color white
		extension: 	a MorphExtension (190840832) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a LessonView
		scrollBar: 	a ScrollBar(28835840)
		scroller: 	a TransformMorph(59244544)
		getMenuSelector: 	#shoutMorphFillMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(633339904)
		textMorph: 	a TextMorphForEditView(11534336)
		getTextSelector: 	nil
		setTextSelector: 	nil
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(319 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1037565952)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(102.0@301.0) corner: (1013.0@782.0)
		owner: 	a SystemWindow(846725120)
		submorphs: 	an Array(a TransformMorph(59244544))
		fullBounds: 	(102@301) corner: (1013@782)
		color: 	Color white
		extension: 	a MorphExtension (190840832) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a LessonView
		scrollBar: 	a ScrollBar(28835840)
		scroller: 	a TransformMorph(59244544)
		getMenuSelector: 	#shoutMorphFillMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(633339904)
		textMorph: 	a TextMorphForEditView(11534336)
		getTextSelector: 	nil
		setTextSelector: 	nil
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(319 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1037565952)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1037565952)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	121
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1037565952)
		secondArg: 	a PluggableTextMorph(1037565952)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	121
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1037565952)
		secondArg: 	a PluggableTextMorph(1037565952)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	121
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Ctrl + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1037565952)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1037565952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Ctrl + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Ctrl + D
		defaultShortcut: 	Ctrl + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Ctrl + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Ctrl + D
		defaultShortcut: 	Ctrl + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Ctrl + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Ctrl + D
		defaultShortcut: 	Ctrl + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Ctrl + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]
 #doIt on Ctrl + D do [ :morp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	6
		each: 	#doIt on Ctrl + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]
 nil nil...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1037565952)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1037565952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#ScrollPane) aKMCategoryTarget(#TextEditor) aK...etc...
		morph: 	a PluggableTextMorph(1037565952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#ScrollPane) aKMCategoryTarg...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#ScrollPane) aKMCatego...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#ScrollPane) aKMCategoryTarget(#TextEditor) aK...etc...
		morph: 	a PluggableTextMorph(1037565952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1037565952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(11534336)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(11534336)
	Receiver's instance variables: 
		timeStamp: 	5823698
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(189@368.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	4
		charCode: 	100
		scanCode: 	4


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(11534336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (903@325)
		owner: 	a TransformMorph(59244544)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (903@325)
		color: 	Color black
		extension: 	a MorphExtension (63438848) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Sans Pro
		text: 	a Text for '"Conditionals are just messages sent to Boolean objects"

1 <...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	nil
		editView: 	a PluggableTextMorph(1037565952)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a TextMorphForEditView(11534336)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(295@670.0) corner: (311@686.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(295@670.0) corner: (311@686.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(295@670) mouseOver nil nil]
		targetOffset: 	(171@318)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5822218 294 670 0 0 0 1)
		lastKeyScanCode: 	4
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(846725120) a Nauti...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil



--- The full stack ---
PharoTutorial class(Object)>>doesNotUnderstand: #prev
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Adapter>>topics
3 December 2015 6:02:58.176712 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Adapter(Object)>>doesNotUnderstand: #topics
	Receiver: an Adapter
	Arguments and temporary variables: 
		aMessage: 	topics
		exception: 	MessageNotUnderstood: Adapter>>topics
		resumeValue: 	nil
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


Adapter>>createTopic:
	Receiver: an Adapter
	Arguments and temporary variables: 
		aTopicName: 	'/rosout_agg'
		exist: 	nil
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic ] ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
		newTopic: 	nil
		newNode: 	nil
		e: 	#('/rosout_agg' #('/rosout'))
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


Array(SequenceableCollection)>>collect:
	Receiver: #(#('/rosout_agg' #('/rosout')))
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode |...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#('/rosout_agg' #('/rosout')))

Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		newTopic: 	nil
		newNode: 	nil
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://l...etc...
		itsSelection: 	a Text for '"| proxy systemState |
proxy := XMLRPCProxy withUrl:'...etc...
		itsSelectionString: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(661389312))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(773324800))(a SearchMorp...etc...
		lastStepTime: 	6319716
		lastStepMessage: 	nil
		lastCycleTime: 	6319736
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6319716
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(773324800))(a SearchMorp...etc...
		lastStepTime: 	6319716
		lastStepMessage: 	nil
		lastCycleTime: 	6319736
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6319716
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(773324800))(a SearchMorp...etc...
		lastStepTime: 	6319716
		lastStepMessage: 	nil
		lastCycleTime: 	6319736
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6319716
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Adapter(Object)>>doesNotUnderstand: #topics
Adapter>>createTopic:
[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic ] ] in Adapter>>getData
Array(SequenceableCollection)>>collect:
Adapter>>getData
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 6:04:22.704709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
self halt ] in [ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		self halt ] ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
		e: 	#('/rosout_agg' #('/rosout'))
		newTopic: 	a Topic
		newNode: 	a Node
		aNode: 	'/rosout'
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


Array(SequenceableCollection)>>do:
	Receiver: #('/rosout')
	Arguments and temporary variables: 
		aBlock: 	[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
s...etc...
		index: 	1
	Receiver's instance variables: 
#('/rosout')

[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		self halt ] ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
		newTopic: 	a Topic
		newNode: 	a Node
		e: 	#('/rosout_agg' #('/rosout'))
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


Array(SequenceableCollection)>>collect:
	Receiver: #(#('/rosout_agg' #('/rosout')))
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode |...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#('/rosout_agg' #('/rosout')))

Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		newTopic: 	a Topic
		newNode: 	a Node
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://l...etc...
		itsSelection: 	a Text for '"| proxy systemState |
proxy := XMLRPCProxy withUrl:'...etc...
		itsSelectionString: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(586940416))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(728498176))(a DropList...etc...
		lastStepTime: 	6404236
		lastStepMessage: 	nil
		lastCycleTime: 	6404298
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6404236
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(728498176))(a DropList...etc...
		lastStepTime: 	6404236
		lastStepMessage: 	nil
		lastCycleTime: 	6404298
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6404236
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(728498176))(a DropList...etc...
		lastStepTime: 	6404236
		lastStepMessage: 	nil
		lastCycleTime: 	6404298
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6404236
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
self halt ] in [ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		self halt ] ] in Adapter>>getData
Array(SequenceableCollection)>>do:
[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		self halt ] ] in Adapter>>getData
Array(SequenceableCollection)>>collect:
Adapter>>getData
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
3 December 2015 6:06:41.724709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
nodes add: newNode.
self halt ] in [ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode.
		self halt ].
topics add: newTopic ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
		e: 	#('/rosout_agg' #('/rosout'))
		newTopic: 	a Topic
		newNode: 	a Node
		aNode: 	'/rosout'
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection(a Node)


Array(SequenceableCollection)>>do:
	Receiver: #('/rosout')
	Arguments and temporary variables: 
		aBlock: 	[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
n...etc...
		index: 	1
	Receiver's instance variables: 
#('/rosout')

[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode.
		self halt ].
topics add: newTopic ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
		newTopic: 	a Topic
		newNode: 	a Node
		e: 	#('/rosout_agg' #('/rosout'))
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection(a Node)


Array(SequenceableCollection)>>collect:
	Receiver: #(#('/rosout_agg' #('/rosout')))
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode |...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#('/rosout_agg' #('/rosout')))

Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		newTopic: 	a Topic
		newNode: 	a Node
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/rosout_agg' #('/rosout'))) #(#(...etc...
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection(a Node)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://l...etc...
		itsSelection: 	a Text for '"| proxy systemState |
proxy := XMLRPCProxy withUrl:'...etc...
		itsSelectionString: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(346554368))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(605290496))(a SearchMorp...etc...
		lastStepTime: 	6543286
		lastStepMessage: 	nil
		lastCycleTime: 	6543306
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6543286
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(605290496))(a SearchMorp...etc...
		lastStepTime: 	6543286
		lastStepMessage: 	nil
		lastCycleTime: 	6543306
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6543286
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(605290496))(a SearchMorp...etc...
		lastStepTime: 	6543286
		lastStepMessage: 	nil
		lastCycleTime: 	6543306
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	6543286
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
nodes add: newNode.
self halt ] in [ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode.
		self halt ].
topics add: newTopic ] in Adapter>>getData
Array(SequenceableCollection)>>do:
[ :e | 
newTopic := self createTopic: e first.
e second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode.
		self halt ].
topics add: newTopic ] in Adapter>>getData
Array(SequenceableCollection)>>collect:
Adapter>>getData
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
3 December 2015 6:21:32.218709 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SmallInteger>>-
	Receiver: 7
	Arguments and temporary variables: 
		aNumber: 	5.5520172119140625
	Receiver's instance variables: 
7

FreeTypeFont>>widthOfString:from:to:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
		startIndex: 	1
		stopIndex: 	28
		char: 	$r
		nextChar: 	nil
		resultX: 	219.6964111328125
		glyph: 	GlyphForm(7x10x32)
		a: 	#(5.5520172119140625 5.5520172119140625)
		subPixelPosition: 	45
		i: 	28
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0x91518A8>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	nil
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont(AbstractFont)>>widthOfString:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0x91518A8>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	nil
		subPixelPositioned: 	true
		symbolFont: 	false


LogicalFont>>widthOfString:
	Receiver: a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
 realFont: FreeTy...etc...
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
	Receiver's instance variables: 
		realFont: 	FreeTypeFont('Source Sans Pro' 'Regular' 12)
		emphasis: 	nil
		familyName: 	'Source Sans Pro'
		fallbackFamilyNames: 	nil
		pointSize: 	12
		stretchValue: 	5
		weightValue: 	400
		slantValue: 	0
		derivatives: 	nil
		boldDerivative: 	nil
		italicDerivative: 	nil
		boldItalicDerivative: 	nil


TRLabelShape>>textWidth
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>basicEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		w: 	nil
		h: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape(TRShape)>>transformedEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		basicRectangle: 	nil
		rotatedRectangle: 	nil
		topLeft: 	nil
		topRight: 	nil
		bottomRight: 	nil
		bottomLeft: 	nil
		p1: 	nil
		p2: 	nil
		p3: 	nil
		p4: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>encompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


ByteSymbol(Symbol)>>value:
	Receiver: #encompassingRectangle
	Arguments and temporary variables: 
		anObject: 	a TRLabelShape
	Receiver's instance variables: 
#encompassingRectangle

OrderedCollection>>collect:
	Receiver: an OrderedCollection(a TREllipseShape a TRLabelShape)
	Arguments and temporary variables: 
		aBlock: 	#encompassingRectangle
		newCollection: 	an OrderedCollection((518.6125409942573@25.738035185121724) corn...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a TREllipseShape a TRLabelShape)
		firstIndex: 	1
		lastIndex: 	2


TRCompositeShape>>position
	Receiver: a TRCompositeShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	nil
		color: 	Color gray
		path: 	nil
		strokePaint: 	Color black
		announcer: 	nil
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		shapeAndOffsets: 	an OrderedCollection(an Array(a TREllipseShape (0@0)) an Array...etc...


RTElement>>position
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
		indexOfEdge: 	2
		multipleEdges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdg...etc...
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTLine(RTAbstractLine)>>updateFor:trachelShape:
	Receiver: a RTLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRLineShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	2
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint


RTArrowedLine>>updateFor:trachelShape:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRCompositeShape
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTArrowedLine(RTShape)>>updateFor:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edgeOrElement: 	a RTEdge
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdge(RTShapedObject)>>update
	Receiver: a RTEdge
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTArrowedLine
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		from: 	a RTElement
		to: 	a RTElement
		shouldBeUsedInLayout: 	true


[ :edge | edge update ] in RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 
		edge: 	a RTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :edge | edge update ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	45
		attributes: 	nil


RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement>>translateTo:
	Receiver: a RTElement
	Arguments and temporary variables: 
		newPosition: 	(610.6630846602945@43.123872958516564)
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	nil
		e: 	a RTEdge
		x: 	-0.7226431627162054
		len: 	-0.007941133656222038
		k: 	(167/182)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(519@26)
		y: 	-0.13499927215577465
		old: 	nil
		tp: 	(610@43)
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to posit...etc...
		index: 	139
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	483


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	-0.7226431627162054
		len: 	-0.007941133656222038
		k: 	(167/182)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(519@26)
		y: 	-0.13499927215577465
		old: 	nil
		tp: 	(610@43)
		quad: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in SmallInteger>>-


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in SmallInteger>>-


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in SmallInteger>>-


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(1168@140) a RTElement->(861@140) a RTE...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->0 a RTElement->0 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTView
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTView
		names: 	true



--- The full stack ---
SmallInteger>>-
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
TRLabelShape>>textWidth
TRLabelShape>>basicEncompassingRectangle
TRLabelShape(TRShape)>>transformedEncompassingRectangle
TRLabelShape>>encompassingRectangle
ByteSymbol(Symbol)>>value:
OrderedCollection>>collect:
TRCompositeShape>>position
RTElement>>position
RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
RTLine(RTAbstractLine)>>updateFor:trachelShape:
RTArrowedLine>>updateFor:trachelShape:
RTArrowedLine(RTShape)>>updateFor:
RTEdge(RTShapedObject)>>update
[ :edge | edge update ] in RTElement>>updateConnectedEdges
RTGroup(OrderedCollection)>>do:
RTElement>>updateConnectedEdges
RTElement>>translateTo:
[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
Graph>>addLayout:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Graph>>createGraph:withView:
Graph>>createGraph:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
5 December 2015 3:20:24.292051 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Dictionary>>at:ifAbsentPut:
	Receiver: a Dictionary($/->a Dictionary($a->#(5.600006103515625 5.600006103515625) $b->#(5.600006103...etc...
	Arguments and temporary variables: 
		key: 	$a
		aBlock: 	[ Dictionary new ]
	Receiver's instance variables: 
		tally: 	27
		array: 	an Array($/->a Dictionary($a->#(5.600006103515625 5.600006103515625) $b-...etc...


FreeTypeFont>>widthAndKernedWidthOfLeft:right:into:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		leftCharacter: 	$a
		rightCharacterOrNil: 	$n
		aTwoElementArray: 	#(13.264022827148438 13.264022827148438)
		privateArray: 	nil
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0xA1B4CF0>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	nil
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont>>widthOfString:from:to:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
		startIndex: 	1
		stopIndex: 	28
		char: 	$a
		nextChar: 	$n
		resultX: 	173.00831604003906
		glyph: 	nil
		a: 	#(13.264022827148438 13.264022827148438)
		subPixelPosition: 	nil
		i: 	23
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0xA1B4CF0>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	nil
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont(AbstractFont)>>widthOfString:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0xA1B4CF0>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	nil
		subPixelPositioned: 	true
		symbolFont: 	false


LogicalFont>>widthOfString:
	Receiver: a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
 realFont: FreeTy...etc...
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
	Receiver's instance variables: 
		realFont: 	FreeTypeFont('Source Sans Pro' 'Regular' 12)
		emphasis: 	nil
		familyName: 	'Source Sans Pro'
		fallbackFamilyNames: 	nil
		pointSize: 	12
		stretchValue: 	5
		weightValue: 	400
		slantValue: 	0
		derivatives: 	nil
		boldDerivative: 	nil
		italicDerivative: 	nil
		boldItalicDerivative: 	nil


TRLabelShape>>textWidth
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>basicEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		w: 	nil
		h: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape(TRShape)>>transformedEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		basicRectangle: 	nil
		rotatedRectangle: 	nil
		topLeft: 	nil
		topRight: 	nil
		bottomRight: 	nil
		bottomLeft: 	nil
		p1: 	nil
		p2: 	nil
		p3: 	nil
		p4: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>encompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


ByteSymbol(Symbol)>>value:
	Receiver: #encompassingRectangle
	Arguments and temporary variables: 
		anObject: 	a TRLabelShape
	Receiver's instance variables: 
#encompassingRectangle

OrderedCollection>>collect:
	Receiver: an OrderedCollection(a TREllipseShape a TRLabelShape)
	Arguments and temporary variables: 
		aBlock: 	#encompassingRectangle
		newCollection: 	an OrderedCollection((305.3738463967392@14.816067586364015) corn...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a TREllipseShape a TRLabelShape)
		firstIndex: 	1
		lastIndex: 	2


TRCompositeShape>>position
	Receiver: a TRCompositeShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	nil
		color: 	Color gray
		path: 	nil
		strokePaint: 	Color black
		announcer: 	nil
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		shapeAndOffsets: 	an OrderedCollection(an Array(a TREllipseShape (0@0)) an Array...etc...


RTElement>>position
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
		indexOfEdge: 	35
		multipleEdges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdg...etc...
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
	Receiver: a RTSimpleArrowHead
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRSimpleArrowShape
		f: 	(377.6707389086921@186.2638963759231)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	nil
		size: 	nil
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	nil
		baseSize: 	10


RTArrowedLine>>updateFor:trachelShape:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRCompositeShape
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTArrowedLine(RTShape)>>updateFor:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edgeOrElement: 	a RTEdge
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdge(RTShapedObject)>>update
	Receiver: a RTEdge
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTArrowedLine
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		from: 	a RTElement
		to: 	a RTElement
		shouldBeUsedInLayout: 	true


[ :edge | edge update ] in RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 
		edge: 	a RTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :edge | edge update ]
		index: 	51
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	65
		attributes: 	nil


RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement>>translateTo:
	Receiver: a RTElement
	Arguments and temporary variables: 
		newPosition: 	(465.9840971893235@53.586625243274796)
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	nil
		e: 	a RTEdge
		x: 	6.796409163359086
		len: 	0.040942223875657144
		k: 	(501/566)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(306@16)
		y: 	1.5967467311506287
		old: 	nil
		tp: 	(472@55)
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to posit...etc...
		index: 	37
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	474


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	6.796409163359086
		len: 	0.040942223875657144
		k: 	(501/566)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(306@16)
		y: 	1.5967467311506287
		old: 	nil
		tp: 	(472@55)
		quad: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true



--- The full stack ---
Dictionary>>at:ifAbsentPut:
FreeTypeFont>>widthAndKernedWidthOfLeft:right:into:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
TRLabelShape>>textWidth
TRLabelShape>>basicEncompassingRectangle
TRLabelShape(TRShape)>>transformedEncompassingRectangle
TRLabelShape>>encompassingRectangle
ByteSymbol(Symbol)>>value:
OrderedCollection>>collect:
TRCompositeShape>>position
RTElement>>position
RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
RTArrowedLine>>updateFor:trachelShape:
RTArrowedLine(RTShape)>>updateFor:
RTEdge(RTShapedObject)>>update
[ :edge | edge update ] in RTElement>>updateConnectedEdges
RTGroup(OrderedCollection)>>do:
RTElement>>updateConnectedEdges
RTElement>>translateTo:
[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Graph>>addLayout:
Graph>>createGraph:withView:
Graph>>createGraph:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Debug
5 December 2015 3:20:24.69605 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Dictionary>>at:ifAbsentPut:
	Receiver: a Dictionary($/->a Dictionary($a->#(5.600006103515625 5.600006103515625) $b->#(5.600006103...etc...
	Arguments and temporary variables: 
		key: 	$a
		aBlock: 	[ Dictionary new ]
	Receiver's instance variables: 
		tally: 	27
		array: 	an Array($/->a Dictionary($a->#(5.600006103515625 5.600006103515625) $b-...etc...


FreeTypeFont>>widthAndKernedWidthOfLeft:right:into:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		leftCharacter: 	$a
		rightCharacterOrNil: 	$n
		aTwoElementArray: 	#(13.264022827148438 13.264022827148438)
		privateArray: 	nil
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0xA1B4CF0>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	nil
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont>>widthOfString:from:to:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
		startIndex: 	1
		stopIndex: 	28
		char: 	$a
		nextChar: 	$n
		resultX: 	173.00831604003906
		glyph: 	nil
		a: 	#(13.264022827148438 13.264022827148438)
		subPixelPosition: 	nil
		i: 	23
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0xA1B4CF0>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	nil
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont(AbstractFont)>>widthOfString:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0xA1B4CF0>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	nil
		subPixelPositioned: 	true
		symbolFont: 	false


LogicalFont>>widthOfString:
	Receiver: a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
 realFont: FreeTy...etc...
	Arguments and temporary variables: 
		aString: 	'/mobile_base_nodelet_manager'
	Receiver's instance variables: 
		realFont: 	FreeTypeFont('Source Sans Pro' 'Regular' 12)
		emphasis: 	nil
		familyName: 	'Source Sans Pro'
		fallbackFamilyNames: 	nil
		pointSize: 	12
		stretchValue: 	5
		weightValue: 	400
		slantValue: 	0
		derivatives: 	nil
		boldDerivative: 	nil
		italicDerivative: 	nil
		boldItalicDerivative: 	nil


TRLabelShape>>textWidth
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>basicEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		w: 	nil
		h: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape(TRShape)>>transformedEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		basicRectangle: 	nil
		rotatedRectangle: 	nil
		topLeft: 	nil
		topRight: 	nil
		bottomRight: 	nil
		bottomLeft: 	nil
		p1: 	nil
		p2: 	nil
		p3: 	nil
		p4: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>encompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/mobile_base_nodelet_manager'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


ByteSymbol(Symbol)>>value:
	Receiver: #encompassingRectangle
	Arguments and temporary variables: 
		anObject: 	a TRLabelShape
	Receiver's instance variables: 
#encompassingRectangle

OrderedCollection>>collect:
	Receiver: an OrderedCollection(a TREllipseShape a TRLabelShape)
	Arguments and temporary variables: 
		aBlock: 	#encompassingRectangle
		newCollection: 	an OrderedCollection((305.3738463967392@14.816067586364015) corn...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a TREllipseShape a TRLabelShape)
		firstIndex: 	1
		lastIndex: 	2


TRCompositeShape>>position
	Receiver: a TRCompositeShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	nil
		color: 	Color gray
		path: 	nil
		strokePaint: 	Color black
		announcer: 	nil
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		shapeAndOffsets: 	an OrderedCollection(an Array(a TREllipseShape (0@0)) an Array...etc...


RTElement>>position
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
		indexOfEdge: 	35
		multipleEdges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdg...etc...
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
	Receiver: a RTSimpleArrowHead
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRSimpleArrowShape
		f: 	(377.6707389086921@186.2638963759231)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	nil
		size: 	nil
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	nil
		baseSize: 	10


RTArrowedLine>>updateFor:trachelShape:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRCompositeShape
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTArrowedLine(RTShape)>>updateFor:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edgeOrElement: 	a RTEdge
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdge(RTShapedObject)>>update
	Receiver: a RTEdge
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTArrowedLine
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		from: 	a RTElement
		to: 	a RTElement
		shouldBeUsedInLayout: 	true


[ :edge | edge update ] in RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 
		edge: 	a RTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :edge | edge update ]
		index: 	51
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	65
		attributes: 	nil


RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement>>translateTo:
	Receiver: a RTElement
	Arguments and temporary variables: 
		newPosition: 	(465.9840971893235@53.586625243274796)
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTView
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	nil
		e: 	a RTEdge
		x: 	6.796409163359086
		len: 	0.040942223875657144
		k: 	(501/566)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(306@16)
		y: 	1.5967467311506287
		old: 	nil
		tp: 	(472@55)
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to posit...etc...
		index: 	37
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	474


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	6.796409163359086
		len: 	0.040942223875657144
		k: 	(501/566)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(306@16)
		y: 	1.5967467311506287
		old: 	nil
		tp: 	(472@55)
		quad: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(287@36) a RTElement->(817@10) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->0 a RTElement->79 a RTElement->0 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.099
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true



--- The full stack ---
Dictionary>>at:ifAbsentPut:
FreeTypeFont>>widthAndKernedWidthOfLeft:right:into:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
TRLabelShape>>textWidth
TRLabelShape>>basicEncompassingRectangle
TRLabelShape(TRShape)>>transformedEncompassingRectangle
TRLabelShape>>encompassingRectangle
ByteSymbol(Symbol)>>value:
OrderedCollection>>collect:
TRCompositeShape>>position
RTElement>>position
RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
RTArrowedLine>>updateFor:trachelShape:
RTArrowedLine(RTShape)>>updateFor:
RTEdge(RTShapedObject)>>update
[ :edge | edge update ] in RTElement>>updateConnectedEdges
RTGroup(OrderedCollection)>>do:
RTElement>>updateConnectedEdges
RTElement>>translateTo:
[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Graph>>addLayout:
Graph>>createGraph:withView:
Graph>>createGraph:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
5 December 2015 3:23:08.29005 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Adapter>>createNode:
	Receiver: an Adapter
	Arguments and temporary variables: 
		aNodeName: 	'/app_manager'
		exist: 	an OrderedCollection()
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
nodes add: newNode ] in [ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
		expr: 	#('/gateway/force_update' #('/app_manager'))
		newTopic: 	a Topic
		newNode: 	nil
		aNode: 	'/app_manager'
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


Array(SequenceableCollection)>>do:
	Receiver: #('/app_manager')
	Arguments and temporary variables: 
		aBlock: 	[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
n...etc...
		index: 	1
	Receiver's instance variables: 
#('/app_manager')

[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
		newTopic: 	a Topic
		newNode: 	nil
		expr: 	#('/gateway/force_update' #('/app_manager'))
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


Array(SequenceableCollection)>>do:
	Receiver: #(#('/gateway/force_update' #('/app_manager')) #('/cmd_vel_mux/parameter_descriptions' #('...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [...etc...
		index: 	1
	Receiver's instance variables: 
#(#('/gateway/force_update' #('/app_manager')) #('/cmd_vel_mux/parameter_descriptions' #('...etc...

Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		newTopic: 	a Topic
		newNode: 	nil
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://l...etc...
		itsSelection: 	a Text for '"| proxy systemState |
proxy := XMLRPCProxy withUrl:'...etc...
		itsSelectionString: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	(0@0) corner: (442@259)
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(831520768))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(822083584))(a DropList...etc...
		lastStepTime: 	698667
		lastStepMessage: 	nil
		lastCycleTime: 	698667
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	698667
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a GL...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(822083584))(a DropList...etc...
		lastStepTime: 	698667
		lastStepMessage: 	nil
		lastCycleTime: 	698667
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	698667
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(822083584))(a DropList...etc...
		lastStepTime: 	698667
		lastStepMessage: 	nil
		lastCycleTime: 	698667
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	698667
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a GL...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Adapter>>createNode:
[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
nodes add: newNode ] in [ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
Array(SequenceableCollection)>>do:
[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
Array(SequenceableCollection)>>do:
Adapter>>getData
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
5 December 2015 3:23:22.078052 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Adapter>>createNode:
	Receiver: an Adapter
	Arguments and temporary variables: 
		aNodeName: 	'/mobile_base_nodelet_manager'
		exist: 	an OrderedCollection()
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic)
		nodes: 	an OrderedCollection(a Node)


[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
nodes add: newNode ] in [ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
		expr: 	#('/cmd_vel_mux/parameter_descriptions' #('/mobile_base_nodelet_manager')...etc...
		newTopic: 	a Topic
		newNode: 	a Node
		aNode: 	'/mobile_base_nodelet_manager'
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic)
		nodes: 	an OrderedCollection(a Node)


Array(SequenceableCollection)>>do:
	Receiver: #('/mobile_base_nodelet_manager')
	Arguments and temporary variables: 
		aBlock: 	[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
n...etc...
		index: 	1
	Receiver's instance variables: 
#('/mobile_base_nodelet_manager')

[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
		newTopic: 	a Topic
		newNode: 	a Node
		expr: 	#('/cmd_vel_mux/parameter_descriptions' #('/mobile_base_nodelet_manager')...etc...
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic)
		nodes: 	an OrderedCollection(a Node)


Array(SequenceableCollection)>>do:
	Receiver: #(#('/gateway/force_update' #('/app_manager')) #('/cmd_vel_mux/parameter_descriptions' #('...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [...etc...
		index: 	2
	Receiver's instance variables: 
#(#('/gateway/force_update' #('/app_manager')) #('/cmd_vel_mux/parameter_descriptions' #('...etc...

Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		newTopic: 	a Topic
		newNode: 	a Node
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic)
		nodes: 	an OrderedCollection(a Node)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://l...etc...
		itsSelection: 	a Text for '"| proxy systemState |
proxy := XMLRPCProxy withUrl:'...etc...
		itsSelectionString: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	(0@0) corner: (442@259)
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(831520768))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(192937984))(a SearchMorp...etc...
		lastStepTime: 	712410
		lastStepMessage: 	nil
		lastCycleTime: 	712430
		alarms: 	a Heap()
		lastAlarmTime: 	712410
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(559677440) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(192937984))(a SearchMorp...etc...
		lastStepTime: 	712410
		lastStepMessage: 	nil
		lastCycleTime: 	712430
		alarms: 	a Heap()
		lastAlarmTime: 	712410
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(192937984))(a SearchMorp...etc...
		lastStepTime: 	712410
		lastStepMessage: 	nil
		lastCycleTime: 	712430
		alarms: 	a Heap()
		lastAlarmTime: 	712410
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(559677440) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Adapter>>createNode:
[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
nodes add: newNode ] in [ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
Array(SequenceableCollection)>>do:
[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
Array(SequenceableCollection)>>do:
Adapter>>getData
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
5 December 2015 3:23:27.356056 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Adapter>>createNode:
	Receiver: an Adapter
	Arguments and temporary variables: 
		aNodeName: 	'/mobile_base_nodelet_manager'
		exist: 	an OrderedCollection(a Node)
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic a Topic)
		nodes: 	an OrderedCollection(a Node a Node)


[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
nodes add: newNode ] in [ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
		expr: 	#('/mobile_base/events/robot_state' #('/mobile_base_nodelet_manager'))
		newTopic: 	a Topic
		newNode: 	a Node
		aNode: 	'/mobile_base_nodelet_manager'
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic a Topic)
		nodes: 	an OrderedCollection(a Node a Node)


Array(SequenceableCollection)>>do:
	Receiver: #('/mobile_base_nodelet_manager')
	Arguments and temporary variables: 
		aBlock: 	[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
n...etc...
		index: 	1
	Receiver's instance variables: 
#('/mobile_base_nodelet_manager')

[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
		newTopic: 	a Topic
		newNode: 	a Node
		expr: 	#('/mobile_base/events/robot_state' #('/mobile_base_nodelet_manager'))
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic a Topic)
		nodes: 	an OrderedCollection(a Node a Node)


Array(SequenceableCollection)>>do:
	Receiver: #(#('/gateway/force_update' #('/app_manager')) #('/cmd_vel_mux/parameter_descriptions' #('...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [...etc...
		index: 	3
	Receiver's instance variables: 
#(#('/gateway/force_update' #('/app_manager')) #('/cmd_vel_mux/parameter_descriptions' #('...etc...

Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		newTopic: 	a Topic
		newNode: 	a Node
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic a Topic)
		nodes: 	an OrderedCollection(a Node a Node)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://l...etc...
		itsSelection: 	a Text for '"| proxy systemState |
proxy := XMLRPCProxy withUrl:'...etc...
		itsSelectionString: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	(0@0) corner: (442@259)
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(831520768))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(984875008))(a Spec...etc...
		lastStepTime: 	717668
		lastStepMessage: 	nil
		lastCycleTime: 	717688
		alarms: 	a Heap()
		lastAlarmTime: 	717668
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(792985600) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(984875008))(a Spec...etc...
		lastStepTime: 	717668
		lastStepMessage: 	nil
		lastCycleTime: 	717688
		alarms: 	a Heap()
		lastAlarmTime: 	717668
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(984875008))(a Spec...etc...
		lastStepTime: 	717668
		lastStepMessage: 	nil
		lastCycleTime: 	717688
		alarms: 	a Heap()
		lastAlarmTime: 	717668
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(792985600) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Adapter>>createNode:
[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic.
nodes add: newNode ] in [ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
Array(SequenceableCollection)>>do:
[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic.
		nodes add: newNode ].
topics add: newTopic ] in Adapter>>getData
Array(SequenceableCollection)>>do:
Adapter>>getData
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
5 December 2015 3:27:50.188052 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Adapter>>createNode:
	Receiver: an Adapter
	Arguments and temporary variables: 
		newNode: 	nil
		aNodeName: 	'/app_manager'
		exist: 	an OrderedCollection()
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic)
		nodes: 	an OrderedCollection()


[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic ] in [ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic ] ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
		expr: 	#('/gateway/force_update' #('/app_manager'))
		newTopic: 	a Topic
		newNode: 	nil
		aNode: 	'/app_manager'
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic)
		nodes: 	an OrderedCollection()


Array(SequenceableCollection)>>do:
	Receiver: #('/app_manager')
	Arguments and temporary variables: 
		aBlock: 	[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic ]
		index: 	1
	Receiver's instance variables: 
#('/app_manager')

[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic ] ] in Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
		newTopic: 	a Topic
		newNode: 	nil
		expr: 	#('/gateway/force_update' #('/app_manager'))
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic)
		nodes: 	an OrderedCollection()


Array(SequenceableCollection)>>do:
	Receiver: #(#('/gateway/force_update' #('/app_manager')) #('/cmd_vel_mux/parameter_descriptions' #('...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [...etc...
		index: 	1
	Receiver's instance variables: 
#(#('/gateway/force_update' #('/app_manager')) #('/cmd_vel_mux/parameter_descriptions' #('...etc...

Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 
		newTopic: 	a Topic
		newNode: 	nil
		proxy: 	a XMLRPCProxy
		systemState: 	#(1 'current system state' #(#(#('/gateway/force_update' #('/app_m...etc...
	Receiver's instance variables: 
		topics: 	an OrderedCollection(a Topic)
		nodes: 	an OrderedCollection()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://l...etc...
		itsSelection: 	a Text for '"| proxy systemState |
proxy := XMLRPCProxy withUrl:'...etc...
		itsSelectionString: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(106692608))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(841744384))(a SearchMorp...etc...
		lastStepTime: 	980458
		lastStepMessage: 	nil
		lastCycleTime: 	980478
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	980458
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(841744384))(a SearchMorp...etc...
		lastStepTime: 	980458
		lastStepMessage: 	nil
		lastCycleTime: 	980478
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	980458
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(841744384))(a SearchMorp...etc...
		lastStepTime: 	980458
		lastStepMessage: 	nil
		lastCycleTime: 	980478
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	980458
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Adapter>>createNode:
[ :aNode | 
newNode := self createNode: aNode.
newNode pub: newTopic ] in [ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic ] ] in Adapter>>getData
Array(SequenceableCollection)>>do:
[ :expr | 
newTopic := self createTopic: expr first.
expr second
	do: [ :aNode | 
		newNode := self createNode: aNode.
		newNode pub: newTopic ] ] in Adapter>>getData
Array(SequenceableCollection)>>do:
Adapter>>getData
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
5 December 2015 3:29:27.83605 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SortedCollection(Object)>>errorSubscriptBounds:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>at:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(SequenceableCollection)>>first
	Receiver: a SortedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


RTSugiyamaLayout>>assignLabels:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
		label: 	4
		vertices: 	a SortedCollection()
		parentLabels: 	a SortedCollection(10000000000)
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->2 a RTElement->3 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout>>doExecute:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->2 a RTElement->3 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->2 a RTElement->3 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->2 a RTElement->3 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTForceBasedLayout>>initialPositionOfNodes:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(59@233) a RTElement->(178@232) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->9 a RTElement->9 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>start:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(59@233) a RTElement->(178@232) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->9 a RTElement->9 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTSpringLayoutStepping>>prepareLayoutFor:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aView: 	a RTView
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTView
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


RTSpringLayoutStepping>>layout:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aForceBasedLayout: 	a RTForceBasedLayout
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTView
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTView
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTView
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTView
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTView
		names: 	true


Graph>>createGraph:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTView
		names: 	true


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http://l...etc...
		itsSelection: 	a Text for '"| proxy systemState |
proxy := XMLRPCProxy withUrl:'...etc...
		itsSelectionString: 	'"| proxy systemState |
proxy := XMLRPCProxy withUrl:''http...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(21495808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(21495808)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (442@259)
		owner: 	a TransformWithLayoutMorph(463208448)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1003487232) a RubCursor(42572185...etc...
		fullBounds: 	(0@0) corner: (442@259)
		color: 	Color transparent
		extension: 	a MorphExtension (487587840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(424935424)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(425721856)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(651689984))
		getMenuPolicy: 	a RubEditingArea(21495808)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(341311488)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(822083584))(a DropList...etc...
		lastStepTime: 	1019326
		lastStepMessage: 	nil
		lastCycleTime: 	1019346
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	1019326
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(822083584))(a DropList...etc...
		lastStepTime: 	1019326
		lastStepMessage: 	nil
		lastCycleTime: 	1019346
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	1019326
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(822083584))(a DropList...etc...
		lastStepTime: 	1019326
		lastStepMessage: 	nil
		lastCycleTime: 	1019346
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(425721856)))
		lastAlarmTime: 	1019326
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(492568576) a Na...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SortedCollection(Object)>>errorSubscriptBounds:
SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
SortedCollection(OrderedCollection)>>at:
SortedCollection(SequenceableCollection)>>first
RTSugiyamaLayout>>assignLabels:
RTSugiyamaLayout>>doExecute:
RTSugiyamaLayout(RTLayout)>>executeOnElements:
RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout>>initialPositionOfNodes:
RTForceBasedLayout>>start:
RTSpringLayoutStepping>>prepareLayoutFor:
RTSpringLayoutStepping>>layout:
Graph>>addLayout:
Graph>>createGraph:withView:
Graph>>createGraph:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
7 December 2015 4:27:24.957184 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SortedCollection(Object)>>errorSubscriptBounds:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>at:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(SequenceableCollection)>>first
	Receiver: a SortedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


RTSugiyamaLayout>>assignLabels:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
		label: 	4
		vertices: 	a SortedCollection()
		parentLabels: 	a SortedCollection(1 2 3 10000000000 10000000000 10000000000 1000...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->2 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout>>doExecute:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->2 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->2 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->2 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTForceBasedLayout>>initialPositionOfNodes:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(118@286) a RTElement->(180@82) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->9 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>start:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(118@286) a RTElement->(180@82) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->9 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTSpringLayoutStepping>>prepareLayoutFor:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


RTSpringLayoutStepping>>layout:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aForceBasedLayout: 	a RTForceBasedLayout
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(407633920)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(407633920)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
SortedCollection(Object)>>errorSubscriptBounds:
SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
SortedCollection(OrderedCollection)>>at:
SortedCollection(SequenceableCollection)>>first
RTSugiyamaLayout>>assignLabels:
RTSugiyamaLayout>>doExecute:
RTSugiyamaLayout(RTLayout)>>executeOnElements:
RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout>>initialPositionOfNodes:
RTForceBasedLayout>>start:
RTSpringLayoutStepping>>prepareLayoutFor:
RTSpringLayoutStepping>>layout:
Graph>>addLayout:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
7 December 2015 4:32:56.673183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SortedCollection(Object)>>errorSubscriptBounds:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>at:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(SequenceableCollection)>>first
	Receiver: a SortedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


RTSugiyamaLayout>>assignLabels:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
		label: 	4
		vertices: 	a SortedCollection()
		parentLabels: 	a SortedCollection(1 2 3 10000000000 10000000000 10000000000 1000...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->2 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout>>doExecute:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->2 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->2 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->2 a RTElement->1 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTForceBasedLayout>>initialPositionOfNodes:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(183@300) a RTElement->(283@228) a RTEl...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->6 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>start:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(183@300) a RTElement->(283@228) a RTEl...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->6 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTSpringLayoutStepping>>prepareLayoutFor:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


RTSpringLayoutStepping>>layout:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aForceBasedLayout: 	a RTForceBasedLayout
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(436994048)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(436994048)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
SortedCollection(Object)>>errorSubscriptBounds:
SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
SortedCollection(OrderedCollection)>>at:
SortedCollection(SequenceableCollection)>>first
RTSugiyamaLayout>>assignLabels:
RTSugiyamaLayout>>doExecute:
RTSugiyamaLayout(RTLayout)>>executeOnElements:
RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout>>initialPositionOfNodes:
RTForceBasedLayout>>start:
RTSpringLayoutStepping>>prepareLayoutFor:
RTSpringLayoutStepping>>layout:
Graph>>addLayout:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
7 December 2015 4:35:05.561183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SortedCollection(Object)>>errorSubscriptBounds:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>at:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(SequenceableCollection)>>first
	Receiver: a SortedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


RTSugiyamaLayout>>assignLabels:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
		label: 	4
		vertices: 	a SortedCollection()
		parentLabels: 	a SortedCollection(1 2 3 10000000000 10000000000 10000000000 1000...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->1 a RTElement->2 a RTElement->3 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout>>doExecute:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->1 a RTElement->2 a RTElement->3 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->1 a RTElement->2 a RTElement->3 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->1 a RTElement->2 a RTElement->3 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTForceBasedLayout>>initialPositionOfNodes:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(33@184) a RTElement->(172@186) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->9 a RTElement->12 a RTElement->2 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>start:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(33@184) a RTElement->(172@186) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->9 a RTElement->12 a RTElement->2 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTSpringLayoutStepping>>prepareLayoutFor:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


RTSpringLayoutStepping>>layout:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aForceBasedLayout: 	a RTForceBasedLayout
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	204
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(540803072)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(540803072)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
SortedCollection(Object)>>errorSubscriptBounds:
SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
SortedCollection(OrderedCollection)>>at:
SortedCollection(SequenceableCollection)>>first
RTSugiyamaLayout>>assignLabels:
RTSugiyamaLayout>>doExecute:
RTSugiyamaLayout(RTLayout)>>executeOnElements:
RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout>>initialPositionOfNodes:
RTForceBasedLayout>>start:
RTSpringLayoutStepping>>prepareLayoutFor:
RTSpringLayoutStepping>>layout:
Graph>>addLayout:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
CompiledMethod>>valueWithReceiver:arguments:
[ v := compiledMethod valueWithReceiver: receiver arguments: #() ] in RubSmalltalkEditor>>tally:
BlockClosure>>ensure:
MessageTally>>spyEvery:on:
TimeProfiler>>runBlock:pollingEvery:
TimeProfiler>>openOnBlock:
TimeProfiler class>>spyOn:
RubSmalltalkEditor>>tally:
RubSmalltalkEditor>>tallyHighlight
GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>profileHighlightedText
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
GLMPharoPlaygroundPresentation(Announcer)>>announce:
GLMPharoPlaygroundPresentation(GLMAnnouncer)>>announce:
GLMPharoPlaygroundPresentation(GLMLoggedObject)>>announce:
GLMPharoPlaygroundPresentation(GLMRubricSmalltalkCodePresentation)>>profileSelection
[ :aPresentation | aPresentation profileSelection ] in GLMPharoPlaygroundPresentation(GLMRubricSmalltalkCodePresentation)>>executionSelectionActions
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
[ :ann | ann action morphicActOn: aPresentation ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicWidgetRenderer)>>installActionsOnModel:fromPresentation:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
GLMRubricSmalltalkTextModel(Announcer)>>announce:
GLMRubricSmalltalkTextModel(GLMMorphicModel)>>executeMenuAction:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
[ :menu | 
menu setInvokingView: self editor.
menu invokeModal.
self changed.
^ true ] in RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
MenuMorph(Object)>>ifNotNilDo:
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RQTGMainWindow class>>instantiate:
7 December 2015 4:40:16.049183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RQTGMainWindow class(Object)>>doesNotUnderstand: #instantiate:
	Receiver: RQTGMainWindow
	Arguments and temporary variables: 
		aMessage: 	instantiate: RoassalModel
		exception: 	MessageNotUnderstood: RQTGMainWindow class>>instantiate:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	ComposableModel
		methodDict: 	a MethodDictionary(#data->RQTGMainWindow>>#data #data:->RQTGMainWin...etc...
		format: 	174
		layout: 	a FixedLayout
		instanceVariables: 	#(#showName #hideNodes #hideTopics #graph #data #hide #graph...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RQTGMainWindow
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


RQTGMainWindow class>>DoIt
	Receiver: RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ComposableModel
		methodDict: 	a MethodDictionary(#data->RQTGMainWindow>>#data #data:->RQTGMainWin...etc...
		format: 	174
		layout: 	a FixedLayout
		instanceVariables: 	#(#showName #hideNodes #hideTopics #graph #data #hide #graph...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RQTGMainWindow
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self instantiate: RoassalModel'
		itsSelection: 	a Text for 'self instantiate: RoassalModel'
		itsSelectionString: 	'self instantiate: RoassalModel'
	Receiver's instance variables: 
		ast: 	DoIt
	^ self instantiate: RoassalModel
		source: 	a ReadStream
		context: 	nil
		receiver: 	RQTGMainWindow
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	RQTGMainWindow
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(131596288)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>inspectIt
	Receiver: a PluggableTextMorphWithLimits(760217600)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(142.0@558.0) corner: (958.0@973.0)
		owner: 	a MultipleMethodsEditor(442236928)
		submorphs: 	an Array(an AlphaImageMorph(39059456) a TransformMorph(740032512))
		fullBounds: 	(142@558) corner: (958@973)
		color: 	Color white
		extension: 	a MorphExtension (998244352) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(808976384)
		scroller: 	a TransformMorph(740032512)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(252444672)
		textMorph: 	a TextMorphForEditView(131596288)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(92 to: 121)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(39059456)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(760217600)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(142.0@558.0) corner: (958.0@973.0)
		owner: 	a MultipleMethodsEditor(442236928)
		submorphs: 	an Array(an AlphaImageMorph(39059456) a TransformMorph(740032512))
		fullBounds: 	(142@558) corner: (958@973)
		color: 	Color white
		extension: 	a MorphExtension (998244352) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(808976384)
		scroller: 	a TransformMorph(740032512)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(252444672)
		textMorph: 	a TextMorphForEditView(131596288)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(92 to: 121)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(39059456)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@249)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@249)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'initializeWidgets
	
	self initializeButtons.
	
	data := Order...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(760217600)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(142.0@558.0) corner: (958.0@973.0)
		owner: 	a MultipleMethodsEditor(442236928)
		submorphs: 	an Array(an AlphaImageMorph(39059456) a TransformMorph(740032512))
		fullBounds: 	(142@558) corner: (958@973)
		color: 	Color white
		extension: 	a MorphExtension (998244352) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(808976384)
		scroller: 	a TransformMorph(740032512)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(252444672)
		textMorph: 	a TextMorphForEditView(131596288)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(92 to: 121)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(39059456)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>inspectIt
	Receiver: a PluggableTextMorphWithLimits(760217600)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(142.0@558.0) corner: (958.0@973.0)
		owner: 	a MultipleMethodsEditor(442236928)
		submorphs: 	an Array(an AlphaImageMorph(39059456) a TransformMorph(740032512))
		fullBounds: 	(142@558) corner: (958@973)
		color: 	Color white
		extension: 	a MorphExtension (998244352) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		scrollBar: 	a ScrollBar(808976384)
		scroller: 	a TransformMorph(740032512)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(252444672)
		textMorph: 	a TextMorphForEditView(131596288)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(92 to: 121)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(39059456)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorphWithLimits(760217600)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorphWithLimits(760217600)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	138
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorphWithLimits(760217600)
		secondArg: 	a PluggableTextMorphWithLimits(760217600)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	138
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorphWithLimits(760217600)
		secondArg: 	a PluggableTextMorphWithLimits(760217600)
		thirdArg: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	138
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorphWithLimits(760217600)
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(760217600)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Ctrl + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Ctrl + I
		defaultShortcut: 	Ctrl + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Ctrl + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Ctrl + I
		defaultShortcut: 	Ctrl + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Ctrl + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Ctrl + I
		defaultShortcut: 	Ctrl + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]
 #doIt on Ctrl + D do [ :morp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	1
		each: 	#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#inspectIt on Ctrl + I do [ :morph | morph inspectIt ]
 nil nil...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorphWithLimits(760217600)
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(760217600)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextEditor) aKMCategoryTarget(#ScrollPane) aK...etc...
		morph: 	a PluggableTextMorphWithLimits(760217600)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextEditor) aKMCategoryTarg...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextEditor) aKMCatego...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextEditor) aKMCategoryTarget(#ScrollPane) aK...etc...
		morph: 	a PluggableTextMorphWithLimits(760217600)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(760217600)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(131596288)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@249)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@249)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'initializeWidgets
	
	self initializeButtons.
	
	data := Order...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@249)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@249)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'initializeWidgets
	
	self initializeButtons.
	
	data := Order...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(131596288)
	Receiver's instance variables: 
		timeStamp: 	1019286
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(330.0@128.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	9
		charCode: 	105
		scanCode: 	9


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@249)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@249)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'initializeWidgets
	
	self initializeButtons.
	
	data := Order...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@249)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@249)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'initializeWidgets
	
	self initializeButtons.
	
	data := Order...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-i>']
		focusHolder: 	a TextMorphForEditView(131596288)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(468@678.0) corner: (484@694.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(468@678.0) corner: (484@694.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(131596288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(476@687) mouseOver nil nil]
		targetOffset: 	(91.0@127.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1018478 476 687 0 0 0 1)
		lastKeyScanCode: 	9
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(628621312) a Nau...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-i>']
		focusHolder: 	a TextMorphForEditView(131596288)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(468@678.0) corner: (484@694.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(468@678.0) corner: (484@694.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(131596288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(476@687) mouseOver nil nil]
		targetOffset: 	(91.0@127.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1018478 476 687 0 0 0 1)
		lastKeyScanCode: 	9
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
RQTGMainWindow class(Object)>>doesNotUnderstand: #instantiate:
RQTGMainWindow class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>inspectIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
7 December 2015 4:44:32.709183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SortedCollection(Object)>>errorSubscriptBounds:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>at:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(SequenceableCollection)>>first
	Receiver: a SortedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


RTSugiyamaLayout>>assignLabels:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
		label: 	4
		vertices: 	a SortedCollection()
		parentLabels: 	a SortedCollection(1 2 3 10000000000 10000000000 10000000000 1000...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection() a RTEl...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->1 a RTElement->2 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout>>doExecute:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection() a RTEl...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->1 a RTElement->2 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection() a RTEl...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->1 a RTElement->2 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection() a RTEl...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->1 a RTElement->2 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTForceBasedLayout>>initialPositionOfNodes:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(33@184) a RTElement->(265@125) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->9 a RTElement->7 a RTElement->9 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>start:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(33@184) a RTElement->(265@125) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->9 a RTElement->7 a RTElement->9 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTSpringLayoutStepping>>prepareLayoutFor:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


RTSpringLayoutStepping>>layout:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aForceBasedLayout: 	a RTForceBasedLayout
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(1016856576)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(1016856576)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
SortedCollection(Object)>>errorSubscriptBounds:
SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
SortedCollection(OrderedCollection)>>at:
SortedCollection(SequenceableCollection)>>first
RTSugiyamaLayout>>assignLabels:
RTSugiyamaLayout>>doExecute:
RTSugiyamaLayout(RTLayout)>>executeOnElements:
RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout>>initialPositionOfNodes:
RTForceBasedLayout>>start:
RTSpringLayoutStepping>>prepareLayoutFor:
RTSpringLayoutStepping>>layout:
Graph>>addLayout:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
7 December 2015 4:45:58.083183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SortedCollection(Object)>>errorSubscriptBounds:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(OrderedCollection)>>at:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


SortedCollection(SequenceableCollection)>>first
	Receiver: a SortedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	a RTSortBlock


RTSugiyamaLayout>>assignLabels:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
		label: 	4
		vertices: 	a SortedCollection()
		parentLabels: 	a SortedCollection(1 2 3 10000000000 10000000000 10000000000 1000...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->1 a RTElement->2 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout>>doExecute:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		aNodeCollection: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTE...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->1 a RTElement->2 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->1 a RTElement->2 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTSugiyamaLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		verticalGap: 	nil
		horizontalGap: 	nil
		cachedChildren: 	nil
		cachedParents: 	an IdentityDictionary(a RTElement->an OrderedCollection(a RTElem...etc...
		cachedParentsWithHighestNestings: 	nil
		sortBlock: 	a RTSortBlock
		labels: 	an IdentityDictionary(a RTElement->3 a RTElement->1 a RTElement->2 )
		layers: 	nil
		layerNrs: 	nil
		connections: 	nil


RTForceBasedLayout>>initialPositionOfNodes:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(265@125) a RTElement->(98@218) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->9 a RTElement->9 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>start:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTEle...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(265@125) a RTElement->(98@218) a RTEle...etc...
		nodes: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->9 a RTElement->9 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTSugiyamaLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTSpringLayoutStepping>>prepareLayoutFor:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


RTSpringLayoutStepping>>layout:
	Receiver: a RTSpringLayoutStepping
	Arguments and temporary variables: 
		aForceBasedLayout: 	a RTForceBasedLayout
	Receiver's instance variables: 
		cycleLength: 	nil
		element: 	nil
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		afterBlock: 	[  ]


Graph>>addLayout:
	Receiver: a Graph
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(27525120)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(27525120)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
SortedCollection(Object)>>errorSubscriptBounds:
SortedCollection(OrderedCollection)>>ensureBoundsFrom:to:
SortedCollection(OrderedCollection)>>at:
SortedCollection(SequenceableCollection)>>first
RTSugiyamaLayout>>assignLabels:
RTSugiyamaLayout>>doExecute:
RTSugiyamaLayout(RTLayout)>>executeOnElements:
RTSugiyamaLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout>>initialPositionOfNodes:
RTForceBasedLayout>>start:
RTSpringLayoutStepping>>prepareLayoutFor:
RTSpringLayoutStepping>>layout:
Graph>>addLayout:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
CompiledMethod>>valueWithReceiver:arguments:
[ v := compiledMethod valueWithReceiver: receiver arguments: #() ] in RubSmalltalkEditor>>tally:
BlockClosure>>ensure:
MessageTally>>spyEvery:on:
TimeProfiler>>runBlock:pollingEvery:
TimeProfiler>>openOnBlock:
TimeProfiler class>>spyOn:
RubSmalltalkEditor>>tally:
RubSmalltalkEditor>>tallyHighlight
GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>profileHighlightedText
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
GLMPharoPlaygroundPresentation(Announcer)>>announce:
GLMPharoPlaygroundPresentation(GLMAnnouncer)>>announce:
GLMPharoPlaygroundPresentation(GLMLoggedObject)>>announce:
GLMPharoPlaygroundPresentation(GLMRubricSmalltalkCodePresentation)>>profileSelection
[ :aPresentation | aPresentation profileSelection ] in GLMPharoPlaygroundPresentation(GLMRubricSmalltalkCodePresentation)>>executionSelectionActions
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
[ :ann | ann action morphicActOn: aPresentation ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicWidgetRenderer)>>installActionsOnModel:fromPresentation:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
GLMRubricSmalltalkTextModel(Announcer)>>announce:
GLMRubricSmalltalkTextModel(GLMMorphicModel)>>executeMenuAction:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
[ :menu | 
menu setInvokingView: self editor.
menu invokeModal.
self changed.
^ true ] in RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
MenuMorph(Object)>>ifNotNilDo:
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Graph>>addInteractionsToNodes
7 December 2015 4:57:10.129183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Graph(Object)>>doesNotUnderstand: #addInteractionsToNodes
	Receiver: a Graph
	Arguments and temporary variables: 
		aMessage: 	addInteractionsToNodes
		exception: 	MessageNotUnderstood: Graph>>addInteractionsToNodes
		resumeValue: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(347602944)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(347602944)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #showN...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
Graph(Object)>>doesNotUnderstand: #addInteractionsToNodes
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
7 December 2015 5:28:45.889183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Dictionary>>at:ifAbsentPut:
	Receiver: a Dictionary($_->#(8.880020141601563 8.880020141601563) $a->#(8.880020141601563 8.88002014...etc...
	Arguments and temporary variables: 
		key: 	$e
		aBlock: 	[ super widthAndKernedWidthOfLeft: leftCharacter right: rightCharacterO...etc...
	Receiver's instance variables: 
		tally: 	6
		array: 	{nil. $o->#(8.880020141601563 8.880020141601563). $e->#(8.88002014160156...etc...


FreeTypeFont>>widthAndKernedWidthOfLeft:right:into:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		leftCharacter: 	$p
		rightCharacterOrNil: 	$e
		aTwoElementArray: 	#(13.264022827148438 13.264022827148438)
		privateArray: 	nil
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0x8A608D8>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	5
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont>>widthOfString:from:to:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/bumper2pointcloud'
		startIndex: 	1
		stopIndex: 	18
		char: 	$p
		nextChar: 	$e
		resultX: 	36.44807434082031
		glyph: 	nil
		a: 	#(13.264022827148438 13.264022827148438)
		subPixelPosition: 	nil
		i: 	5
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0x8A608D8>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	5
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont(AbstractFont)>>widthOfString:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/bumper2pointcloud'
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0x8A608D8>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	5
		subPixelPositioned: 	true
		symbolFont: 	false


LogicalFont>>widthOfString:
	Receiver: a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
 realFont: FreeTy...etc...
	Arguments and temporary variables: 
		aString: 	'/bumper2pointcloud'
	Receiver's instance variables: 
		realFont: 	FreeTypeFont('Source Sans Pro' 'Regular' 12)
		emphasis: 	nil
		familyName: 	'Source Sans Pro'
		fallbackFamilyNames: 	nil
		pointSize: 	12
		stretchValue: 	5
		weightValue: 	400
		slantValue: 	0
		derivatives: 	nil
		boldDerivative: 	nil
		italicDerivative: 	nil
		boldItalicDerivative: 	nil


TRLabelShape>>textWidth
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/bumper2pointcloud'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>basicEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		w: 	nil
		h: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/bumper2pointcloud'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape(TRShape)>>transformedEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		basicRectangle: 	nil
		rotatedRectangle: 	nil
		topLeft: 	nil
		topRight: 	nil
		bottomRight: 	nil
		bottomLeft: 	nil
		p1: 	nil
		p2: 	nil
		p3: 	nil
		p4: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/bumper2pointcloud'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>encompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/bumper2pointcloud'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


ByteSymbol(Symbol)>>value:
	Receiver: #encompassingRectangle
	Arguments and temporary variables: 
		anObject: 	a TRLabelShape
	Receiver's instance variables: 
#encompassingRectangle

OrderedCollection>>collect:
	Receiver: an OrderedCollection(a TREllipseShape a TRLabelShape)
	Arguments and temporary variables: 
		aBlock: 	#encompassingRectangle
		newCollection: 	an OrderedCollection((155.21591473331654@86.99719066776521) corn...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a TREllipseShape a TRLabelShape)
		firstIndex: 	1
		lastIndex: 	2


TRCompositeShape>>position
	Receiver: a TRCompositeShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	nil
		color: 	Color gray
		path: 	nil
		strokePaint: 	Color black
		announcer: 	nil
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		shapeAndOffsets: 	an OrderedCollection(an Array(a TREllipseShape (0@0)) an Array...etc...


RTElement>>position
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	nil
		x: 	0.766480194626108
		len: 	-0.00923470114007359
		k: 	(1/2)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(205@136)
		y: 	-0.2862757353422813
		old: 	nil
		tp: 	(121@168)
		e: 	a RTEdge
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to posit...etc...
		index: 	37
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	38


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	0.766480194626108
		len: 	-0.00923470114007359
		k: 	(1/2)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(205@136)
		y: 	-0.2862757353422813
		old: 	nil
		tp: 	(121@168)
		quad: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9275019664042147
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9275019664042147
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9275019664042147
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Dictionary>>at:ifAbsentPut:


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(199@67) a RTElement->(263@283) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->15 a RTElement->1 a RTElement->9 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07177305325982747
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(482344960)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(482344960)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
Dictionary>>at:ifAbsentPut:
FreeTypeFont>>widthAndKernedWidthOfLeft:right:into:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
TRLabelShape>>textWidth
TRLabelShape>>basicEncompassingRectangle
TRLabelShape(TRShape)>>transformedEncompassingRectangle
TRLabelShape>>encompassingRectangle
ByteSymbol(Symbol)>>value:
OrderedCollection>>collect:
TRCompositeShape>>position
RTElement>>position
[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTCenteredAttachPoint>>edgeFrom:to:
7 December 2015 5:33:18.453184 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTCenteredAttachPoint(Object)>>doesNotUnderstand: #edgeFrom:to:
	Receiver: a RTCenteredAttachPoint
	Arguments and temporary variables: 
		aMessage: 	edgeFrom: a RTElement to: a RTElement
		exception: 	MessageNotUnderstood: RTCenteredAttachPoint>>edgeFrom:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		inverted: 	false


RTEdgeBuilder(RTBuilder)>>edgeFrom:to:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		source: 	a RTElement
		target: 	a RTElement
		newEdge: 	nil
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTEdgeBuilder>>edgeFrom:to:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		source: 	a RTElement
		target: 	a RTElement
		edge: 	nil
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


[ :toE | edges add: (self edgeFrom: fromElement to: toE) ] in [ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
		e: 	a RTElement
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		toE: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :toE | edges add: (self edgeFrom: fromElement to: toE) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
		e: 	a RTElement
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	13
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>connectNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(869269504)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(869269504)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
RTCenteredAttachPoint(Object)>>doesNotUnderstand: #edgeFrom:to:
RTEdgeBuilder(RTBuilder)>>edgeFrom:to:
RTEdgeBuilder>>edgeFrom:to:
[ :toE | edges add: (self edgeFrom: fromElement to: toE) ] in [ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>connectNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTCenteredAttachPoint>>edgeFrom:to:
7 December 2015 5:34:23.051183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTCenteredAttachPoint(Object)>>doesNotUnderstand: #edgeFrom:to:
	Receiver: a RTCenteredAttachPoint
	Arguments and temporary variables: 
		aMessage: 	edgeFrom: a RTElement to: a RTElement
		exception: 	MessageNotUnderstood: RTCenteredAttachPoint>>edgeFrom:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		inverted: 	false


RTEdgeBuilder(RTBuilder)>>edgeFrom:to:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		source: 	a RTElement
		target: 	a RTElement
		newEdge: 	nil
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTEdgeBuilder>>edgeFrom:to:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		source: 	a RTElement
		target: 	a RTElement
		edge: 	nil
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


[ :toE | edges add: (self edgeFrom: fromElement to: toE) ] in [ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
		e: 	a RTElement
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		toE: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :toE | edges add: (self edgeFrom: fromElement to: toE) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
		e: 	a RTElement
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	13
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTCenteredAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>connectNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(527433728)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(527433728)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
RTCenteredAttachPoint(Object)>>doesNotUnderstand: #edgeFrom:to:
RTEdgeBuilder(RTBuilder)>>edgeFrom:to:
RTEdgeBuilder>>edgeFrom:to:
[ :toE | edges add: (self edgeFrom: fromElement to: toE) ] in [ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>connectNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTShorterDistanceAttachPoint>>edgeFrom:to:
7 December 2015 5:35:00.947183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTShorterDistanceAttachPoint(Object)>>doesNotUnderstand: #edgeFrom:to:
	Receiver: a RTShorterDistanceAttachPoint
	Arguments and temporary variables: 
		aMessage: 	edgeFrom: a RTElement to: a RTElement
		exception: 	MessageNotUnderstood: RTShorterDistanceAttachPoint>>edgeFrom:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		inverted: 	false


RTEdgeBuilder(RTBuilder)>>edgeFrom:to:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		source: 	a RTElement
		target: 	a RTElement
		newEdge: 	nil
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTShorterDistanceAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTEdgeBuilder>>edgeFrom:to:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		source: 	a RTElement
		target: 	a RTElement
		edge: 	nil
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTShorterDistanceAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


[ :toE | edges add: (self edgeFrom: fromElement to: toE) ] in [ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
		e: 	a RTElement
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		toE: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTShorterDistanceAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :toE | edges add: (self edgeFrom: fromElement to: toE) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
		e: 	a RTElement
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTShorterDistanceAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	13
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self getSub: sub ]
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RTShorterDistanceAttachPoint
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	false
		shouldNotBeUsedInLayout: 	true


Graph>>connectNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(537919488)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(537919488)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
RTShorterDistanceAttachPoint(Object)>>doesNotUnderstand: #edgeFrom:to:
RTEdgeBuilder(RTBuilder)>>edgeFrom:to:
RTEdgeBuilder>>edgeFrom:to:
[ :toE | edges add: (self edgeFrom: fromElement to: toE) ] in [ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>connectNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
7 December 2015 5:51:46.735183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTGroup(OrderedCollection)>>select:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
	Arguments and temporary variables: 
		selectBlock: 	[ :e | e from == anEdge from and: [ e to == anEdge to ] ]
		newCollection: 	nil
		element: 	nil
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	12
		attributes: 	nil


RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
		indexOfEdge: 	nil
		multipleEdges: 	an OrderedCollection()
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTLine(RTAbstractLine)>>updateFor:trachelShape:
	Receiver: a RTLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRLineShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	2
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint


RTArrowedLine>>updateFor:trachelShape:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRCompositeShape
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTArrowedLine(RTShape)>>updateFor:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edgeOrElement: 	a RTEdge
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdge(RTShapedObject)>>update
	Receiver: a RTEdge
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTArrowedLine
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		from: 	a RTElement
		to: 	a RTElement
		shouldBeUsedInLayout: 	true


[ :edge | edge update ] in RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 
		edge: 	a RTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :edge | edge update ]
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	12
		attributes: 	nil


RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement>>translateTo:
	Receiver: a RTElement
	Arguments and temporary variables: 
		newPosition: 	(132.02533915770584@197.7348355734697)
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	nil
		e: 	a RTEdge
		x: 	-0.05912470131365425
		len: 	-0.029562350656827125
		k: 	(3/7)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(130@139)
		y: 	-1.7146163380959734
		old: 	nil
		tp: 	(132@197)
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to posit...etc...
		index: 	28
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	38


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	-0.05912470131365425
		len: 	-0.029562350656827125
		k: 	(3/7)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(130@139)
		y: 	-1.7146163380959734
		old: 	nil
		tp: 	(132@197)
		quad: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9587050328866111
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in RTGroup(OrderedCollection)>>select:


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9587050328866111
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in RTGroup(OrderedCollection)>>select:


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9587050328866111
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in RTGroup(OrderedCollection)>>select:


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(205@86) a RTElement->(218@116) a RTEle...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->2 a RTElement->2 a RTElement->7 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.04088201744225495
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Graph>>addLayout
	Receiver: a Graph
	Arguments and temporary variables: 
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		names: 	false


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		names: 	false


[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in [ 
graphObj names: graphObj names not.
graph
	script: [ :view :canvas | 
		self graphObj data: data.
		self graphObj createGraph: data withView: view ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	[ 
graphObj names: graphObj names not.
graph
	script: [ :view :ca...etc...
		startpc: 	64
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(201326592)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(201326592)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(201326592)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]



--- The full stack ---
RTGroup(OrderedCollection)>>select:
RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
RTLine(RTAbstractLine)>>updateFor:trachelShape:
RTArrowedLine>>updateFor:trachelShape:
RTArrowedLine(RTShape)>>updateFor:
RTEdge(RTShapedObject)>>update
[ :edge | edge update ] in RTElement>>updateConnectedEdges
RTGroup(OrderedCollection)>>do:
RTElement>>updateConnectedEdges
RTElement>>translateTo:
[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
Graph>>addLayout
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in [ 
graphObj names: graphObj names not.
graph
	script: [ :view :canvas | 
		self graphObj data: data.
		self graphObj createGraph: data withView: view ] ] in RQTGMainWindow>>initializePresenter
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
[ 
graphObj names: graphObj names not.
graph
	script: [ :view :canvas | 
		self graphObj data: data.
		self graphObj createGraph: data withView: view ] ] in RQTGMainWindow>>initializePresenter
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
CheckBoxModel>>state:
MorphicCheckBoxAdapter>>state:
CheckboxMorph>>toggleSelected
[ target perform: actionSelector withArguments: arguments ] in CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
CheckboxMorph>>updateButton:
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
CheckboxMorph(Morph)>>mouseUp:
CheckboxMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
CheckboxMorph(Morph)>>handleEvent:
CheckboxMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
7 December 2015 5:52:29.951183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Rectangle>>center
	Receiver: (189.6450391106505@263.3424043017647) corner: (239.6450391106505@313.3424043017647)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		origin: 	(189.6450391106505@263.3424043017647)
		corner: 	(239.6450391106505@313.3424043017647)


RTShorterDistanceWithOffsetAttachPoint>>attachPointsFor:on:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
		anElement: 	a RTElement
		rec: 	(189.6450391106505@263.3424043017647) corner: (239.6450391106505@313.34240...etc...
		center: 	nil
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint(RTAbstractShorterDistanceAttachPoint)>>destinationAttachPointsFor:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint(RTAbstractShorterDistanceAttachPoint)>>endingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
	Receiver: a RTSimpleArrowHead
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRSimpleArrowShape
		f: 	(119.71172343114841@252)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	nil
		size: 	nil
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	nil
		baseSize: 	10


RTArrowedLine>>updateFor:trachelShape:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRCompositeShape
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTArrowedLine(RTShape)>>updateFor:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edgeOrElement: 	a RTEdge
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdge(RTShapedObject)>>update
	Receiver: a RTEdge
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTArrowedLine
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		from: 	a RTElement
		to: 	a RTElement
		shouldBeUsedInLayout: 	true


[ :edge | edge update ] in RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 
		edge: 	a RTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :edge | edge update ]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	11
		attributes: 	nil


RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement>>translateTo:
	Receiver: a RTElement
	Arguments and temporary variables: 
		newPosition: 	(214.42579486263267@287.82916210789074)
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	nil
		e: 	a RTEdge
		x: 	1.4765274960874257
		len: 	0.012202706579234923
		k: 	(7/18)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(94@252)
		y: 	0.4392974368524572
		old: 	nil
		tp: 	(215@288)
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to posit...etc...
		index: 	17
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	30


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	1.4765274960874257
		len: 	0.012202706579234923
		k: 	(7/18)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(94@252)
		y: 	0.4392974368524572
		old: 	nil
		tp: 	(215@288)
		quad: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9407033553598501
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Rectangle>>center


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9407033553598501
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Rectangle>>center


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9407033553598501
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in Rectangle>>center


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(184@374) a RTElement->(148@270) a RTEl...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->7 a RTElement->13 a RTElement->1 a RTElement...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.05870367819374844
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Graph>>addLayout
	Receiver: a Graph
	Arguments and temporary variables: 
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		names: 	false


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		names: 	false


[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(201326592)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(201326592)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(201326592)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj data: data.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]



--- The full stack ---
Rectangle>>center
RTShorterDistanceWithOffsetAttachPoint>>attachPointsFor:on:
RTShorterDistanceWithOffsetAttachPoint(RTAbstractShorterDistanceAttachPoint)>>destinationAttachPointsFor:
RTShorterDistanceWithOffsetAttachPoint(RTAbstractShorterDistanceAttachPoint)>>endingPointOf:
RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
RTArrowedLine>>updateFor:trachelShape:
RTArrowedLine(RTShape)>>updateFor:
RTEdge(RTShapedObject)>>update
[ :edge | edge update ] in RTElement>>updateConnectedEdges
RTGroup(OrderedCollection)>>do:
RTElement>>updateConnectedEdges
RTElement>>translateTo:
[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
Graph>>addLayout
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
7 December 2015 5:52:43.895183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

AthensAffineTransform>>transform:
	Receiver: an AthensAffineTransform
	Arguments and temporary variables: 
		aPoint: 	(-26@(21/2))
		px: 	nil
		py: 	nil
	Receiver's instance variables: 
		sx: 	1.0
		shx: 	0.0
		x: 	136.85556419860578
		shy: 	0.0
		sy: 	1.0
		y: 	121.17856544352959


TRLabelShape(TRShape)>>transformedEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		basicRectangle: 	(-26@ (-21/2)) corner: (26@(21/2))
		rotatedRectangle: 	nil
		topLeft: 	(110.85556419860578@110.67856544352959)
		topRight: 	(162.85556419860578@110.67856544352959)
		bottomRight: 	(162.85556419860578@131.67856544352958)
		bottomLeft: 	nil
		p1: 	nil
		p2: 	nil
		p3: 	nil
		p4: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/rosout'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>encompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/rosout'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


ByteSymbol(Symbol)>>value:
	Receiver: #encompassingRectangle
	Arguments and temporary variables: 
		anObject: 	a TRLabelShape
	Receiver's instance variables: 
#encompassingRectangle

OrderedCollection>>collect:
	Receiver: an OrderedCollection(a TREllipseShape a TRLabelShape)
	Arguments and temporary variables: 
		aBlock: 	#encompassingRectangle
		newCollection: 	an OrderedCollection((111.85556419860578@96.17856544352959) corn...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a TREllipseShape a TRLabelShape)
		firstIndex: 	1
		lastIndex: 	2


TRCompositeShape>>encompassingRectangle
	Receiver: a TRCompositeShape
	Arguments and temporary variables: 
		ans: 	nil
		c: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	nil
		color: 	Color gray
		path: 	nil
		strokePaint: 	Color black
		announcer: 	nil
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		shapeAndOffsets: 	an OrderedCollection(an Array(a TREllipseShape (0@0)) an Array...etc...


RTElement>>encompassingRectangle
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTShorterDistanceWithOffsetAttachPoint>>attachPointsFor:on:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
		anElement: 	a RTElement
		rec: 	nil
		center: 	nil
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint(RTAbstractShorterDistanceAttachPoint)>>destinationAttachPointsFor:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint(RTAbstractShorterDistanceAttachPoint)>>endingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
	Receiver: a RTSimpleArrowHead
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRSimpleArrowShape
		f: 	(164.76177721761877@190)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	nil
		size: 	nil
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	nil
		baseSize: 	10


RTArrowedLine>>updateFor:trachelShape:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRCompositeShape
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTArrowedLine(RTShape)>>updateFor:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edgeOrElement: 	a RTEdge
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdge(RTShapedObject)>>update
	Receiver: a RTEdge
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTArrowedLine
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		from: 	a RTElement
		to: 	a RTElement
		shouldBeUsedInLayout: 	true


[ :edge | edge update ] in RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 
		edge: 	a RTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge)
	Arguments and temporary variables: 
		aBlock: 	[ :edge | edge update ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	7
		attributes: 	nil


RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement>>translateTo:
	Receiver: a RTElement
	Arguments and temporary variables: 
		newPosition: 	(235.15707202385997@189.36941801336846)
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	nil
		x: 	-1.2968122709846643
		len: 	0.021259217557125645
		k: 	(13/20)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(236@191)
		y: 	-2.508587671740826
		old: 	nil
		tp: 	(175@73)
		e: 	a RTEdge
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to posit...etc...
		index: 	27
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	30


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	-1.2968122709846643
		len: 	0.021259217557125645
		k: 	(13/20)
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(236@191)
		y: 	-2.508587671740826
		old: 	nil
		tp: 	(175@73)
		quad: 	nil
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9131254187231022
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in AthensAffineTransform>>transform:


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9131254187231022
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in AthensAffineTransform>>transform:


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9131254187231022
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in AthensAffineTransform>>transform:


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>on:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(87@223) a RTElement->(56@183) a RTElem...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->1 a RTElement->2 a RTElement->1 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.08600583546412884
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


Graph>>addLayout
	Receiver: a Graph
	Arguments and temporary variables: 
		layout: 	a RTForceBasedLayout
		stepping: 	nil
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in [ 
graphObj names: graphObj names not.
graph
	script: [ :view :canvas | 
		self graphObj data: data.
		self graphObj createGraph: data withView: view ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	[ 
graphObj names: graphObj names not.
graph
	script: [ :view :ca...etc...
		startpc: 	64
		numArgs: 	2



--- The full stack ---
AthensAffineTransform>>transform:
TRLabelShape(TRShape)>>transformedEncompassingRectangle
TRLabelShape>>encompassingRectangle
ByteSymbol(Symbol)>>value:
OrderedCollection>>collect:
TRCompositeShape>>encompassingRectangle
RTElement>>encompassingRectangle
RTShorterDistanceWithOffsetAttachPoint>>attachPointsFor:on:
RTShorterDistanceWithOffsetAttachPoint(RTAbstractShorterDistanceAttachPoint)>>destinationAttachPointsFor:
RTShorterDistanceWithOffsetAttachPoint(RTAbstractShorterDistanceAttachPoint)>>endingPointOf:
RTShorterDistanceWithOffsetAttachPoint>>endingPointOf:
RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
RTArrowedLine>>updateFor:trachelShape:
RTArrowedLine(RTShape)>>updateFor:
RTEdge(RTShapedObject)>>update
[ :edge | edge update ] in RTElement>>updateConnectedEdges
RTGroup(OrderedCollection)>>do:
RTElement>>updateConnectedEdges
RTElement>>translateTo:
[ :e | 
from := e from.
fp := from position.
to := e to.
tp := to position.
x := tp x - fp x.
y := tp y - fp y.
len := (x * x + (y * y)) sqrt.
(len closeTo: 0) not
	ifTrue: [ 
		len := alpha * (self strengthOf: e) * (len - (self lengthOf: e)) / len.
		x := x * len.
		y := y * len.
		k := (weights at: from) / ((weights at: from) + (weights at: to)).
		to translateTo: (tp x - (x * k)) @ (tp y - (y * k)).
		k := 1 - k.
		from translateTo: (fp x + (x * k)) @ (fp y + (y * k)) ] ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
RTForceBasedLayout(RTLayout)>>on:
Graph>>addLayout
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj data: data.
self graphObj createGraph: data withView: view ] in [ 
graphObj names: graphObj names not.
graph
	script: [ :view :canvas | 
		self graphObj data: data.
		self graphObj createGraph: data withView: view ] ] in RQTGMainWindow>>initializePresenter
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
[ 
graphObj names: graphObj names not.
graph
	script: [ :view :canvas | 
		self graphObj data: data.
		self graphObj createGraph: data withView: view ] ] in RQTGMainWindow>>initializePresenter
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
CheckBoxModel>>state:
MorphicCheckBoxAdapter>>state:
CheckboxMorph>>toggleSelected
[ target perform: actionSelector withArguments: arguments ] in CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
CheckboxButtonMorph(ThreePhaseButtonMorph)>>doButtonAction
CheckboxMorph>>updateButton:
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
CheckboxMorph(Morph)>>mouseUp:
CheckboxMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
CheckboxMorph(Morph)>>handleEvent:
CheckboxMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
7 December 2015 5:58:28.607183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

FreeTypeCacheLinkedList>>moveDown:
	Receiver: a FreeTypeCacheLinkedList(a FreeTypeCacheEntry a FreeTypeCacheEntry a FreeTypeCacheEntry a...etc...
	Arguments and temporary variables: 
		aLink: 	a FreeTypeCacheEntry
		e1: 	nil
		e2: 	nil
		e3: 	nil
		e4: 	nil
	Receiver's instance variables: 
		firstLink: 	a FreeTypeCacheEntry
		lastLink: 	a FreeTypeCacheEntry


FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
	Receiver: a FreeTypeCache
	Arguments and temporary variables: 
		aFreeTypeFont: 	FreeTypeFont('Source Sans Pro' 'Regular' 12)
		charCodeInteger: 	100
		typeFlag: 	17179869184
		aBlock: 	[ 
FreeTypeGlyphRenderer current
	glyphOf: aCharacter
	colorValue: aCol...etc...
		charCodeTable: 	a Dictionary(32->a Dictionary(4->a FreeTypeCacheEntry ) 47->a Di...etc...
		typeTable: 	a Dictionary(4->a FreeTypeCacheEntry 17179869184->a FreeTypeCacheEnt...etc...
		entry: 	a FreeTypeCacheEntry
		v: 	nil
		vSize: 	nil
	Receiver's instance variables: 
		maximumSize: 	5120000
		used: 	1888700
		fontTable: 	a Dictionary(FreeTypeFont('Source Code Pro' 'Regular' 10)->a Diction...etc...
		fifo: 	a FreeTypeCacheLinkedList(a FreeTypeCacheEntry a FreeTypeCacheEntry a Fre...etc...


FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aCharacter: 	$d
		aColorValue: 	0
		monoBoolean: 	false
		sub: 	3
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0x8A608D8>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	5
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont>>widthOfString:from:to:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/bumper2pointcloud'
		startIndex: 	1
		stopIndex: 	18
		char: 	$d
		nextChar: 	nil
		resultX: 	140.04827880859375
		glyph: 	nil
		a: 	#(8.880020141601563 8.880020141601563)
		subPixelPosition: 	3
		i: 	18
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0x8A608D8>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	5
		subPixelPositioned: 	true
		symbolFont: 	false


FreeTypeFont(AbstractFont)>>widthOfString:
	Receiver: FreeTypeFont('Source Sans Pro' 'Regular' 12)
	Arguments and temporary variables: 
		aString: 	'/bumper2pointcloud'
	Receiver's instance variables: 
		face: 	a FreeTypeFace<0x8A608D8>[Source Sans Pro Regular]
		pointSize: 	12
		simulatedEmphasis: 	nil
		pixelSize: 	16
		widthAndKernedWidthCache: 	a Dictionary($/->a Dictionary($a->#(5.600006103515625...etc...
		cachedHeight: 	21
		cachedAscent: 	nil
		cachedDescent: 	5
		subPixelPositioned: 	true
		symbolFont: 	false


LogicalFont>>widthOfString:
	Receiver: a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
 realFont: FreeTy...etc...
	Arguments and temporary variables: 
		aString: 	'/bumper2pointcloud'
	Receiver's instance variables: 
		realFont: 	FreeTypeFont('Source Sans Pro' 'Regular' 12)
		emphasis: 	nil
		familyName: 	'Source Sans Pro'
		fallbackFamilyNames: 	nil
		pointSize: 	12
		stretchValue: 	5
		weightValue: 	400
		slantValue: 	0
		derivatives: 	nil
		boldDerivative: 	nil
		italicDerivative: 	nil
		boldItalicDerivative: 	nil


TRLabelShape>>textWidth
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/bumper2pointcloud'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>basicEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		w: 	nil
		h: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/bumper2pointcloud'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape(TRShape)>>transformedEncompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 
		basicRectangle: 	nil
		rotatedRectangle: 	nil
		topLeft: 	nil
		topRight: 	nil
		bottomRight: 	nil
		bottomLeft: 	nil
		p1: 	nil
		p2: 	nil
		p3: 	nil
		p4: 	nil
	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/bumper2pointcloud'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


TRLabelShape>>encompassingRectangle
	Receiver: a TRLabelShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	a TRCanvas
		color: 	Color black
		path: 	nil
		strokePaint: 	Color black
		announcer: 	an Announcer
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		text: 	'/bumper2pointcloud'
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 12
...etc...
		fontSize: 	12
		fontName: 	'Source Sans Pro'


ByteSymbol(Symbol)>>value:
	Receiver: #encompassingRectangle
	Arguments and temporary variables: 
		anObject: 	a TRLabelShape
	Receiver's instance variables: 
#encompassingRectangle

OrderedCollection>>collect:
	Receiver: an OrderedCollection(a TREllipseShape a TRLabelShape)
	Arguments and temporary variables: 
		aBlock: 	#encompassingRectangle
		newCollection: 	an OrderedCollection((164.390257909374@98.83278542653981) corner...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a TREllipseShape a TRLabelShape)
		firstIndex: 	1
		lastIndex: 	2


TRCompositeShape>>position
	Receiver: a TRCompositeShape
	Arguments and temporary variables: 

	Receiver's instance variables: 
		callbacks: 	nil
		canvas: 	nil
		color: 	Color gray
		path: 	nil
		strokePaint: 	Color black
		announcer: 	nil
		element: 	a RTElement
		matrix: 	an AthensAffineTransform
		rotationAngleDegrees: 	0
		session: 	a Session
		shapeAndOffsets: 	an OrderedCollection(an Array(a TREllipseShape (0@0)) an Array...etc...


RTElement>>position
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
		indexOfEdge: 	1
		multipleEdges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge)
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTShorterDistanceWithOffsetAttachPoint>>startingPointOf:
	Receiver: a RTShorterDistanceWithOffsetAttachPoint
	Arguments and temporary variables: 
		anEdge: 	a RTEdge
	Receiver's instance variables: 
		inverted: 	false
		offset: 	5


RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
	Receiver: a RTSimpleArrowHead
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRSimpleArrowShape
		f: 	nil
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	nil
		size: 	nil
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	nil
		baseSize: 	10


RTArrowedLine>>updateFor:trachelShape:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edge: 	a RTEdge
		trachelShape: 	a TRCompositeShape
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTArrowedLine(RTShape)>>updateFor:
	Receiver: a RTArrowedLine
	Arguments and temporary variables: 
		edgeOrElement: 	a RTEdge
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTShorterDistanceWithOffsetAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdge(RTShapedObject)>>update
	Receiver: a RTEdge
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTArrowedLine
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		from: 	a RTElement
		to: 	a RTElement
		shouldBeUsedInLayout: 	true


[ :edge | edge update ] in RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 
		edge: 	a RTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :edge | edge update ]
		index: 	8
	Receiver's instance variables: 
		array: 	an Array(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge ...etc...
		firstIndex: 	1
		lastIndex: 	9
		attributes: 	nil


RTElement>>updateConnectedEdges
	Receiver: a RTElement
	Arguments and temporary variables: 

	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement>>translateTo:
	Receiver: a RTElement
	Arguments and temporary variables: 
		newPosition: 	(188.81643440409874@123.62093561608667)
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTCompositeShape
		trachelShape: 	a TRCompositeShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | 
old := e position.
e
	translateTo:
		(old x - (((oldPositions at: e) x - old x) * friction)) @ (old y - (((oldPositions at: e) y - old y) * friction)).
oldPositions at: e put: old ] in RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		quad: 	a RTQuadTree
		x: 	200
		len: 	0.0038465626885598497
		k: 	0.007249803359578533
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(141@275)
		y: 	200
		old: 	(191@124)
		tp: 	(185@179)
		e: 	a RTElement
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(219@305) a RTElement->(150.76500440276...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->6 a RTElement->1 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07249803359578533
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


OrderedCollection>>do:
	Receiver: an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a RTElement a RTEleme...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
old := e position.
e
	translateTo:
		(old x - (((oldPositions a...etc...
		index: 	11
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	13


RTForceBasedLayout>>step
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		x: 	200
		len: 	0.0038465626885598497
		k: 	0.007249803359578533
		from: 	a RTElement
		to: 	a RTElement
		fp: 	(141@275)
		y: 	200
		old: 	(191@124)
		tp: 	(185@179)
		quad: 	a RTQuadTree
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(219@305) a RTElement->(150.76500440276...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->6 a RTElement->1 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07249803359578533
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		job: 	a Job
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(219@305) a RTElement->(150.76500440276...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->6 a RTElement->1 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07249803359578533
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


BlockClosure>>cull:
	Receiver: [ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	i...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	RTForceBasedLayout>>runLayoutInJob
		startpc: 	69
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9267696630345603
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in FreeTypeCacheLinkedList>>moveDown:


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9267696630345603
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in FreeTypeCacheLinkedList>>moveDown:


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
n...etc...
		currentValue: 	0.9267696630345603
		min: 	0.9
		max: 	1
		title: 	'Laying out elements'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in FreeTypeCacheLinkedList>>moveDown:


RTForceBasedLayout>>runLayoutInJob
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(219@305) a RTElement->(150.76500440276...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->6 a RTElement->1 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07249803359578533
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout>>doExecute:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		nodeElements: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElem...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(219@305) a RTElement->(150.76500440276...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->6 a RTElement->1 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07249803359578533
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(219@305) a RTElement->(150.76500440276...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->6 a RTElement->1 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07249803359578533
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(219@305) a RTElement->(150.76500440276...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->6 a RTElement->1 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07249803359578533
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true


RTForceBasedLayout(RTLayout)>>applyOn:
	Receiver: a RTForceBasedLayout
	Arguments and temporary variables: 
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
	Receiver's instance variables: 
		affectedNodes: 	nil
		translator: 	a RTDirectLayoutTranslator
		eventHandler: 	nil
		currentIteraction: 	nil
		edges: 	an OrderedCollection(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEd...etc...
		userDefinedEdges: 	nil
		fromPositions: 	nil
		toPositions: 	nil
		oldPositions: 	a Dictionary(a RTElement->(219@305) a RTElement->(150.76500440276...etc...
		nodes: 	an OrderedCollection(a RTElement a RTElement a RTElement a RTElement a R...etc...
		weights: 	a Dictionary(a RTElement->6 a RTElement->1 a RTElement->2 a RTElement-...etc...
		strengths: 	a Dictionary()
		lengths: 	a Dictionary()
		gravity: 	0.1
		friction: 	0.9
		theta: 	0.8
		charge: 	-450
		alpha: 	0.07249803359578533
		charges: 	a Dictionary()
		strength: 	1
		length: 	100
		fixedNodes: 	a Dictionary()
		center: 	(200@200)
		initialLayout: 	a RTGridLayout
		nbIterations: 	0
		shouldUseProgressBar: 	true



--- The full stack ---
FreeTypeCacheLinkedList>>moveDown:
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
TRLabelShape>>textWidth
TRLabelShape>>basicEncompassingRectangle
TRLabelShape(TRShape)>>transformedEncompassingRectangle
TRLabelShape>>encompassingRectangle
ByteSymbol(Symbol)>>value:
OrderedCollection>>collect:
TRCompositeShape>>position
RTElement>>position
RTShorterDistanceWithOffsetAttachPoint>>offsetNormalFor:
RTShorterDistanceWithOffsetAttachPoint>>startingPointOf:
RTSimpleArrowHead(RTLineDecoration)>>updateFor:trachelShape:
RTArrowedLine>>updateFor:trachelShape:
RTArrowedLine(RTShape)>>updateFor:
RTEdge(RTShapedObject)>>update
[ :edge | edge update ] in RTElement>>updateConnectedEdges
RTGroup(OrderedCollection)>>do:
RTElement>>updateConnectedEdges
RTElement>>translateTo:
[ :e | 
old := e position.
e
	translateTo:
		(old x - (((oldPositions at: e) x - old x) * friction)) @ (old y - (((oldPositions at: e) y - old y) * friction)).
oldPositions at: e put: old ] in RTForceBasedLayout>>step
OrderedCollection>>do:
RTForceBasedLayout>>step
[ :job | 
job
	title: 'Laying out elements';
	min: 1 - alpha;
	max: 1.
nbIterations = 0
	ifTrue: [ 
		[ 
		alpha := alpha * 0.99.
		alpha > 0.005 ]
			whileTrue: [ 
				self step.
				job currentValue: 1 - alpha ] ]
	ifFalse: [ 
		nbIterations
			timesRepeat: [ 
				alpha := alpha * 0.99.
				self step.
				job currentValue: 1 - alpha ] ] ] in RTForceBasedLayout>>runLayoutInJob
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
RTForceBasedLayout>>runLayoutInJob
RTForceBasedLayout>>doExecute:
RTForceBasedLayout(RTLayout)>>executeOnElements:
RTForceBasedLayout(RTEdgeDrivenLayout)>>executeOnElements:
RTForceBasedLayout(RTLayout)>>applyOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
RTForceBasedLayout(RTLayout)>>on:
Graph>>addLayout
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
7 December 2015 6:01:00.377183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Graph>>addLayout
	Receiver: a Graph
	Arguments and temporary variables: 
		layout: 	a RTForceBasedLayout
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(1004011520)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(1004011520)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #showN...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
Graph>>addLayout
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTLabel class>>initializeElement:
7 December 2015 6:10:27.533183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTLabel class(Object)>>doesNotUnderstand: #initializeElement:
	Receiver: RTLabel
	Arguments and temporary variables: 
		aMessage: 	initializeElement: a RTElement
		exception: 	MessageNotUnderstood: RTLabel class>>initializeElement:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	RTShape
		methodDict: 	a MethodDictionary(#defaultColor->RTLabel>>#defaultColor #defaultTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#text #font #height #fontName)
		organization: 	a ClassOrganization
		subclasses: 	{RTEditableLabel. RTExtensibleLabel. RTRotatedLabel}
		name: 	#RTLabel
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Roassal2-Core'
		traitComposition: 	{}
		localSelectors: 	nil


RTElement(RTAnnounceableObject)>>addInteraction:
	Receiver: a RTElement
	Arguments and temporary variables: 
		anInteractionClassOrInstance: 	RTLabel
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TREllipseShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


RTElement(RTAnnounceableObject)>>@
	Receiver: a RTElement
	Arguments and temporary variables: 
		anInteractionClassOrInstance: 	RTLabel
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TREllipseShape
		view: 	a RTViewForSpec
		connectedEdges: 	a RTGroup(a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge a RTEdge...etc...
		shouldUpdateEdges: 	true


[ :e | e @ interaction ] in RTGroup>>@
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		interaction: 	RTLabel
		e: 	a RTElement
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	13
		attributes: 	nil


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | e @ interaction ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	13
		attributes: 	nil


RTGroup>>@
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		interaction: 	RTLabel
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	13
		attributes: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	a RTViewForSpec
		names: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(114294784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(114294784)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil



--- The full stack ---
RTLabel class(Object)>>doesNotUnderstand: #initializeElement:
RTElement(RTAnnounceableObject)>>addInteraction:
RTElement(RTAnnounceableObject)>>@
[ :e | e @ interaction ] in RTGroup>>@
RTGroup(OrderedCollection)>>do:
RTGroup>>@
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 770
7 December 2015 6:24:37.749183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #methodStringsContainingIt: #d...etc...
	Arguments and temporary variables: 
		index: 	770
	Receiver's instance variables: 
#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #methodStringsContainingIt: #d...etc...

Array(Object)>>at:
	Receiver: #(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #methodStringsContainingIt: #d...etc...
	Arguments and temporary variables: 
		index: 	770
	Receiver's instance variables: 
#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #methodStringsContainingIt: #d...etc...

SmalltalkEditor(TextEditor)>>performCmdActionsWith:shifted:return:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-Opt-́>']		aBoolean: 	true		return: 	[ :val | ^ val ]		asciiValue: 	770		actions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #methodStr...etc...		action: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(131596288)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>dispatchCommandOn:return:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-Opt-́>']		return: 	[ :val | ^ val ]		asciiValue: 	769		honorCommandKeys: 	true		char: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(131596288)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>dispatchOn:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-Opt-́>']		char: 	nil		return: 	[ :val | ^ val ]		keyEvents: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(131596288)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ self dispatchOn: aKeyboardEvent ] in SmalltalkEditor(TextEditor)>>keystroke:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(131596288)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>handleKeystrokeAction:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ self dispatchOn: aKeyboardEvent ]
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(131596288)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>handleEditionAction:fromKeyboardEvent:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		anAction: 	[ self dispatchOn: aKeyboardEvent ]		aKeyboardEvent: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(131596288)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor(TextEditor)>>keystroke:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(131596288)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ editor keystroke: evt ] in TextMorphForEditView(TextMorph)>>basicKeyStroke:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-Opt-́>']		action: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleInteraction:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		interactionBlock: 	[ editor keystroke: evt ]
		oldEditor: 	a SmalltalkEditor
		oldParagraph: 	a Paragraph
		oldText: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge ...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView>>handleInteraction:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		interActionBlock: 	[ editor keystroke: evt ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>basicKeyStroke:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-Opt-́>']		action: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ self basicKeyStroke: evt ] in TextMorphForEditView(TextMorph)>>keyStroke:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


NECController class>>codeCompletionAround:textMorph:keyStroke:
	Receiver: NECController
	Arguments and temporary variables: 
		aBlock: 	[ self basicKeyStroke: evt ]		aTextMorph: 	a TextMorphForEditView(131596288)		evt: 	[keystroke '<Ctrl-Opt-́>']		editor: 	a SmalltalkEditor		stringHolder: 	a PackageTreeNautilusUI		completionAllowed: 	true		controller: 	a NECController
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#additionals->NECController>>#additionals #captu...etc...
		format: 	142
		layout: 	a FixedLayout
		instanceVariables: 	#('model' 'menuMorph' 'editor' 'context' 'inverseMapping' 'c...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NECWorkspaceController. NOCController}
		name: 	#NECController
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'NECompletion-View'
		traitComposition: 	{}
		localSelectors: 	nil
		uniqueInstance: 	a NECController


PharoCommonTools(ToolRegistry)>>codeCompletionAround:textMorph:keyStroke:
	Receiver: a PharoCommonTools
	Arguments and temporary variables: 
		aBlock: 	[ self basicKeyStroke: evt ]		aTextMorph: 	a TextMorphForEditView(131596288)		evt: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		tools: 	an IdentityDictionary(#basicInspector->EyeInspector #browser->PackageTre...etc...
		recentTools: 	a Dictionary(#basicInspector->a Set(EyeInspector) #browser->a Set(...etc...


TextMorphForEditView(TextMorph)>>keyStroke:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView>>keyStroke:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-Opt-́>']		view: 	a PluggableTextMorphWithLimits(760217600)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-Opt-́>']		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-Opt-́>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(131596288)
	Receiver's instance variables: 
		timeStamp: 	7281082
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	48
		position: 	(513@6.0)
		handler: 	nil
		wasHandled: 	false
		keyValue: 	769
		charCode: 	769
		scanCode: 	769


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(131596288)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1296@97)
		owner: 	a TransformMorph(740032512)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1296@97)
		color: 	Color black
		extension: 	a MorphExtension (189530112) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for 'withNameTopic: anEdge
	^ showNodeNames
		ifTrue: [ anEdge @ (...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(760217600)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-Opt-́>']		focusHolder: 	a TextMorphForEditView(131596288)		aBlock: 	[ self keyboardFocus: nil ]		w: 	a WorldMorph(511705088) [world]		result: 	nil
	Receiver's instance variables: 
		bounds: 	(648@481.0) corner: (664@497.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(648@481.0) corner: (664@497.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(131596288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(656@490) mouseOver nil nil]
		targetOffset: 	(135@53)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7261138 641 490 0 0 0 1)
		lastKeyScanCode: 	769
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	6


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(628621312) a GLM...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil		anEvent: 	[keystroke '<Ctrl-Opt-́>']		focusHolder: 	a TextMorphForEditView(131596288)		aBlock: 	[ self keyboardFocus: nil ]		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(648@481.0) corner: (664@497.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(648@481.0) corner: (664@497.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(131596288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(656@490) mouseOver nil nil]
		targetOffset: 	(135@53)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7261138 641 490 0 0 0 1)
		lastKeyScanCode: 	769
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	6


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-Opt-́>']		focusHolder: 	a TextMorphForEditView(131596288)		aBlock: 	[ self keyboardFocus: nil ]		result: 	nil
	Receiver's instance variables: 
		bounds: 	(648@481.0) corner: (664@497.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(648@481.0) corner: (664@497.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(131596288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(656@490) mouseOver nil nil]
		targetOffset: 	(135@53)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7261138 641 490 0 0 0 1)
		lastKeyScanCode: 	769
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	6


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		bounds: 	(648@481.0) corner: (664@497.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(648@481.0) corner: (664@497.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(131596288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(656@490) mouseOver nil nil]
		targetOffset: 	(135@53)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7261138 641 490 0 0 0 1)
		lastKeyScanCode: 	769
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	6


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-Opt-́>']		evt: 	[keystroke '<Ctrl-Opt-́>']
	Receiver's instance variables: 
		bounds: 	(648@481.0) corner: (664@497.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(648@481.0) corner: (664@497.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(131596288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(656@490) mouseOver nil nil]
		targetOffset: 	(135@53)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7261138 641 490 0 0 0 1)
		lastKeyScanCode: 	769
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	6


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-Opt-́>']		evtBuf: 	#(2 7281082 769 0 6 769 0 1)		type: 	2		hadAny: 	true
	Receiver's instance variables: 
		bounds: 	(648@481.0) corner: (664@497.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(648@481.0) corner: (664@497.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(131596288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(656@490) mouseOver nil nil]
		targetOffset: 	(135@53)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7261138 641 490 0 0 0 1)
		lastKeyScanCode: 	769
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(190840832))(a DropList...etc...
		lastStepTime: 	7281282
		lastStepMessage: 	nil
		lastCycleTime: 	7281282
		alarms: 	a Heap()
		lastAlarmTime: 	7281282
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(190840832))(a DropList...etc...
		lastStepTime: 	7281282
		lastStepMessage: 	nil
		lastCycleTime: 	7281282
		alarms: 	a Heap()
		lastAlarmTime: 	7281282
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(190840832))(a DropList...etc...
		lastStepTime: 	7281282
		lastStepMessage: 	nil
		lastCycleTime: 	7281282
		alarms: 	a Heap()
		lastAlarmTime: 	7281282
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(190840832))(a DropList...etc...
		lastStepTime: 	7281282
		lastStepMessage: 	nil
		lastCycleTime: 	7281282
		alarms: 	a Heap()
		lastAlarmTime: 	7281282
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(628621312) a GLM...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
SmalltalkEditor(TextEditor)>>performCmdActionsWith:shifted:return:
SmalltalkEditor(TextEditor)>>dispatchCommandOn:return:
SmalltalkEditor(TextEditor)>>dispatchOn:
[ self dispatchOn: aKeyboardEvent ] in SmalltalkEditor(TextEditor)>>keystroke:
SmalltalkEditor(TextEditor)>>handleKeystrokeAction:
SmalltalkEditor(TextEditor)>>handleEditionAction:fromKeyboardEvent:
SmalltalkEditor(TextEditor)>>keystroke:
[ editor keystroke: evt ] in TextMorphForEditView(TextMorph)>>basicKeyStroke:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>basicKeyStroke:
[ self basicKeyStroke: evt ] in TextMorphForEditView(TextMorph)>>keyStroke:
NECController class>>codeCompletionAround:textMorph:keyStroke:
PharoCommonTools(ToolRegistry)>>codeCompletionAround:textMorph:keyStroke:
TextMorphForEditView(TextMorph)>>keyStroke:
TextMorphForEditView>>keyStroke:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "addAll:" is nil
7 December 2015 6:26:21.939183 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #addAll:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	addAll: a RTGroup(a RTElement a RTElement a RTElement a RTElement a R...etc...
		exception: 	MessageNotUnderstood: receiver of "addAll:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	nil
		showNodeNames: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection()
		view: 	nil
		showNodeNames: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(17563648)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(17563648)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #addAll:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

