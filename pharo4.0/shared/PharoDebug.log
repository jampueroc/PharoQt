THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MessageTally>>withDeepCollect:
20 October 2015 5:12:29.969833 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
	Receiver: UndefinedObject(ProtoObject) >> ~~
	Arguments and temporary variables: 
		aMessage: 	withDeepCollect: #children
		exception: 	MessageNotUnderstood: MessageTally>>withDeepCollect:
		resumeValue: 	nil
	Receiver's instance variables: 
		class: 	UndefinedObject
		method: 	ProtoObject>>#'~~'
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	66
		receivers: 	#()
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


MessageTally>>gtInspectorMessageTreeIn:
	Receiver: UndefinedObject(ProtoObject) >> ~~
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=243531776 title=nil pane=a GLMPane(144...etc...
		methods: 	nil
		normalizer: 	nil
	Receiver's instance variables: 
		class: 	UndefinedObject
		method: 	ProtoObject>>#'~~'
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	66
		receivers: 	#()
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
	Receiver: UndefinedObject(ProtoObject) >> ~~
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=243531776 title=nil pane=a GLMPane(144...etc...
		aGTInspector: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLM...etc...
		pragmas: 	an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOr...etc...
		eachPragma: 	<gtInspectorPresentationOrder: 40>
	Receiver's instance variables: 
		class: 	UndefinedObject
		method: 	ProtoObject>>#'~~'
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	66
		receivers: 	#()
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOrder: 40> <gtInspecto...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue:...etc...
		index: 	2
	Receiver's instance variables: 
an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOrder: 40> <gtInspecto...etc...

MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
	Receiver: UndefinedObject(ProtoObject) >> ~~
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=243531776 title=nil pane=a GLMPane(144...etc...
		aGTInspector: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLM...etc...
		pragmas: 	an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOr...etc...
	Receiver's instance variables: 
		class: 	UndefinedObject
		method: 	ProtoObject>>#'~~'
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	66
		receivers: 	#()
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=806092800 title=a MessageTally (UndefinedObjec...etc...
		each: 	UndefinedObject(ProtoObject) >> ~~
		x: 	UndefinedObject(ProtoObject) >> ~~
		d: 	a GLMCompositePresentation(id=375390208 title=nil pane=a GLMPane(1024458752 ...etc...
	Receiver's instance variables: 
a RTExampleBrowser

GLMCompositePresentation(GLMPresentation)>>with:
	Receiver: a GLMCompositePresentation(id=375390208 title=nil pane=a GLMPane(1024458752 root))
	Arguments and temporary variables: 
		aBlock: 	[ :d | each gtInspectorPresentationsIn: d inContext: pager ]
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(1024458752 root)
		title: 	nil
		titleIcon: 	nil
		transformation: 	nil
		actions: 	nil
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentations: 	an OrderedCollection(a GTObjectVariablesBrowser(id=788004864 tit...etc...
		arrangement: 	nil


[ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=806092800 title=a MessageTally (UndefinedObjec...etc...
		each: 	UndefinedObject(ProtoObject) >> ~~
		x: 	UndefinedObject(ProtoObject) >> ~~
	Receiver's instance variables: 
a RTExampleBrowser

BlockClosure>>glamourValueWithArgs:
	Receiver: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inCon...etc...
	Arguments and temporary variables: 
		anArray: 	an Array(UndefinedObject(ProtoObject) >> ~~)
	Receiver's instance variables: 
		outerContext: 	[ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: eac...etc...
		startpc: 	167
		numArgs: 	1


BlockClosure(Object)>>glamourValue:
	Receiver: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inCon...etc...
	Arguments and temporary variables: 
		anObject: 	UndefinedObject(ProtoObject) >> ~~
		args: 	an Array(UndefinedObject(ProtoObject) >> ~~)
	Receiver's instance variables: 
		outerContext: 	[ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: eac...etc...
		startpc: 	167
		numArgs: 	1


GLMDynamicPresentation(GLMPresentation)>>displayValue
	Receiver: a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(578289664 4))
	Arguments and temporary variables: 

	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(578289664 4)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=934805504 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMDynamicPresentation>>currentPresentation
	Receiver: a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(578289664 4))
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=251133952 title=nil pane=a GLMPane(131...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(578289664 4)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=934805504 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMMorphicDynamicRenderer>>render:
	Receiver: a GLMMorphicDynamicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(5...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(152829952)


GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicDynamicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(5...etc...
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicWidgetRenderer
		methodDict: 	a MethodDictionary(#actOnPresentationUpdated:->GLMMorphicDynamicRen...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#container)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicDynamicRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderDynamicPresentation:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=467664896 title=nil pane=a GLMPane(5...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMDynamicPresentation>>renderGlamorouslyOn:
	River: a GLMDynamicPresentation(id=269484032 title=nil pane=a GLMPane(452460544 5))
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(452460544 5)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=766771200 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMDynamicPresentation(id=269484032 title=nil pane=a GLMPane(452...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMDynamicPresentation(id=269484032 title=nil pane=a GLMPane(452460...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=269484032 title=nil pane=a GLMPane(4...etc...
		morph: 	nil
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer>>render:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMCompositePresentation(id=137101312 title=a MessageTally (Un...etc...
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicCompositeRenderer
		methodDict: 	a MethodDictionary(#actOnContextChanged:->GLMMorphicTabbedRenderer>...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#tabs)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicTabbedRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderTabbedCompositePresentation:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aCompositePresentation: 	a GLMCompositePresentation(id=137101312 title=a Message...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMTabbedArrangement>>renderGlamorouslyOn:
	Receiver: a GLMTabbedArrangement
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		composite: 	a GLMCompositePresentation(id=137101312 title=a MessageTally (Undefi...etc...


GLMCompositePresentation>>renderGlamorouslyOn:
	Receiver: a GLMCompositePresentation(id=137101312 title=a MessageTally (UndefinedObject(ProtoObject)...etc...
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
er
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(578289664 4)
		title: 	[ GTInspector new printObjectAsAnItem: each ]
		titleIcon: 	nil
		transformation: 	nil
		actions: 	nil
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	[ :aPresentation | each gtInspectorActions asOrderedCollec...etc...
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	a GLMCompositePresentation(id=806092800 title=a MessageTally (...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentations: 	an OrderedCollection(a GLMDynamicPresentation(id=467664896 title...etc...
		arrangement: 	a GLMTabbedArrangement


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMCompositePresentation(id=335282176 title=a MessageTally (Unde...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMCompositePresentation(id=335282176 title=a MessageTally (Undefin...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(1018691584)
		contentMorph: 	nil


GLMMorphicPaneRenderer>>renderContainerFor:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(1018691584)
		contentMorph: 	nil


GLMMorphicPaneRenderer>>render:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(1018691584)
		contentMorph: 	nil


GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMPane(578289664 4)
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicWidgetRenderer
		methodDict: 	a MethodDictionary(#actOnMatchingPresentationChanged:->GLMMorphicPa...etc...
		format: 	136
		layout: 	a FixedLayout
		instanceVariables: 	#(#container #contentMorph)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicPaneRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderPane:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMPane>>renderGlamorouslyOn:
	Receiver: a GLMPane(578289664 4)
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		browser: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(...etc...
		name: 	'4'
		presentations: 	a GLMCompositePresentation(id=335282176 title=a MessageTally (Un...etc...
		ports: 	an OrderedCollection(Port (pane='4' name=#activePresentation value=nil) ...etc...
		lastActivePresentation: 	nil
		allowedToNotePresentationsChanged: 	true
		cachedMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=4...etc...


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMPane(578289664 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


GLMMorphicPagerRenderer>>actOnPaneAdded:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		ann: 	a GLMPaneAdded
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


MessageSend>>value:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		anObject: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg1: 	a GLMPaneAdded
		arg2: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(675...etc...
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a GLMPaneAdded
	Receiver's instance variables: 
		announcer: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPan...etc...
		announcementClass: 	GLMPaneAdded
		subscriber: 	a GLMMorphicPagerRenderer
		action: 	MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
MessageTally>>gtInspectorMessageTreeIn:
[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
Array(SequenceableCollection)>>do:
MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
GLMCompositePresentation(GLMPresentation)>>with:
[ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
BlockClosure>>glamourValueWithArgs:
BlockClosure(Object)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
GLMMorphicDynamicRenderer>>render:
GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderDynamicPresentation:
GLMDynamicPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GLMCompositePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPaneRenderer>>renderContainerFor:
GLMMorphicPaneRenderer>>render:
GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPane:
GLMPane>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPagerRenderer>>actOnPaneAdded:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MessageTally>>withDeepCollect:
20 October 2015 5:13:02.437839 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
	Receiver: LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Arguments and temporary variables: 
		aMessage: 	withDeepCollect: #children
		exception: 	MessageNotUnderstood: MessageTally>>withDeepCollect:
		resumeValue: 	nil
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


MessageTally>>gtInspectorMessageTreeIn:
	Receiver: LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(101...etc...
		methods: 	nil
		normalizer: 	nil
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
	Receiver: LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(101...etc...
		aGTInspector: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLM...etc...
		pragmas: 	an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOr...etc...
		eachPragma: 	<gtInspectorPresentationOrder: 40>
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOrder: 40> <gtInspecto...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue:...etc...
		index: 	2
	Receiver's instance variables: 
an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOrder: 40> <gtInspecto...etc...

MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
	Receiver: LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(101...etc...
		aGTInspector: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLM...etc...
		pragmas: 	an Array(<gtInspectorPresentationOrder: 10> <gtInspectorPresentationOr...etc...
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=629407744 title=a MessageTally (LazyMorphListM...etc...
		each: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		x: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		d: 	a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(1016594432 ...etc...
	Receiver's instance variables: 
a RTExampleBrowser

GLMCompositePresentation(GLMPresentation)>>with:
	Receiver: a GLMCompositePresentation(id=337379328 title=nil pane=a GLMPane(1016594432 root))
	Arguments and temporary variables: 
		aBlocationOr...etc...
	Receiver's instance variables: 
		class: 	LazyMorphListMorph
		method: 	LazyMorphListMorph>>#listChanged
		process: 	a Process in [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFal...etc...
		tally: 	1678
		receivers: 	an Array(LazyMorphListMorph(LazyListMorph) >> getListSize LazyMorphL...etc...
		senders: 	nil
		time: 	0
		gcStats: 	nil
		maxClassNameSize: 	50
		maxClassPlusSelectorSize: 	100
		maxTabs: 	120
		reportOtherProcesses: 	true


[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=689700864 title=a MessageTally (LazyMorphListM...etc...
		each: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		x: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		d: 	a GLMCompositePresentation(id=228851712 title=nil pane=a GLMPane(871890944 r...etc...
	Receiver's instance variables: 
a RTExampleBrowser

GLMCompositePresentation(GLMPresentation)>>with:
	Receiver: a GLMCompositePresentation(id=228851712 title=nil pane=a GLMPane(871890944 root))
	Arguments and temporary variables: 
		aBlock: 	[ :d | each gtInspectorPresentationsIn: d inContext: pager ]
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(871890944 root)
		title: 	nil
		titleIcon: 	nil
		transformation: 	nil
		actions: 	nil
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentations: 	an OrderedCollection(a GTObjectVariablesBrowser(id=647495680 tit...etc...
		arrangement: 	nil


[ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
	Receiver: a RTExampleBrowser
	Arguments and temporary variables: 
		pager: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(67...etc...
		a: 	a GLMCompositePresentation(id=689700864 title=a MessageTally (LazyMorphListM...etc...
		each: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
		x: 	LazyMorphListMorph(LazyMorphListMorph) >> listChanged
	Receiver's instance variables: 
a RTExampleBrowser

BlockClosure>>glamourValueWithArgs:
	Receiver: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inCon...etc...
	Arguments and temporary variables: 
		anArray: 	an Array(LazyMorphListMorph(LazyMorphListMorph) >> listChanged)
	Receiver's instance variables: 
		outerContext: 	[ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: eac...etc...
		startpc: 	167
		numArgs: 	1


BlockClosure(Object)>>glamourValue:
	Receiver: [ :x | (GLMCompositePresennsformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMDynamicPresentation>>currentPresentation
	Receiver: a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(486014976 4))
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=207093760 title=nil pane=a GLMPane(650...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(486014976 4)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=782237696 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMMorphicDynamicRenderer>>render:
	Receiver: a GLMMorphicDynamicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(4...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(102760448)


GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicDynamicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(4...etc...
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicWidgetRenderer
		methodDict: 	a MethodDictionary(#actOnPresentationUpdated:->GLMMorphicDynamicRen...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#container)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicDynamicRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderDynamicPresentation:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(4...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMDynamicPresentation>>renderGlamorouslyOn:
	Receiver: a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(486014976 4))
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(486014976 4)
		title: 	nil
		titleIcon: 	nil
		transformation: 	[ :x | (GLMCompositePresentation new with: [ :d | each gtInspec...etc...
		actions: 	nil
		condition: 	[ true ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	nil
		parentPrototype: 	a GLMDynamicPresentation(id=782237696 title=nil pane=a GLMPane...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>dynamic
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentationTransformation: 	[ :aComposite :each | aComposite custom: each ]
		cachedPresentation: 	nil


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(486...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(486014...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMDynamicPresentation(id=339214336 title=nil pane=a GLMPane(4...etc...
		morph: 	nil
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer>>render:
	Receiver: a GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		tabs: 	nil


GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicTabbedRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (La...etc...
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicCompositeRenderer
		methodDict: 	a MethodDictionary(#actOnContextChanged:->GLMMorphicTabbedRenderer>...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#tabs)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicTabbedRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderTabbedCompositePresentation:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aCompositePresentation: 	a GLMCompositePresentation(id=212860928 title=a Message...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMTabbedArrangement>>renderGlamorouslyOn:
	Receiver: a GLMTabbedArrangement
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		composite: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (LazyMo...etc...


GLMCompositePresentation>>renderGlamorouslyOn:
	Receiver: a GLMCompositePresentation(id=212860928 title=a MessageTally (LazyMorphListMorph>>#listCha...etc...
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(486014976 4)
		title: 	[ GTInspector new printObjectAsAnItem: each ]
		titleIcon: 	nil
		transformation: 	nil
		actions: 	nil
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	[ :aPresentation | each gtInspectorActions asOrderedCollec...etc...
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	a GLMCompositePresentation(id=629407744 title=a MessageTally (...etc...
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	a Set(GLMTransmission (origins=an OrderedCollection(...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		presentations: 	an OrderedCollection(a GLMDynamicPresentation(id=339214336 title...etc...
		arrangement: 	a GLMTabbedArrangement


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (Lazy...etc...
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (LazyMor...etc...
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(938475520)
		contentMorph: 	nil


GLMMorphicPaneRenderer>>renderContainerFor:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(938475520)
		contentMorph: 	nil


GLMMorphicPaneRenderer>>render:
	Receiver: a GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a PanelMorph(938475520)
		contentMorph: 	nil


GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
	Receiver: GLMMorphicPaneRenderer
	Arguments and temporary variables: 
		aPresentation: 	a GLMPane(486014976 4)
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		superclass: 	GLMMorphicWidgetRenderer
		methodDict: 	a MethodDictionary(#actOnMatchingPresentationChanged:->GLMMorphicPa...etc...
		format: 	136
		layout: 	a FixedLayout
		instanceVariables: 	#(#container #contentMorph)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GLMMorphicPaneRenderer
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Glamour-Morphic-Renderer'
		traitComposition: 	{}
		localSelectors: 	nil


GLMMorphicRenderer>>renderPane:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aPane: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMPane>>renderGlamorouslyOn:
	Receiver: a GLMPane(486014976 4)
	Arguments and temporary variables: 
		aRenderer: 	a GLMMorphicRenderer
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		browser: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(...etc...
		name: 	'4'
		presentations: 	a GLMCompositePresentation(id=212860928 title=a MessageTally (La...etc...
		ports: 	an OrderedCollection(Port (pane='4' name=#activePresentation value=nil) ...etc...
		lastActivePresentation: 	nil
		allowedToNotePresentationsChanged: 	true
		cachedMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=3...etc...


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMPane(486014976 4)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


GLMMorphicPagerRenderer>>actOnPaneAdded:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		ann: 	a GLMPaneAdded
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


MessageSend>>value:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		anObject: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:
	Recinstance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		browser: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(...etc...
		name: 	'5'
		presentations: 	a GLMCompositePresentation(id=164626432 title=a MessageTally (La...etc...
		ports: 	an OrderedCollection(Port (pane='5' name=#activePresentation value=nil) ...etc...
		lastActivePresentation: 	nil
		allowedToNotePresentationsChanged: 	true
		cachedMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=2...etc...


GLMMorphicRenderer(GLMRenderer)>>render:
	Receiver: a GLMMorphicRenderer
	Arguments and temporary variables: 
		aRenderable: 	a GLMPane(528220160 5)
	Receiver's instance variables: 
		window: 	a GLMSystemWindow(850919424)


GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		anObject: 	a GLMPane(528220160 5)
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


GLMMorphicPagerRenderer>>actOnPaneAdded:
	Receiver: a GLMMorphicPagerRenderer
	Arguments and temporary variables: 
		ann: 	a GLMPaneAdded
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


MessageSend>>value:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		anObject: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg1: 	a GLMPaneAdded
		arg2: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(675...etc...
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a GLMPaneAdded
	Receiver's instance variables: 
		announcer: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPan...etc...
		announcementClass: 	GLMPaneAdded
		subscriber: 	a GLMMorphicPagerRenderer
		action: 	MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
MessageTally>>gtInspectorMessageTreeIn:
[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
Array(SequenceableCollection)>>do:
MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsInslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPagerRenderer>>actOnPaneAdded:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

 	a GLMMorphicRenderer
		container: 	a GLMFoundationBrick(970457088)


MessageSend>>value:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		anObject: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg: 	a GLMPaneAdded
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)
	Arguments and temporary variables: 
		arg1: 	a GLMPaneAdded
		arg2: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPane(675...etc...
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPagerRenderer
		selector: 	#actOnPaneAdded:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a GLMPaneAdded
	Receiver's instance variables: 
		announcer: 	a GLMPager(id=262406144 title=Roassal examples browser pane=a GLMPan...etc...
		announcementClass: 	GLMPaneAdded
		subscriber: 	a GLMMorphicPagerRenderer
		action: 	MessageSend(#actOnPaneAdded: -> a GLMMorphicPagerRenderer)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
MessageTally(Object)>>doesNotUnderstand: #withDeepCollect:
MessageTally>>gtInspectorMessageTreeIn:
[ :eachPragma | 
(eachPragma selector findTokens: $:) size = 1
	ifTrue: [ self perform: eachPragma selector with: composite ].
(eachPragma selector findTokens: $:) size = 2
	ifTrue: [ self perform: eachPragma selector with: composite with: aGTInspector ] ] in MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
Array(SequenceableCollection)>>do:
MessageTally(Object)>>gtInspectorPresentationsIn:inContext:
[ :d | each gtInspectorPresentationsIn: d inContext: pager ] in [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
GLMCompositePresentation(GLMPresentation)>>with:
[ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] in [ :a :each | 
a title: [ GTInspector new printObjectAsAnItem: each ].
a dynamicActions: [ :aPresentation | each gtInspectorActions asOrderedCollection ].
a dynamic
	display: [ :x | (GLMCompositePresentation new with: [ :d | each gtInspectorPresentationsIn: d inContext: pager ]) startOn: x ] ] in RTExampleBrowser>>open
BlockClosure>>glamourValueWithArgs:
BlockClosure(Object)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
GLMMorphicDynamicRenderer>>render:
GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderDynamicPresentation:
GLMDynamicPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GLMCompositePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPaneRenderer>>renderContainerFor:
GLMMorphicPaneRenderer>>render:
GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPane:
GLMPane>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPagerRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPagerRenderer>>actOnPaneAdded:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: TRConstraint class>>stick:onTheBottomLeftOf:
22 October 2015 3:36:40.686015 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

TRConstraint class(Object)>>doesNotUnderstand: #stick:onTheBottomLeftOf:
	Receiver: TRConstraint
	Arguments and temporary variables: 
		aMessage: 	stick: a TRLabelShape onTheBottomLeftOf: a TRArcShape
		exception: 	MessageNotUnderstood: TRConstraint class>>stick:onTheBottomLeftOf:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TRObject
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TRConstraint
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Trachel-Core'
		traitComposition: 	{}
		localSelectors: 	nil


RTLabelled>>initializeElement:
	Receiver: a RTLabelled
	Arguments and temporary variables: 
		element: 	a RTElement
		s: 	a TRArcShape
		t: 	1
		callback: 	a TRRemoveCallback
	Receiver's instance variables: 
		canvas: 	a TRCanvas
		color: 	Color gray
		highlightable: 	false
		lbl: 	a TRLabelShape
		lowColor: 	Color veryVeryLightGray
		offsetOnEdge: 	0.5
		position: 	#bottomLeft
		text: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		fontSize: 	12


RTElement(RTAnnounceableObject)>>addInteraction:
	Receiver: a RTElement
	Arguments and temporary variables: 
		anInteractionClassOrInstance: 	a RTLabelled
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	a Dictionary(#RTLabelledCallback->a TRRemoveCallback #RTLabelledLab...etc...
		isFixed: 	false
		model: 	1
		shape: 	a RTArc
		trachelShape: 	a TRArcShape
		view: 	a RTView
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTElement(RTAnnounceableObject)>>@
	Receiver: a RTElement
	Arguments and temporary variables: 
		anInteractionClassOrInstance: 	a RTLabelled
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	a Dictionary(#RTLabelledCallback->a TRRemoveCallback #RTLabelledLab...etc...
		isFixed: 	false
		model: 	1
		shape: 	a RTArc
		trachelShape: 	a TRArcShape
		view: 	a RTView
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


[ :e | e @ interaction ] in RTGroup>>@
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		interaction: 	a RTLabelled
		e: 	a RTElement
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	10
		attributes: 	nil


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | e @ interaction ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	10
		attributes: 	nil


RTGroup>>@
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		interaction: 	a RTLabelled
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	10
		attributes: 	nil


RTRoassalExample>>exampleArc
	Receiver: a RTRoassalExample
	Arguments and temporary variables: 
		view: 	a RTView
		shape: 	a RTArc
		label: 	a RTLabelled
	Receiver's instance variables: 
a RTRoassalExample

RTExampleSelection(GTExample)>>result
	Receiver: a RTExampleSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		result: 	nil
		title: 	nil
		provider: 	a RTRoassalExample
		selector: 	#exampleArc
		parentExample: 	nil
		extractionStrategy: 	nil


[ :example | example result ] in RTRoassalExample(RTAbstractExample)>>gtInspectorPreviewIn:
	Receiver: a RTRoassalExample
	Arguments and temporary variables: 
		composite: 	a GLMCompositePresentation(id=258473984 title=nil pane=a GLMPane(478...etc...
		example: 	a RTExampleSelection
	Receiver's instance variables: 
a RTRoassalExample

BlockClosure>>glamourValueWithArgs:
	Receiver: [ :example | example result ]
	Arguments and temporary variables: 
		anArray: 	an Array(a RTExampleSelection)
	Receiver's instance variables: 
		outerContext: 	RTRoassalExample(RTAbstractExample)>>gtInspectorPreviewIn:
		startpc: 	79
		numArgs: 	1


BlockClosure(Object)>>glamourValue:
	Receiver: [ :example | example result ]
	Arguments and temporary variables: 
		anObject: 	a RTExampleSelection
		args: 	an Array(a RTExampleSelection)
	Receiver's instance variables: 
		outerContext: 	RTRoassalExample(RTAbstractExample)>>gtInspectorPreviewIn:
		startpc: 	79
		numArgs: 	1


GLMTransmission>>value
	Receiver: GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 757858304 (name=#...etc...
	Arguments and temporary variables: 
		originalValue: 	a RTExampleSelection
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		context: 	nil
		destination: 	a GLMPresentationBoundPort 794558464 (name=#selection value=a RTVi...etc...
		browser: 	nil
		origins: 	an OrderedCollection(a GLMOriginPortReference 793247744 (a GLMPresenta...etc...
		transmissionStrategy: 	a GLMNoStrategy
		transformation: 	[ :example | example result ]
		condition: 	true


GLMPanePort>>receive:in:
	Receiver: Port (pane='2' name=#selection value=a RTView)
	Arguments and temporary variables: 
		aTransmission: 	GLMTransmission (origins=an OrderedCollection(a GLMPresentationB...etc...
		aContext: 	a GLMTransmissionContext(nil)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		name: 	#selection
		pane: 	a GLMPane(478937088 2)
		value: 	a RTView


GLMPresentationBoundPort>>receive:in:
	Receiver: a GLMPresentationBoundPort 794558464 (name=#selection value=a RTView)
	Arguments and temporary variables: 
		aTransmission: 	GLMTransmission (origins=an OrderedCollection(a GLMPresentationB...etc...
		aContext: 	a GLMTransmissionContext(nil)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		name: 	#selection
		presentation: 	a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMP...etc...


[ 
self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn:
	Receiver: GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 757858304 (name=#...etc...
	Arguments and temporary variables: 
		aContext: 	a GLMTransmissionContext(nil)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		context: 	nil
		destination: 	a GLMPresentationBoundPort 794558464 (name=#selection value=a RTVi...etc...
		browser: 	nil
		origins: 	an OrderedCollection(a GLMOriginPortReference 793247744 (a GLMPresenta...etc...
		transmissionStrategy: 	a GLMNoStrategy
		transformation: 	[ :example | example result ]
		condition: 	true


GLMPane>>notingPresentationChangeDo:
	Receiver: a GLMPane(478937088 2)
	Arguments and temporary variables: 
		aBlock: 	[ 
self transmissionStrategy transmitIn: aContext.
self destination rec...etc...
		oldPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=350224384 ti...etc...
		oldMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=3502...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		browser: 	a GLMPager(id=108003328 title=Roassal examples browser pane=a GLMPane(...etc...
		name: 	'2'
		presentations: 	a GLMCompositePresentation(id=217841664 title=a RTRoassalExample...etc...
		ports: 	an OrderedCollection(Port (pane='2' name=#activePresentation value=nil) ...etc...
		lastActivePresentation: 	nil
		allowedToNotePresentationsChanged: 	false
		cachedMatchingPresentations: 	an OrderedCollection(a GLMDynamicPresentation(id=3...etc...


GLMPresentationBoundPort(GLMBoundPort)>>notingPresentationChangeDo:
	Receiver: a GLMPresentationBoundPort 794558464 (name=#selection value=a RTView)
	Arguments and temporary variables: 
		aBlock: 	[ 
self transmissionStrategy transmitIn: aContext.
self destination rec...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		name: 	#selection
		presentation: 	a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMP...etc...


GLMTransmission>>transmitIn:
	Receiver: GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 757858304 (name=#...etc...
	Arguments and temporary variables: 
		aContext: 	a GLMTransmissionContext(nil)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		context: 	nil
		destination: 	a GLMPresentationBoundPort 794558464 (name=#selection value=a RTVi...etc...
		browser: 	nil
		origins: 	an OrderedCollection(a GLMOriginPortReference 793247744 (a GLMPresenta...etc...
		transmissionStrategy: 	a GLMNoStrategy
		transformation: 	[ :example | example result ]
		condition: 	true


GLMTransmission>>transmit
	Receiver: GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 757858304 (name=#...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		context: 	nil
		destination: 	a GLMPresentationBoundPort 794558464 (name=#selection value=a RTVi...etc...
		browser: 	nil
		origins: 	an OrderedCollection(a GLMOriginPortReference 793247744 (a GLMPresenta...etc...
		transmissionStrategy: 	a GLMNoStrategy
		transformation: 	[ :example | example result ]
		condition: 	true


ByteSymbol(Symbol)>>value:
	Receiver: #transmit
	Arguments and temporary variables: 
		anObject: 	GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundP...etc...
	Receiver's instance variables: 
#transmit

IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 75...etc...
	Arguments and temporary variables: 
		aBlock: 	#transmit
		index: 	1
		each: 	GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort ...etc...
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(GLMTransmission (origins=an OrderedCollection(a GLMPresentation...etc...


GLMRoassal2Presentation(GLMPresentation)>>selection:
	Receiver: a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMPane(478937088 2))
	Arguments and temporary variables: 
		anObject: 	a RTExampleSelection
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(478937088 2)
		title: 	'Examples'
		titleIcon: 	nil
		transformation: 	nil
		actions: 	an OrderedCollection(a GLMGenericAction a GLMGenericAction a GLMGeneri...etc...
		condition: 	[ self gtExamples notEmpty ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	true
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>roassal2
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		painting: 	nil
		paintingBlock: 	[ :view | 
view @ RTDraggableView.
self gtOpenOn: view ]
		view: 	a RTView
		shouldPopulateSelection: 	true
		newViewBlock: 	[ RTView new ]


[ :event | self selection: each model ] in [ :each | each when: TRMouseLeftClick do: [ :event | self selection: each model ] ] in GLMRoassal2Presentation>>renderOn:
	Receiver: a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMPane(478937088 2))
	Arguments and temporary variables: 
		aView: 	a RTView
		each: 	a RTElement
		event: 	a TRMouseLeftClick
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(478937088 2)
		title: 	'Examples'
		titleIcon: 	nil
		transformation: 	nil
		actions: 	an OrderedCollection(a GLMGenericAction a GLMGenericAction a GLMGeneri...etc...
		condition: 	[ self gtExamples notEmpty ]
		implicitNotNil: 	true
		dynamicActionsBlock: 	nil
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	false
		acceptsSelection: 	true
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	nil
		selectionDynamicActionsBlock: 	nil
		implicitAllNil: 	false
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	GLMCompositePresentation>>roassal2
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		painting: 	nil
		paintingBlock: 	[ :view | 
view @ RTDraggableView.
self gtOpenOn: view ]
		view: 	a RTView
		shouldPopulateSelection: 	true
		newViewBlock: 	[ RTView new ]


BlockClosure>>cull:
	Receiver: [ :event | self selection: each model ]
	Arguments and temporary variables: 
		anArg: 	a TRMouseLeftClick
	Receiver's instance variables: 
		outerContext: 	[ :each | each when: TRMouseLeftClick do: [ :event | self selecti...etc...
		startpc: 	107
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :event | self selection: each model ]
	Arguments and temporary variables: 
		firstArg: 	a TRMouseLeftClick
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	[ :each | each when: TRMouseLeftClick do: [ :event | self selecti...etc...
		startpc: 	107
		numArgs: 	1


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a TRMouseLeftClick
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	TRMouseLeftClick
		subscriber: 	a GLMRoassal2Presentation(id=710672384 title=Examples pane=a GLMPan...etc...
		action: 	[ :event | self selection: each model ]


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		copy: 	nil
		onDoCtx: 	nil
		process: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
TRConstraint class(Object)>>doesNotUnderstand: #stick:onTheBottomLeftOf:
RTLabelled>>initializeElement:
RTElement(RTAnnounceableObject)>>addInteraction:
RTElement(RTAnnounceableObject)>>@
[ :e | e @ interaction ] in RTGroup>>@
RTGroup(OrderedCollection)>>do:
RTGroup>>@
RTRoassalExample>>exampleArc
RTExampleSelection(GTExample)>>result
[ :example | example result ] in RTRoassalExample(RTAbstractExample)>>gtInspectorPreviewIn:
BlockClosure>>glamourValueWithArgs:
BlockClosure(Object)>>glamourValue:
GLMTransmission>>value
GLMPanePort>>receive:in:
GLMPresentationBoundPort>>receive:in:
[ 
self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn:
GLMPane>>notingPresentationChangeDo:
GLMPresentationBoundPort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
GLMTransmission>>transmit
ByteSymbol(Symbol)>>value:
IdentitySet(Set)>>do:
GLMRoassal2Presentation(GLMPresentation)>>selection:
[ :event | self selection: each model ] in [ :each | each when: TRMouseLeftClick do: [ :event | self selection: each model ] ] in GLMRoassal2Presentation>>renderOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: HideWindow>>hideButton
26 November 2015 4:32:46.680323 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow(Object)>>doesNotUnderstand: #hideButton
	Receiver: a HideWindow
	Arguments and temporary variables: 
		aMessage: 	hideButton
		exception: 	MessageNotUnderstood: HideWindow>>hideButton
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	nil
		showButton: 	nil


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#hideButton
		args: 	#()
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#hideButton
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #hideButton)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. ...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0....etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0....etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. ...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayou...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayout...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutF...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFract...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFract...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayout...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSea...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSear...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearc...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearch). #layout:. {#...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearch). #layout:. {#...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSear...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a HideWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a HideWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
HideWindow(Object)>>doesNotUnderstand: #hideButton
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
HideWindow(ComposableModel)>>adapterFrom:model:
HideWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
HideWindow(ComposableModel)>>openWithSpecLayout:
HideWindow(ComposableModel)>>openWithSpec:
HideWindow(ComposableModel)>>openWithSpec
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: HideWindow>>hideButton
26 November 2015 4:33:38.535615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow(Object)>>doesNotUnderstand: #hideButton
	Receiver: a HideWindow
	Arguments and temporary variables: 
		aMessage: 	hideButton
		exception: 	MessageNotUnderstood: HideWindow>>hideButton
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#hideButton
		args: 	#()
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#hideButton
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #hideButton)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #hideButton)
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #hideButton)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFra...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. ...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0....etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0....etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. ...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLa...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayou...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecL...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayout...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutF...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFract...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayoutFrame. #leftFract...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #hideButton). #layout:. {#SpecLayout...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	6


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #label...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSea...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labe...etc...
		aModel: 	a HideWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSear...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearc...etc...
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearch). #layout:. {#...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSearch). #layout:. {#...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #labelSear...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a HideWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a HideWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a HideWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
HideWindow(Object)>>doesNotUnderstand: #hideButton
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
HideWindow(ComposableModel)>>adapterFrom:model:
HideWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
HideWindow(ComposableModel)>>openWithSpecLayout:
HideWindow(ComposableModel)>>openWithSpec:
HideWindow(ComposableModel)>>openWithSpec
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 4:38:58.935615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
a := hideMenu multiSelection.
self halt ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu multiSelection.
self halt ] ]
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(574881792))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(574881792)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		event: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		evt: 	[(1462@402) mouseUp 881604 nil]
		all: 	an Array(a PluggableButtonMorph(574881792) a PluggableButtonMorph(56675532...etc...
		m: 	a PluggableButtonMorph(574881792)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(574881792) a PluggableButtonMorph(566755328))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(574881792) a PluggableButtonMorph(566755328))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		evt: 	[(1462@402) mouseUp 881604 nil]
		all: 	an Array(a PluggableButtonMorph(574881792) a PluggableButtonMorph(56675532...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


MouseButtonEvent>>sentTo:
	Receiver: [(1462@402) mouseUp 881604 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(574881792)
	Receiver's instance variables: 
		timeStamp: 	881604
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1462@402)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(574881792)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(255328256)
		submorphs: 	an Array(an AlignmentMorph(383778816))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (642252800) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(465829888)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		focusHolder: 	a PluggableButtonMorph(574881792)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1462@402) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(860094464) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		focusHolder: 	a PluggableButtonMorph(574881792)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		focusHolder: 	a PluggableButtonMorph(574881792)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1462@402) mouseUp 881604 nil]
		evt: 	[(1462@402) mouseUp 881604 nil]
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1462@402) mouseUp 881604 nil]
		evtBuf: 	#(1 881604 1462 402 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1462@402) corner: (1478@418)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1462@402) corner: (1478@418)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(574881792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1462@402) mouseOver nil nil]
		targetOffset: 	(113.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 881604 1462 402 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	881780
		lastStepMessage: 	nil
		lastCycleTime: 	881780
		alarms: 	a Heap()
		lastAlarmTime: 	881780
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	881780
		lastStepMessage: 	nil
		lastCycleTime: 	881780
		alarms: 	a Heap()
		lastAlarmTime: 	881780
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	881780
		lastStepMessage: 	nil
		lastCycleTime: 	881780
		alarms: 	a Heap()
		lastAlarmTime: 	881780
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	881780
		lastStepMessage: 	nil
		lastCycleTime: 	881780
		alarms: 	a Heap()
		lastAlarmTime: 	881780
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(860094464) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
a := hideMenu multiSelection.
self halt ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MultiColumnListModel>>selectItems
26 November 2015 4:40:38.437617 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

MultiColumnListModel(Object)>>doesNotUnderstand: #selectItems
	Receiver: a MultiColumnListModel
	Arguments and temporary variables: 
		aMessage: 	selectItems
		exception: 	MessageNotUnderstood: MultiColumnListModel>>selectItems
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicMultiColumnListAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self clickOnSelectedItem...etc...
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'List' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		selectionHolder: 	a SelectionValueHolder[ an Array(a NewValueHolder[ 4 ] a NewVa...etc...
		listHolder: 	a CollectionValueHolder[ an OrderedCollection(a Node a Node a Node ...etc...
		menuHolder: 	a NewValueHolder[ [ :m :s | self menu: m shifted: s ] ]
		shortcutsHolder: 	nil
		multiSelectionHolder: 	a DictionaryValueHolder[ an IdentityDictionary(3->false 4...etc...
		multiSelection: 	a NewValueHolder[ true ]
		allowToSelect: 	a NewValueHolder[ true ]
		listItemsCache: 	an OrderedCollection(a Node a Node a Node a Node)
		filteringBlockHolder: 	a NewValueHolder[ [ :col | col ] ]
		sortingBlockHolder: 	a NewValueHolder[ [ :a :b | a objName < b objName ] ]
		wrapBlockHolder: 	a NewValueHolder[ [ :item | self wrapItem: item ] ]
		listAnnouncer: 	an Announcer
		backgroundColorBlock: 	a NewValueHolder[ [ :item :index | Smalltalk ui theme bac...etc...
		autoDeselect: 	a NewValueHolder[ true ]


[ 
a := hideMenu selectItems.
self halt ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectItems.
self halt ] ]
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(254017536))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(254017536)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		event: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		evt: 	[(1440@399) mouseUp 981204 nil]
		all: 	an Array(a PluggableButtonMorph(254017536) a PluggableButtonMorph(31064064...etc...
		m: 	a PluggableButtonMorph(254017536)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(254017536) a PluggableButtonMorph(310640640))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(254017536) a PluggableButtonMorph(310640640))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		evt: 	[(1440@399) mouseUp 981204 nil]
		all: 	an Array(a PluggableButtonMorph(254017536) a PluggableButtonMorph(31064064...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


MouseButtonEvent>>sentTo:
	Receiver: [(1440@399) mouseUp 981204 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(254017536)
	Receiver's instance variables: 
		timeStamp: 	981204
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1440@399)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(254017536)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(786432000)
		submorphs: 	an Array(an AlignmentMorph(62914560))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (315359232) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(144965632)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		focusHolder: 	a PluggableButtonMorph(254017536)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1440@399) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(173539328) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		focusHolder: 	a PluggableButtonMorph(254017536)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		focusHolder: 	a PluggableButtonMorph(254017536)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1440@399) mouseUp 981204 nil]
		evt: 	[(1440@399) mouseUp 981204 nil]
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1440@399) mouseUp 981204 nil]
		evtBuf: 	#(1 981204 1440 399 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1440@399) corner: (1456@415)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1440@399) corner: (1456@415)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(254017536)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1440@399) mouseOver nil nil]
		targetOffset: 	(91.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 981204 1440 399 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	981278
		lastStepMessage: 	nil
		lastCycleTime: 	981278
		alarms: 	a Heap()
		lastAlarmTime: 	981278
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	981278
		lastStepMessage: 	nil
		lastCycleTime: 	981278
		alarms: 	a Heap()
		lastAlarmTime: 	981278
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	981278
		lastStepMessage: 	nil
		lastCycleTime: 	981278
		alarms: 	a Heap()
		lastAlarmTime: 	981298
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	981298
		lastStepMessage: 	nil
		lastCycleTime: 	981298
		alarms: 	a Heap()
		lastAlarmTime: 	981298
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(173539328) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MultiColumnListModel(Object)>>doesNotUnderstand: #selectItems
[ 
a := hideMenu selectItems.
self halt ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 4:41:06.665617 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
a := hideMenu selectedItems.
self halt ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#(#('D' 'true'))
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems.
self halt ] ]
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(470548480))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(470548480)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		event: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		evt: 	[(1485@392) mouseUp 1009420 nil]
		all: 	an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424...etc...
		m: 	a PluggableButtonMorph(470548480)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		evt: 	[(1485@392) mouseUp 1009420 nil]
		all: 	an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


MouseButtonEvent>>sentTo:
	Receiver: [(1485@392) mouseUp 1009420 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(470548480)
	Receiver's instance variables: 
		timeStamp: 	1009420
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1485@392)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1485@392) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1042022400) a GLMSys...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1485@392) mouseUp 1009420 nil]
		evt: 	[(1485@392) mouseUp 1009420 nil]
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1485@392) mouseUp 1009420 nil]
		evtBuf: 	#(1 1009420 1485 392 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1485@392) corner: (1501@408)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1485@392) corner: (1501@408)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1485@392) mouseOver nil nil]
		targetOffset: 	(136.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1009420 1485 392 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1009514
		lastStepMessage: 	nil
		lastCycleTime: 	1009514
		alarms: 	a Heap()
		lastAlarmTime: 	1009514
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1009514
		lastStepMessage: 	nil
		lastCycleTime: 	1009514
		alarms: 	a Heap()
		lastAlarmTime: 	1009514
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1009514
		lastStepMessage: 	nil
		lastCycleTime: 	1009514
		alarms: 	a Heap()
		lastAlarmTime: 	1009514
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1009514
		lastStepMessage: 	nil
		lastCycleTime: 	1009514
		alarms: 	a Heap()
		lastAlarmTime: 	1009514
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1042022400) a GLMSys...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
a := hideMenu selectedItems.
self halt ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 4:41:25.641618 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
a := hideMenu selectedItems.
self halt ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#(#('D' 'true') #('B' 'true') #('C' 'true'))
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems.
self halt ] ]
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(470548480))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(470548480)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		event: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		evt: 	[(1448@398) mouseUp 1028412 nil]
		all: 	an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424...etc...
		m: 	a PluggableButtonMorph(470548480)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		evt: 	[(1448@398) mouseUp 1028412 nil]
		all: 	an Array(a PluggableButtonMorph(470548480) a PluggableButtonMorph(64487424...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


MouseButtonEvent>>sentTo:
	Receiver: [(1448@398) mouseUp 1028412 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(470548480)
	Receiver's instance variables: 
		timeStamp: 	1028412
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1448@398)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(470548480)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(525336576)
		submorphs: 	an Array(an AlignmentMorph(279445504))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (537919488) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(361496576)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1448@398) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1042022400) a GLMSys...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		focusHolder: 	a PluggableButtonMorph(470548480)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1448@398) mouseUp 1028412 nil]
		evt: 	[(1448@398) mouseUp 1028412 nil]
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1448@398) mouseUp 1028412 nil]
		evtBuf: 	#(1 1028412 1448 398 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1448@398) corner: (1464@414)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1448@398) corner: (1464@414)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(470548480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1448@398) mouseOver nil nil]
		targetOffset: 	(99.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1028412 1448 398 0 0 0 1)
		lastKeyScanCode: 	255
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1028480
		lastStepMessage: 	nil
		lastCycleTime: 	1028480
		alarms: 	a Heap()
		lastAlarmTime: 	1028480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1028480
		lastStepMessage: 	nil
		lastCycleTime: 	1028480
		alarms: 	a Heap()
		lastAlarmTime: 	1028480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1028480
		lastStepMessage: 	nil
		lastCycleTime: 	1028480
		alarms: 	a Heap()
		lastAlarmTime: 	1028480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1028480
		lastStepMessage: 	nil
		lastCycleTime: 	1028480
		alarms: 	a Heap()
		lastAlarmTime: 	1028480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(1042022400) a GLMSys...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
a := hideMenu selectedItems.
self halt ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "a" is nil
26 November 2015 4:42:37.535621 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #a
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	a
		exception: 	MessageNotUnderstood: receiver of "a" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')).

...etc...
		itsSelection: 	a Text for 'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''tr...etc...
		itsSelectionString: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	a := #(#('D' 'true') #('B' 'true') #('C' 'true')).
	^ first a
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(901513216)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(371982336)
		submorphs: 	an Array(a RubPrimarySelectionMorph(708050944) a RubCursor(225968128...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (299892736) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(333709312)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(225968128)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(74973184))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1100288
		lastStepMessage: 	nil
		lastCycleTime: 	1100310
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1100288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1100288
		lastStepMessage: 	nil
		lastCycleTime: 	1100310
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1100288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	1100288
		lastStepMessage: 	nil
		lastCycleTime: 	1100310
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1100288
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #a
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "a" is nil
26 November 2015 4:42:48.909615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #a
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	a
		exception: 	MessageNotUnderstood: receiver of "a" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ first a
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1111670
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 
		anArgument: 	1111674
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1111670
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1111674
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111734
		lastStepMessage: 	nil
		lastCycleTime: 	1111734
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111734
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		now: 	1111674
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111734
		lastStepMessage: 	nil
		lastCycleTime: 	1111734
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111734
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111734
		lastStepMessage: 	nil
		lastCycleTime: 	1111734
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111734
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111754
		lastStepMessage: 	nil
		lastCycleTime: 	1111754
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111754
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	1111754
		lastStepMessage: 	nil
		lastCycleTime: 	1111754
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1111754
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #a
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "a" is nil
26 November 2015 4:43:11.405616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #a
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	a
		exception: 	MessageNotUnderstood: receiver of "a" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')).

...etc...
		itsSelection: 	a Text for 'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''tr...etc...
		itsSelectionString: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	a := #(#('D' 'true') #('B' 'true') #('C' 'true')).
	^ first a
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(901513216)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(371982336)
		submorphs: 	an Array(a RubPrimarySelectionMorph(708050944) a RubCursor(225968128...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (299892736) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(333709312)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(225968128)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(111411200))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SimpleBalloonMorph(46399488))(a Simp...etc...
		lastStepTime: 	1134178
		lastStepMessage: 	nil
		lastCycleTime: 	1134198
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1134178
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a SimpleBalloonMorph(46399488) a TaskbarMorph(984088576) a ...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SimpleBalloonMorph(46399488))(a Simp...etc...
		lastStepTime: 	1134178
		lastStepMessage: 	nil
		lastCycleTime: 	1134198
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1134178
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SimpleBalloonMorph(46399488))(a Simp...etc...
		lastStepTime: 	1134178
		lastStepMessage: 	nil
		lastCycleTime: 	1134198
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1134178
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a SimpleBalloonMorph(46399488) a TaskbarMorph(984088576) a ...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #a
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>elements
26 November 2015 4:49:48.091614 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>doesNotUnderstand: #elements
	Receiver: #(#('D' 'true') #('B' 'true') #('C' 'true'))
	Arguments and temporary variables: 
		aMessage: 	elements
		exception: 	MessageNotUnderstood: Array>>elements
		resumeValue: 	nil
	Receiver's instance variables: 
#(#('D' 'true') #('B' 'true') #('C' 'true'))

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')).

...etc...
		itsSelection: 	a Text for 'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''tr...etc...
		itsSelectionString: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	a := #(#('D' 'true') #('B' 'true') #('C' 'true')).
	b := OrderedColl...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(901513216)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (285@164)
		owner: 	a TransformWithLayoutMorph(371982336)
		submorphs: 	an Array(a RubPrimarySelectionMorph(951320576) a RubCursor(225968128...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (299892736) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(333709312)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(225968128)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(336592896))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1530872
		lastStepMessage: 	nil
		lastCycleTime: 	1530892
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1530872
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1530872
		lastStepMessage: 	nil
		lastCycleTime: 	1530892
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1530872
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1530872
		lastStepMessage: 	nil
		lastCycleTime: 	1530892
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1530872
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #elements
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>b
26 November 2015 4:50:08.395616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #b
	Receiver: [ :asd | b add: asd first ]
	Arguments and temporary variables: 
		aMessage: 	b
		exception: 	MessageNotUnderstood: BlockClosure>>b
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	53
		numArgs: 	1


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')).

...etc...
		itsSelection: 	a Text for 'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''tr...etc...
		itsSelectionString: 	'a:=#(#(''D'' ''true'') #(''B'' ''true'') #(''C'' ''true'')...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	a := #(#('D' 'true') #('B' 'true') #('C' 'true')).
	b := OrderedColl...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901513216)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(901513216)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (285@145)
		owner: 	a TransformWithLayoutMorph(371982336)
		submorphs: 	an Array(a RubPrimarySelectionMorph(951320576) a RubCursor(225968128...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (299892736) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(333709312)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(225968128)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(749207552))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(256114688)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1551172
		lastStepMessage: 	nil
		lastCycleTime: 	1551192
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1551172
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1551172
		lastStepMessage: 	nil
		lastCycleTime: 	1551192
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1551172
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#autoScroll: -> a RubEditingArea(901513216))(a Rub...etc...
		lastStepTime: 	1551172
		lastStepMessage: 	nil
		lastCycleTime: 	1551192
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(225968128)))
		lastAlarmTime: 	1551172
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(237502464) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #b
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>key
26 November 2015 4:52:00.363626 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Array(Object)>>doesNotUnderstand: #key
	Receiver: #('D' 'true')
	Arguments and temporary variables: 
		aMessage: 	key
		exception: 	MessageNotUnderstood: Array>>key
		resumeValue: 	nil
	Receiver's instance variables: 
#('D' 'true')

[ :item | item key ] in Array>>DoIt
	Receiver: #(#('D' 'true') #('B' 'true') #('C' 'true'))
	Arguments and temporary variables: 
		item: 	#('D' 'true')
	Receiver's instance variables: 
#(#('D' 'true') #('B' 'true') #('C' 'true'))

Array(SequenceableCollection)>>collect:
	Receiver: #(#('D' 'true') #('B' 'true') #('C' 'true'))
	Arguments and temporary variables: 
		aBlock: 	[ :item | item key ]
		newCollection: 	#(nil nil nil)
		index: 	1
	Receiver's instance variables: 
#(#('D' 'true') #('B' 'true') #('C' 'true'))

Array>>DoIt
	Receiver: #(#('D' 'true') #('B' 'true') #('C' 'true'))
	Arguments and temporary variables: 

	Receiver's instance variables: 
#(#('D' 'true') #('B' 'true') #('C' 'true'))

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ self collect: [ :item | item key ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	#(#('D' 'true') #('B' 'true') #('C' 'true'))
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	#(#('D' 'true') #('B' 'true') #('C' 'true'))
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(513015808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(513015808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(262144)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1663126
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 
		anArgument: 	1663136
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1663126
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1663136
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		now: 	1663136
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(220987392) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(316669952))(a SearchMorp...etc...
		lastStepTime: 	1663114
		lastStepMessage: 	nil
		lastCycleTime: 	1663166
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(989593600)))
		lastAlarmTime: 	1663114
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(220987392) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #key
[ :item | item key ] in Array>>DoIt
Array(SequenceableCollection)>>collect:
Array>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: HideWindow>>listChange:with:
26 November 2015 5:00:17.255619 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow(Object)>>doesNotUnderstand: #listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		aMessage: 	listChange: 'C' with: true
		exception: 	MessageNotUnderstood: HideWindow>>listChange:with:
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(11534336))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(11534336)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		event: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
		m: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


MouseButtonEvent>>sentTo:
	Receiver: [(1444@397) mouseUp 2160014 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		timeStamp: 	2160014
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1444@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseUp 2160014 nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1444@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(927727616) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseUp 2160014 nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseOver nil nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseOver nil nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		evt: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseOver nil nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		evtBuf: 	#(1 2160014 1444 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1444@397) corner: (1460@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1444@397) corner: (1460@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(11534336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1444@397) mouseOver nil nil]
		targetOffset: 	(95.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2160014 1444 397 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(853016576))(a DropList...etc...
		lastStepTime: 	2160106
		lastStepMessage: 	nil
		lastCycleTime: 	2160104
		alarms: 	a Heap()
		lastAlarmTime: 	2160106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(853016576))(a DropList...etc...
		lastStepTime: 	2160106
		lastStepMessage: 	nil
		lastCycleTime: 	2160104
		alarms: 	a Heap()
		lastAlarmTime: 	2160106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(853016576))(a DropList...etc...
		lastStepTime: 	2160106
		lastStepMessage: 	nil
		lastCycleTime: 	2160104
		alarms: 	a Heap()
		lastAlarmTime: 	2160106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(853016576))(a DropList...etc...
		lastStepTime: 	2160106
		lastStepMessage: 	nil
		lastCycleTime: 	2160104
		alarms: 	a Heap()
		lastAlarmTime: 	2160106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(927727616) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow(Object)>>doesNotUnderstand: #listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteString>>equals:
26 November 2015 5:00:56.159614 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ByteString(Object)>>doesNotUnderstand: #equals:
	Receiver: 'A'
	Arguments and temporary variables: 
		aMessage: 	equals: 'C'
		exception: 	MessageNotUnderstood: ByteString>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
'A'

[ :item | item objName equals: nameObj ] in HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	nil
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :item | item objName equals: nameObj ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(11534336))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(11534336)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		event: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
		m: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


MouseButtonEvent>>sentTo:
	Receiver: [(1444@397) mouseUp 2160014 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		timeStamp: 	2160014
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1444@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1444@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		evt: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		evtBuf: 	#(1 2160014 1444 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(738@388) corner: (754@404)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(738@388) corner: (754@404)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(908328960)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(738@388) mouseOver nil nil]
		targetOffset: 	(115.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2198950 738 388 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	2199056
		lastStepMessage: 	nil
		lastCycleTime: 	2199056
		alarms: 	a Heap()
		lastAlarmTime: 	2199056
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	2199056
		lastStepMessage: 	nil
		lastCycleTime: 	2199056
		alarms: 	a Heap()
		lastAlarmTime: 	2199056
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	2199056
		lastStepMessage: 	nil
		lastCycleTime: 	2199056
		alarms: 	a Heap()
		lastAlarmTime: 	2199056
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(767295488))(a SearchMorp...etc...
		lastStepTime: 	2199056
		lastStepMessage: 	nil
		lastCycleTime: 	2199056
		alarms: 	a Heap()
		lastAlarmTime: 	2199056
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #equals:
[ :item | item objName equals: nameObj ] in HideWindow>>listChange:with:
OrderedCollection>>select:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteString>>equals:
26 November 2015 5:01:46.119616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ByteString(Object)>>doesNotUnderstand: #equals:
	Receiver: 'A'
	Arguments and temporary variables: 
		aMessage: 	equals: 'C'
		exception: 	MessageNotUnderstood: ByteString>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
'A'

[ :item | item objName equals: nameObj ] in HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	nil
		item: 	a Node
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Node a Node a Node a Node)
	Arguments and temporary variables: 
		selectBlock: 	[ :item | item objName equals: nameObj ]
		newCollection: 	an OrderedCollection()
		element: 	a Node
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(11534336))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(11534336)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		event: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
		m: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


MouseButtonEvent>>sentTo:
	Receiver: [(1444@397) mouseUp 2160014 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		timeStamp: 	2160014
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1444@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1444@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		evt: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		evtBuf: 	#(1 2160014 1444 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(143@364) corner: (159@380)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(143@364) corner: (159@380)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(17301504)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(143@364) mouseOver nil nil]
		targetOffset: 	(75.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2248918 143 364 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(700973056))(a Spec...etc...
		lastStepTime: 	2248956
		lastStepMessage: 	nil
		lastCycleTime: 	2248950
		alarms: 	a Heap()
		lastAlarmTime: 	2248956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(700973056))(a Spec...etc...
		lastStepTime: 	2248956
		lastStepMessage: 	nil
		lastCycleTime: 	2248950
		alarms: 	a Heap()
		lastAlarmTime: 	2248956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(700973056))(a Spec...etc...
		lastStepTime: 	2248956
		lastStepMessage: 	nil
		lastCycleTime: 	2248950
		alarms: 	a Heap()
		lastAlarmTime: 	2248956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(700973056))(a Spec...etc...
		lastStepTime: 	2248956
		lastStepMessage: 	nil
		lastCycleTime: 	2248950
		alarms: 	a Heap()
		lastAlarmTime: 	2248956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #equals:
[ :item | item objName equals: nameObj ] in HideWindow>>listChange:with:
OrderedCollection>>select:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:02:13.35162 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	true
		temp: 	an OrderedCollection(a Node)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(11534336))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(11534336)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		event: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
		m: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		all: 	an Array(a PluggableButtonMorph(11534336) a PluggableButtonMorph(851181568...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


MouseButtonEvent>>sentTo:
	Receiver: [(1444@397) mouseUp 2160014 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(11534336)
	Receiver's instance variables: 
		timeStamp: 	2160014
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1444@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(11534336)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(238288896)
		submorphs: 	an Array(an AlignmentMorph(894173184))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (78905344) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(976224256)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1444@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		focusHolder: 	a PluggableButtonMorph(11534336)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1444@397) mouseUp 2160014 nil]
		evt: 	[(1444@397) mouseUp 2160014 nil]
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1444@397) mouseUp 2160014 nil]
		evtBuf: 	#(1 2160014 1444 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(193@372) corner: (209@388)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(193@372) corner: (209@388)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(760217600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(193@372) mouseOver nil nil]
		targetOffset: 	(124.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2276126 193 372 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(966787072))(a SearchMorp...etc...
		lastStepTime: 	2276208
		lastStepMessage: 	nil
		lastCycleTime: 	2276190
		alarms: 	a Heap()
		lastAlarmTime: 	2276208
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(966787072))(a SearchMorp...etc...
		lastStepTime: 	2276208
		lastStepMessage: 	nil
		lastCycleTime: 	2276190
		alarms: 	a Heap()
		lastAlarmTime: 	2276208
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(966787072))(a SearchMorp...etc...
		lastStepTime: 	2276208
		lastStepMessage: 	nil
		lastCycleTime: 	2276190
		alarms: 	a Heap()
		lastAlarmTime: 	2276208
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(966787072))(a SearchMorp...etc...
		lastStepTime: 	2276208
		lastStepMessage: 	nil
		lastCycleTime: 	2276190
		alarms: 	a Heap()
		lastAlarmTime: 	2276208
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(858259456) a Spe...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:07:40.807619 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	true
		temp: 	an OrderedCollection(a Node a Node a Node a Node)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('D')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: true ]
		index: 	1
	Receiver's instance variables: 
#('D')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('D')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Show' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(565444608))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(565444608)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		event: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		evt: 	[(1378@391) mouseUp 2603574 nil]
		all: 	an Array(a PluggableButtonMorph(565444608) a PluggableButtonMorph(62364057...etc...
		m: 	a PluggableButtonMorph(565444608)
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(565444608) a PluggableButtonMorph(623640576))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(565444608) a PluggableButtonMorph(623640576))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		evt: 	[(1378@391) mouseUp 2603574 nil]
		all: 	an Array(a PluggableButtonMorph(565444608) a PluggableButtonMorph(62364057...etc...
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


MouseButtonEvent>>sentTo:
	Receiver: [(1378@391) mouseUp 2603574 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(565444608)
	Receiver's instance variables: 
		timeStamp: 	2603574
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1378@391)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(565444608)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1349.0@383.0) corner: (1540.0@412.0)
		owner: 	a PanelMorph(312213504)
		submorphs: 	an Array(an AlignmentMorph(374341632))
		fullBounds: 	(1349@383) corner: (1540@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (632815616) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Show'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(456392704)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		focusHolder: 	a PluggableButtonMorph(565444608)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1378@391) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(664535040) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		focusHolder: 	a PluggableButtonMorph(565444608)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		focusHolder: 	a PluggableButtonMorph(565444608)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1378@391) mouseUp 2603574 nil]
		evt: 	[(1378@391) mouseUp 2603574 nil]
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1378@391) mouseUp 2603574 nil]
		evtBuf: 	#(1 2603574 1378 391 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1378@391) corner: (1394@407)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1378@391) corner: (1394@407)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(565444608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1378@391) mouseOver nil nil]
		targetOffset: 	(29.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2603574 1378 391 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 358350848))(3...etc...
		lastStepTime: 	2603660
		lastStepMessage: 	nil
		lastCycleTime: 	2603660
		alarms: 	a Heap()
		lastAlarmTime: 	2603660
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 358350848))(3...etc...
		lastStepTime: 	2603660
		lastStepMessage: 	nil
		lastCycleTime: 	2603660
		alarms: 	a Heap()
		lastAlarmTime: 	2603660
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 358350848))(3...etc...
		lastStepTime: 	2603660
		lastStepMessage: 	nil
		lastCycleTime: 	2603660
		alarms: 	a Heap()
		lastAlarmTime: 	2603660
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 358350848))(3...etc...
		lastStepTime: 	2603660
		lastStepMessage: 	nil
		lastCycleTime: 	2603660
		alarms: 	a Heap()
		lastAlarmTime: 	2603660
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(664535040) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: true ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:09:03.341615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'D'
		value: 	false
		temp: 	an OrderedCollection(a Node a Node a Node a Node)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('D')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('D')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('D')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(599261184))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(599261184)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		event: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		evt: 	[(1244@397) mouseUp 2686102 nil]
		all: 	an Array(a PluggableButtonMorph(973602816) a PluggableButtonMorph(59926118...etc...
		m: 	a PluggableButtonMorph(599261184)
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(973602816) a PluggableButtonMorph(599261184))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(973602816) a PluggableButtonMorph(599261184))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		evt: 	[(1244@397) mouseUp 2686102 nil]
		all: 	an Array(a PluggableButtonMorph(973602816) a PluggableButtonMorph(59926118...etc...
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


MouseButtonEvent>>sentTo:
	Receiver: [(1244@397) mouseUp 2686102 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(599261184)
	Receiver's instance variables: 
		timeStamp: 	2686102
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1244@397)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(599261184)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1150.0@383.0) corner: (1345.0@412.0)
		owner: 	a PanelMorph(1060110336)
		submorphs: 	an Array(an AlignmentMorph(408158208))
		fullBounds: 	(1150@383) corner: (1345@412)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (666632192) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(490209280)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		focusHolder: 	a PluggableButtonMorph(599261184)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1244@397) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(471597056) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		focusHolder: 	a PluggableButtonMorph(599261184)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		focusHolder: 	a PluggableButtonMorph(599261184)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1244@397) mouseUp 2686102 nil]
		evt: 	[(1244@397) mouseUp 2686102 nil]
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1244@397) mouseUp 2686102 nil]
		evtBuf: 	#(1 2686102 1244 397 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1244@397) corner: (1260@413)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1244@397) corner: (1260@413)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(599261184)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1244@397) mouseOver nil nil]
		targetOffset: 	(94.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2686102 1244 397 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2686184
		lastStepMessage: 	nil
		lastCycleTime: 	2686184
		alarms: 	a Heap()
		lastAlarmTime: 	2686184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2686184
		lastStepMessage: 	nil
		lastCycleTime: 	2686184
		alarms: 	a Heap()
		lastAlarmTime: 	2686184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2686184
		lastStepMessage: 	nil
		lastCycleTime: 	2686184
		alarms: 	a Heap()
		lastAlarmTime: 	2686184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2686184
		lastStepMessage: 	nil
		lastCycleTime: 	2686184
		alarms: 	a Heap()
		lastAlarmTime: 	2686184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(471597056) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:10:43.325616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
		temp: 	an OrderedCollection(a Node a Node a Node a Node)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(186646528))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(186646528)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		event: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		evt: 	[(733@345) mouseUp 2786086 nil]
		all: 	an Array(a PluggableButtonMorph(573833216) a PluggableButtonMorph(18664652...etc...
		m: 	a PluggableButtonMorph(186646528)
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(573833216) a PluggableButtonMorph(186646528))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(573833216) a PluggableButtonMorph(186646528))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		evt: 	[(733@345) mouseUp 2786086 nil]
		all: 	an Array(a PluggableButtonMorph(573833216) a PluggableButtonMorph(18664652...etc...
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


MouseButtonEvent>>sentTo:
	Receiver: [(733@345) mouseUp 2786086 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(186646528)
	Receiver's instance variables: 
		timeStamp: 	2786086
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(733@345)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(186646528)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(613.0@319.0) corner: (808.0@348.0)
		owner: 	a PanelMorph(647495680)
		submorphs: 	an Array(an AlignmentMorph(1063256064))
		fullBounds: 	(613@319) corner: (808@348)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (254017536) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(71565312)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		focusHolder: 	a PluggableButtonMorph(186646528)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(733@345) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(410255360) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		focusHolder: 	a PluggableButtonMorph(186646528)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		focusHolder: 	a PluggableButtonMorph(186646528)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(733@345) mouseUp 2786086 nil]
		evt: 	[(733@345) mouseUp 2786086 nil]
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(733@345) mouseUp 2786086 nil]
		evtBuf: 	#(1 2786086 733 345 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(733@345) corner: (749@361)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(733@345) corner: (749@361)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(186646528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(733@345) mouseOver nil nil]
		targetOffset: 	(120.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2786086 733 345 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2786160
		lastStepMessage: 	nil
		lastCycleTime: 	2786160
		alarms: 	a Heap()
		lastAlarmTime: 	2786160
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2786160
		lastStepMessage: 	nil
		lastCycleTime: 	2786160
		alarms: 	a Heap()
		lastAlarmTime: 	2786160
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2786160
		lastStepMessage: 	nil
		lastCycleTime: 	2786160
		alarms: 	a Heap()
		lastAlarmTime: 	2786160
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(892338176))(a DropList...etc...
		lastStepTime: 	2786160
		lastStepMessage: 	nil
		lastCycleTime: 	2786160
		alarms: 	a Heap()
		lastAlarmTime: 	2786160
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(410255360) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>self
26 November 2015 5:29:45.025616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure(Object)>>doesNotUnderstand: #self
	Receiver: [ :el | self halt ]
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: BlockClosure>>self
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializePresenter
		startpc: 	35
		numArgs: 	1


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow(ComposableModel)>>initialize
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initialize
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow class(Behavior)>>new
	Receiver: RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ComposableModel
		methodDict: 	a MethodDictionary(#data->RQTGMainWindow>>#data #data:->RQTGMainWin...etc...
		format: 	176
		layout: 	a FixedLayout
		instanceVariables: 	#(#refreshButton #showData #showName #hideNodes #hideTopics ...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RQTGMainWindow
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


TestingGraph>>testMainWindow1
	Receiver: a TestingGraph
	Arguments and temporary variables: 
		nodeA: 	a Node
		nodeB: 	a Node
		nodeC: 	a Node
		nodeD: 	a Node
		topic1: 	a Topic
		topic2: 	a Topic
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		graph: 	nil
	Receiver's instance variables: 
a TestingGraph

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"KeymapBrowser new openWithSpec."
TestingGraph new testMainWin...etc...
		itsSelection: 	a Text for '"KeymapBrowser new openWithSpec."
TestingGraph new te...etc...
		itsSelectionString: 	'"KeymapBrowser new openWithSpec."
TestingGraph new testMai...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(944504832)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (272@601)
		owner: 	a TransformWithLayoutMorph(451149824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(434896896) a RubCursor(317194240...etc...
		fullBounds: 	(0@0) corner: (272@601)
		color: 	Color transparent
		extension: 	a MorphExtension (348913664) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(412876800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(317194240)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(22020096))
		getMenuPolicy: 	a RubEditingArea(944504832)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	3927856
		lastStepMessage: 	nil
		lastCycleTime: 	3927856
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	3927856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1016594432) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	3927856
		lastStepMessage: 	nil
		lastCycleTime: 	3927856
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	3927856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	3927856
		lastStepMessage: 	nil
		lastCycleTime: 	3927856
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(317194240)))
		lastAlarmTime: 	3927856
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1016594432) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #self
RQTGMainWindow>>initializePresenter
RQTGMainWindow(ComposableModel)>>initialize
RQTGMainWindow>>initialize
RQTGMainWindow class(Behavior)>>new
TestingGraph>>testMainWindow1
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: OrderedCollection>>whenChangedDo:
26 November 2015 5:30:00.071621 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

OrderedCollection(Object)>>doesNotUnderstand: #whenChangedDo:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aMessage: 	whenChangedDo: [ :el | self halt ]
		exception: 	MessageNotUnderstood: OrderedCollection>>whenChangedDo:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow(ComposableModel)>>initialize
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initialize
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow class(Behavior)>>new
	Receiver: RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ComposableModel
		methodDict: 	a MethodDictionary(#data->RQTGMainWindow>>#data #data:->RQTGMainWin...etc...
		format: 	176
		layout: 	a FixedLayout
		instanceVariables: 	#(#refreshButton #showData #showName #hideNodes #hideTopics ...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RQTGMainWindow
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


TestingGraph>>testMainWindow1
	Receiver: a TestingGraph
	Arguments and temporary variables: 
		nodeA: 	a Node
		nodeB: 	a Node
		nodeC: 	a Node
		nodeD: 	a Node
		topic1: 	a Topic
		topic2: 	a Topic
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node)
		graph: 	nil
	Receiver's instance variables: 
a TestingGraph

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'"KeymapBrowser new openWithSpec."
TestingGraph new testMainWin...etc...
		itsSelection: 	a Text for '"KeymapBrowser new openWithSpec."
TestingGraph new te...etc...
		itsSelectionString: 	'"KeymapBrowser new openWithSpec."
TestingGraph new testMai...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(944504832)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(944504832)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (272@601)
		owner: 	a TransformWithLayoutMorph(451149824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(434896896) a RubCursor(317194240...etc...
		fullBounds: 	(0@0) corner: (272@601)
		color: 	Color transparent
		extension: 	a MorphExtension (348913664) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(412876800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(317194240)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(22020096))
		getMenuPolicy: 	a RubEditingArea(944504832)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(329252864)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	3942846
		lastStepMessage: 	nil
		lastCycleTime: 	3942866
		alarms: 	a Heap()
		lastAlarmTime: 	3942846
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(314310656) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	3942846
		lastStepMessage: 	nil
		lastCycleTime: 	3942866
		alarms: 	a Heap()
		lastAlarmTime: 	3942846
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(202637312))(a DropList...etc...
		lastStepTime: 	3942846
		lastStepMessage: 	nil
		lastCycleTime: 	3942866
		alarms: 	a Heap()
		lastAlarmTime: 	3942846
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(314310656) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
OrderedCollection(Object)>>doesNotUnderstand: #whenChangedDo:
RQTGMainWindow>>initializePresenter
RQTGMainWindow(ComposableModel)>>initialize
RQTGMainWindow>>initialize
RQTGMainWindow class(Behavior)>>new
TestingGraph>>testMainWindow1
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
26 November 2015 5:31:01.737613 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow


RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection()
		hide: 	a HideWindow



--- The full stack ---
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
RQTGMainWindow>>initializePresenter
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
26 November 2015 5:31:36.905615 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RQTGMainWindow>>listChange:with:
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		refreshButton: 	a ButtonModel
		showData: 	a CheckBoxModel
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node)
		hide: 	a HideWindow


HideWindow>>listChange:with:
	Receiver: a HideWindow
	Arguments and temporary variables: 
		nameObj: 	'C'
		value: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


Array(SequenceableCollection)>>do:
	Receiver: #('C')
	Arguments and temporary variables: 
		aBlock: 	[ :ele | self listChange: ele with: false ]
		index: 	1
	Receiver's instance variables: 
#('C')

[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
	Receiver: a HideWindow
	Arguments and temporary variables: 
		a: 	#('C')
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo/NodesAndTopics' ]
		list: 	an OrderedCollection(a Node a Node a Node a Node)
		labelSearch: 	a LabelModel
		search: 	a TextInputFieldModel
		hideMenu: 	a MultiColumnListModel
		clearSearchButton: 	a ButtonModel
		hideButton: 	a ButtonModel
		showButton: 	a ButtonModel
		mainWindow: 	a RQTGMainWindow


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a HideWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
a := hideMenu selectedItems collect: [ :item...etc...
		labelHolder: 	a CollectionValueHolder[ 'Hide' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(59768832))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(59768832)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		event: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		evt: 	[(1313@532) mouseUp 4039676 nil]
		all: 	an Array(a PluggableButtonMorph(19660800) a PluggableButtonMorph(59768832)...etc...
		m: 	a PluggableButtonMorph(59768832)
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(19660800) a PluggableButtonMorph(59768832))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(19660800) a PluggableButtonMorph(59768832))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		evt: 	[(1313@532) mouseUp 4039676 nil]
		all: 	an Array(a PluggableButtonMorph(19660800) a PluggableButtonMorph(59768832)...etc...
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


MouseButtonEvent>>sentTo:
	Receiver: [(1313@532) mouseUp 4039676 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(59768832)
	Receiver's instance variables: 
		timeStamp: 	4039676
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1313@532)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(59768832)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1211.0@512.0) corner: (1406.0@541.0)
		owner: 	a PanelMorph(822083584)
		submorphs: 	an Array(an AlignmentMorph(882114560))
		fullBounds: 	(1211@512) corner: (1406@541)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (127139840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Hide'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(964165632)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		focusHolder: 	a PluggableButtonMorph(59768832)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(1313@532) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(11010048) a SpecWind...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		focusHolder: 	a PluggableButtonMorph(59768832)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		focusHolder: 	a PluggableButtonMorph(59768832)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(1313@532) mouseUp 4039676 nil]
		evt: 	[(1313@532) mouseUp 4039676 nil]
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(1313@532) mouseUp 4039676 nil]
		evtBuf: 	#(1 4039676 1313 532 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1313@532) corner: (1329@548)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1313@532) corner: (1329@548)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(59768832)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1313@532) mouseOver nil nil]
		targetOffset: 	(102.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4039676 1313 532 0 0 0 1)
		lastKeyScanCode: 	46
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	4039740
		lastStepMessage: 	nil
		lastCycleTime: 	4039740
		alarms: 	a Heap()
		lastAlarmTime: 	4039740
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	4039740
		lastStepMessage: 	nil
		lastCycleTime: 	4039740
		alarms: 	a Heap()
		lastAlarmTime: 	4039740
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	4039740
		lastStepMessage: 	nil
		lastCycleTime: 	4039740
		alarms: 	a Heap()
		lastAlarmTime: 	4039740
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(121110528))(a SearchMorp...etc...
		lastStepTime: 	4039740
		lastStepMessage: 	nil
		lastCycleTime: 	4039740
		alarms: 	a Heap()
		lastAlarmTime: 	4039740
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(11010048) a SpecWind...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
RQTGMainWindow>>listChange:with:
HideWindow>>listChange:with:
[ :ele | self listChange: ele with: false ] in [ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
Array(SequenceableCollection)>>do:
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ] ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "withUrl:" is nil
8 December 2015 4:19:22.690612 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

UndefinedObject(Object)>>doesNotUnderstand: #withUrl:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	withUrl: 'http://localhost:11311'
		exception: 	MessageNotUnderstood: receiver of "withUrl:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Adapter>>getInfoNode
	Receiver: an Adapter
	Arguments and temporary variables: 
		proxy: 	nil
		systemState: 	nil
	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


Adapter>>getData
	Receiver: an Adapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		topics: 	an OrderedCollection()
		nodes: 	an OrderedCollection()


PhaRos>>initialize
	Receiver: a PhaRos
	Arguments and temporary variables: 
		nodeArray: 	nil
		graph: 	nil
	Receiver's instance variables: 
a PhaRos

PhaRos class(Behavior)>>new
	Receiver: PhaRos
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#initialize->PhaRos>>#initialize )
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PhaRos
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'PhaRos new.'
		itsSelection: 	a Text for 'PhaRos new.'
		itsSelectionString: 	'PhaRos new.'
	Receiver's instance variables: 
		ast: 	DoIt
	^ PhaRos new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(682098688)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(682098688)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(445382656)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(682098688)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(567279616)
		submorphs: 	an Array(a RubPrimarySelectionMorph(227278848) a RubCursor(910688256...etc...
		fullBounds: 	(0@0) corner: (580@31)
		color: 	Color transparent
		extension: 	a MorphExtension (1002700800) [other:  (announcer -> an Announcer) (...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(529006592)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(910688256)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(893386752))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(445382656)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(358350848))(a DropList...etc...
		lastStepTime: 	359033
		lastStepMessage: 	nil
		lastCycleTime: 	359033
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(910688256)))
		lastAlarmTime: 	359033
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(686555136) a Sy...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(358350848))(a DropList...etc...
		lastStepTime: 	359033
		lastStepMessage: 	nil
		lastCycleTime: 	359033
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(910688256)))
		lastAlarmTime: 	359033
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(358350848))(a DropList...etc...
		lastStepTime: 	359033
		lastStepMessage: 	nil
		lastCycleTime: 	359033
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(910688256)))
		lastAlarmTime: 	359033
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(686555136) a Sy...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #withUrl:
Adapter>>getInfoNode
Adapter>>getData
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Assertion failed
8 December 2015 4:23:19.066606 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

BlockClosure>>assert
	Receiver: [ anEdge class == RTEdge ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	RTElement>>addConnectedEdge:
		startpc: 	38
		numArgs: 	0


RTElement>>addConnectedEdge:
	Receiver: a RTElement
	Arguments and temporary variables: 
		anEdge: 	a RQTEdge
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TREllipseShape
		view: 	a RTViewForSpec
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RQTEdge(RTEdge)>>from:
	Receiver: a RQTEdge
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTNoShape
		trachelShape: 	a TRNoShape
		view: 	nil
		from: 	a RTElement
		to: 	nil
		shouldBeUsedInLayout: 	true
		topic: 	nil


RQTEdge(RTEdge)>>from:to:
	Receiver: a RQTEdge
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElement: 	a RTElement
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node->a Node
		shape: 	a RTNoShape
		trachelShape: 	a TRNoShape
		view: 	nil
		from: 	a RTElement
		to: 	nil
		shouldBeUsedInLayout: 	true
		topic: 	nil


RQTEdge class(RTEdge class)>>on:from:to:
	Receiver: RQTEdge
	Arguments and temporary variables: 
		aModel: 	a Node->a Node
		fromElement: 	a RTElement
		toElement: 	a RTElement
	Receiver's instance variables: 
		superclass: 	RTEdge
		methodDict: 	a MethodDictionary(#initialize->RQTEdge>>#initialize #topic->RQTEdg...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#(#topic)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RQTEdge
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


RQTEdge class(RTEdge class)>>from:to:
	Receiver: RQTEdge
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElement: 	a RTElement
	Receiver's instance variables: 
		superclass: 	RTEdge
		methodDict: 	a MethodDictionary(#initialize->RQTEdge>>#initialize #topic->RQTEdg...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#(#topic)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RQTEdge
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RQT-Pharo'
		traitComposition: 	{}
		localSelectors: 	nil


RQTArrowedLine>>edgeFrom:to:
	Receiver: a RQTArrowedLine
	Arguments and temporary variables: 
		el1: 	a RTElement
		el2: 	a RTElement
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		width: 	1
		attachPoint: 	a RTCenteredAttachPoint
		line: 	a RTLine
		head: 	a RTSimpleArrowHead


RTEdgeBuilder(RTBuilder)>>edgeFrom:to:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		source: 	a RTElement
		target: 	a RTElement
		newEdge: 	nil
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RQTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	true
		shouldNotBeUsedInLayout: 	true


RTEdgeBuilder>>edgeFrom:to:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		source: 	a RTElement
		target: 	a RTElement
		edge: 	nil
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RQTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	true
		shouldNotBeUsedInLayout: 	true


[ :toE | edges add: (self edgeFrom: fromElement to: toE) ] in [ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self nodesSubscribedTo: sub ]
		edges: 	a RTGroup()
		e: 	a RTElement
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		toE: 	a RTElement
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RQTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	true
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Arguments and temporary variables: 
		aBlock: 	[ :toE | edges add: (self edgeFrom: fromElement to: toE) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	4
		attributes: 	nil


[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self nodesSubscribedTo: sub ]
		edges: 	a RTGroup()
		e: 	a RTElement
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RQTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	true
		shouldNotBeUsedInLayout: 	true


RTGroup(OrderedCollection)>>do:
	Receiver: a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a RTElement a RTElem...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtVa...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a RTElement a RTElement a RTElement a RTElement a RTElement a R...etc...
		firstIndex: 	1
		lastIndex: 	13
		attributes: 	nil


RTEdgeBuilder>>connectFrom:toAll:
	Receiver: a RTEdgeBuilder
	Arguments and temporary variables: 
		fromElement: 	a RTElement
		toElements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		aFromBlock: 	[ :publisher | publisher ]
		aBlockOrASymbol: 	[ :sub | self nodesSubscribedTo: sub ]
		edges: 	a RTGroup()
	Receiver's instance variables: 
		view: 	a RTViewForSpec
		interactionBuilder: 	a RTInteractionBuilder
		shapeBuilder: 	a RQTArrowedLine
		layoutBuilder: 	nil
		title: 	'Roassal'
		metricNormalizer: 	nil
		allowRepetition: 	false
		elements: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement...etc...
		elementsToLookup: 	nil
		shouldMoveBehind: 	true
		shouldNotBeUsedInLayout: 	true


Graph>>connectNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(867696640)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(867696640)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
BlockClosure>>assert
RTElement>>addConnectedEdge:
RQTEdge(RTEdge)>>from:
RQTEdge(RTEdge)>>from:to:
RQTEdge class(RTEdge class)>>on:from:to:
RQTEdge class(RTEdge class)>>from:to:
RQTArrowedLine>>edgeFrom:to:
RTEdgeBuilder(RTBuilder)>>edgeFrom:to:
RTEdgeBuilder>>edgeFrom:to:
[ :toE | edges add: (self edgeFrom: fromElement to: toE) ] in [ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
[ :e | 
fromElement := self elements elementFromModel: (aFromBlock rtValue: e model).
toElements := self elementsToLookup elementsFromModels: (aBlockOrASymbol rtValue: e model).
toElements ifNotNil: [ toElements do: [ :toE | edges add: (self edgeFrom: fromElement to: toE) ] ] ] in RTEdgeBuilder>>connectFrom:toAll:
RTGroup(OrderedCollection)>>do:
RTEdgeBuilder>>connectFrom:toAll:
Graph>>connectNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Warning
8 December 2015 5:17:58.092616 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

AioEventHandler class(Object)>>notify:
	Receiver: AioEventHandler
	Arguments and temporary variables: 
		aString: 	'AioPlugin not present, AioEventHandler will use polling input'
	Receiver's instance variables: 
		superclass: 	Model
		methodDict: 	a MethodDictionary(#aioDisable:->AioEventHandler>>#aioDisable: #aio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#semaphore #semaIndex #handlerProc #descriptor)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AioEventHandler
		classPool: 	a Dictionary(#AioPluginPresent->false )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OSProcess-AIO'
		traitComposition: 	{}
		localSelectors: 	nil


AioEventHandler class>>aioPluginPresent
	Receiver: AioEventHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Model
		methodDict: 	a MethodDictionary(#aioDisable:->AioEventHandler>>#aioDisable: #aio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#semaphore #semaIndex #handlerProc #descriptor)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AioEventHandler
		classPool: 	a Dictionary(#AioPluginPresent->false )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OSProcess-AIO'
		traitComposition: 	{}
		localSelectors: 	nil


BufferedAsyncFileReadStream(AsyncFileReadStream)>>enableEventHandling
	Receiver: BufferedAsyncFileReadStream: 'pipeReader'
	Arguments and temporary variables: 

	Receiver's instance variables: 



BufferedAsyncFileReadStream(AsyncFileReadStream)>>initialize
	Receiver: BufferedAsyncFileReadStream: 'pipeReader'
	Arguments and temporary variables: 

	Receiver's instance variables: 



BufferedAsyncFileReadStream class(AttachableFileStream class)>>name:attachTo:writable:
	Receiver: BufferedAsyncFileReadStream
	Arguments and temporary variables: 
		aSymbolOrString: 	'pipeReader'
		anIOHandle: 	#[142 86 183 115 240 140 64 9 0 0 0 0 0 0 0 0]
		readWriteFlag: 	false
	Receiver's instance variables: 
		superclass: 	AsyncFileReadStream
		methodDict: 	a MethodDictionary(#actAsExecutor->BufferedAsyncFileReadStream>>#ac...etc...
		format: 	158
		layout: 	a FixedLayout
		instanceVariables: 	#(#nonBlockingMode #readBuffer #readSyncSemaphore #dataAvail...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#BufferedAsyncFileReadStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OSProcess-Base'
		traitComposition: 	{}
		localSelectors: 	nil


AttachableFileStream>>asBufferedAsyncFileReadStream
	Receiver: AttachableFileStream: 'pipeReader'
	Arguments and temporary variables: 

	Receiver's instance variables: 



ExternalPipe>>setBufferedReader
	Receiver: an ExternalPipe
	Arguments and temporary variables: 

	Receiver's instance variables: 
		writer: 	AttachableFileStream: 'pipeWriter'
		reader: 	AttachableFileStream: 'pipeReader'
		blocking: 	true


PipeableOSProcess class>>command:environment:workingDir:input:output:error:errorPipelineStream:shellSyntax:
	Receiver: PipeableOSProcess
	Arguments and temporary variables: 
		aString: 	'rostopic echo /turtle1/cmd_vel __name:=echoManager'
		anEnvironmentDictionary: 	nil
		pathString: 	nil
		inputStream: 	nil
		outputStream: 	nil
		errorStream: 	nil
		anErrorWriteStream: 	nil
		aSyntaxProcessor: 	nil
		p: 	a PipeableOSProcess on an ExternalUnixOSProcess with pid nil on /bin/sh (not...etc...
	Receiver's instance variables: 
		superclass: 	PipeJunction
		methodDict: 	a MethodDictionary(#addToErrorPipeline:->PipeableOSProcess>>#addToE...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#pipeFromError #processProxy #keepInitialStdOutOpen #keepI...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PipeableOSProcess
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CommandShell-Piping'
		traitComposition: 	{}
		localSelectors: 	nil


PipeableOSProcess class>>command:environment:workingDir:input:output:error:errorPipelineStream:
	Receiver: PipeableOSProcess
	Arguments and temporary variables: 
		aString: 	'rostopic echo /turtle1/cmd_vel __name:=echoManager'
		anEnvironmentDictionary: 	nil
		pathString: 	nil
		inputStream: 	nil
		outputStream: 	nil
		errorStream: 	nil
		anErrorWriteStream: 	nil
	Receiver's instance variables: 
		superclass: 	PipeJunction
		methodDict: 	a MethodDictionary(#addToErrorPipeline:->PipeableOSProcess>>#addToE...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#pipeFromError #processProxy #keepInitialStdOutOpen #keepI...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PipeableOSProcess
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CommandShell-Piping'
		traitComposition: 	{}
		localSelectors: 	nil


PipeableOSProcess class>>command:
	Receiver: PipeableOSProcess
	Arguments and temporary variables: 
		aString: 	'rostopic echo /turtle1/cmd_vel __name:=echoManager'
	Receiver's instance variables: 
		superclass: 	PipeJunction
		methodDict: 	a MethodDictionary(#addToErrorPipeline:->PipeableOSProcess>>#addToE...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#pipeFromError #processProxy #keepInitialStdOutOpen #keepI...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PipeableOSProcess
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CommandShell-Piping'
		traitComposition: 	{}
		localSelectors: 	nil


ROSAPI>>echoProcessOfTopic:named:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		aTopic: 	'/turtle1/cmd_vel'
		aName: 	'echoManager'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil


[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ process := self echoProcessOfTopic: aTopic named: 'echoManager' ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ROSAPI>>echoTopic:
		startpc: 	109
		numArgs: 	0



--- The full stack ---
AioEventHandler class(Object)>>notify:
AioEventHandler class>>aioPluginPresent
BufferedAsyncFileReadStream(AsyncFileReadStream)>>enableEventHandling
BufferedAsyncFileReadStream(AsyncFileReadStream)>>initialize
BufferedAsyncFileReadStream class(AttachableFileStream class)>>name:attachTo:writable:
AttachableFileStream>>asBufferedAsyncFileReadStream
ExternalPipe>>setBufferedReader
PipeableOSProcess class>>command:environment:workingDir:input:output:error:errorPipelineStream:shellSyntax:
PipeableOSProcess class>>command:environment:workingDir:input:output:error:errorPipelineStream:
PipeableOSProcess class>>command:
ROSAPI>>echoProcessOfTopic:named:
[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
8 December 2015 5:18:05.030607 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		cr2: 	''
		isFirst: 	true
		cr3: 	''
		cr1: 	''
		helperString: 	''
		aTopic: 	'/turtle1/cmd_vel'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in SpecDebugger class>>openContext:label:contents:
		lastMsg: 	nil
		thread2: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelection: 	a Text for 'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelectionString: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
	Receiver's instance variables: 
		ast: 	DoIt
	^ ROSAPI new echoTopic: '/turtle1/cmd_vel'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(41156608)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(41156608)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(559939584)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(41156608)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(681836544)
		submorphs: 	an Array(a RubPrimarySelectionMorph(613941248) a RubCursor(475529216...etc...
		fullBounds: 	(0@0) corner: (580@31)
		color: 	Color transparent
		extension: 	a MorphExtension (519307264) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(643563520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(475529216)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(179830784))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(559939584)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(155451392))(a DropList...etc...
		lastStepTime: 	3874409
		lastStepMessage: 	nil
		lastCycleTime: 	3874429
		alarms: 	a Heap()
		lastAlarmTime: 	3874409
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(411041792) a GLMSyst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(155451392))(a DropList...etc...
		lastStepTime: 	3874409
		lastStepMessage: 	nil
		lastCycleTime: 	3874429
		alarms: 	a Heap()
		lastAlarmTime: 	3874409
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(155451392))(a DropList...etc...
		lastStepTime: 	3874409
		lastStepMessage: 	nil
		lastCycleTime: 	3874429
		alarms: 	a Heap()
		lastAlarmTime: 	3874409
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(411041792) a GLMSyst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:18:40.744606 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		cr2: 	''
		isFirst: 	true
		cr3: 	''
		cr1: 	''
		helperString: 	''
		aTopic: 	'/turtle1/cmd_vel'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in [ 
self value.
Processor terminateActive ] in BlockClosure...etc...
		lastMsg: 	nil
		thread2: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelection: 	a Text for 'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelectionString: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
	Receiver's instance variables: 
		ast: 	DoIt
	^ ROSAPI new echoTopic: '/turtle1/cmd_vel'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(41156608)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(41156608)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(559939584)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(41156608)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(681836544)
		submorphs: 	an Array(a RubPrimarySelectionMorph(613941248) a RubCursor(475529216...etc...
		fullBounds: 	(0@0) corner: (580@31)
		color: 	Color transparent
		extension: 	a MorphExtension (519307264) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(643563520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(475529216)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(179830784))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(559939584)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	3917071
		lastStepMessage: 	nil
		lastCycleTime: 	3917093
		alarms: 	a Heap()
		lastAlarmTime: 	3917071
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(774897664) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	3917071
		lastStepMessage: 	nil
		lastCycleTime: 	3917093
		alarms: 	a Heap()
		lastAlarmTime: 	3917071
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	3917071
		lastStepMessage: 	nil
		lastCycleTime: 	3917093
		alarms: 	a Heap()
		lastAlarmTime: 	3917071
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(774897664) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:20:47.350818 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		cr2: 	''
		isFirst: 	true
		cr3: 	''
		cr1: 	''
		helperString: 	''
		aTopic: 	'/turtle1/cmd_vel'
	Receiver's instance variables: 
		process: 	a PipeableOSProcess on an ExternalUnixOSProcess with pid 27981 on /bin...etc...
		thread: 	a Process in [ 
self value.
Processor terminateActive ] in BlockClosure...etc...
		lastMsg: 	nil
		thread2: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelection: 	a Text for 'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelectionString: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
	Receiver's instance variables: 
		ast: 	DoIt
	^ ROSAPI new echoTopic: '/turtle1/cmd_vel'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(41156608)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(41156608)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(559939584)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(41156608)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(681836544)
		submorphs: 	an Array(a RubPrimarySelectionMorph(613941248) a RubCursor(475529216...etc...
		fullBounds: 	(0@0) corner: (580@31)
		color: 	Color transparent
		extension: 	a MorphExtension (519307264) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(643563520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(475529216)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(179830784))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(559939584)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	4043677
		lastStepMessage: 	nil
		lastCycleTime: 	4043699
		alarms: 	a Heap()
		lastAlarmTime: 	4043677
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(835190784) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	4043677
		lastStepMessage: 	nil
		lastCycleTime: 	4043699
		alarms: 	a Heap()
		lastAlarmTime: 	4043677
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	4043677
		lastStepMessage: 	nil
		lastCycleTime: 	4043699
		alarms: 	a Heap()
		lastAlarmTime: 	4043677
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(835190784) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:21:38.421254 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		cr2: 	''
		isFirst: 	true
		cr3: 	''
		cr1: 	''
		helperString: 	''
		aTopic: 	'/turtle1/cmd_vel'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in [ 
self value.
Processor terminateActive ] in BlockClosure...etc...
		lastMsg: 	nil
		thread2: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'(ROSAPI new echoTopic: ''/turtle1/cmd_vel'') inspect.'
		itsSelection: 	a Text for '(ROSAPI new echoTopic: ''/turtle1/cmd_vel'') inspect....etc...
		itsSelectionString: 	'(ROSAPI new echoTopic: ''/turtle1/cmd_vel'') inspect.'
	Receiver's instance variables: 
		ast: 	DoIt
	^ (ROSAPI new echoTopic: '/turtle1/cmd_vel') inspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(41156608)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(41156608)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(559939584)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(41156608)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (285@50)
		owner: 	a TransformWithLayoutMorph(681836544)
		submorphs: 	an Array(a RubPrimarySelectionMorph(613941248) a RubCursor(475529216...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (519307264) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(643563520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(475529216)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(397410304))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(559939584)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	4094653
		lastStepMessage: 	nil
		lastCycleTime: 	4094765
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(475529216)))
		lastAlarmTime: 	4094653
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(367001600) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	4094653
		lastStepMessage: 	nil
		lastCycleTime: 	4094765
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(475529216)))
		lastAlarmTime: 	4094653
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	4094653
		lastStepMessage: 	nil
		lastCycleTime: 	4094765
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(475529216)))
		lastAlarmTime: 	4094653
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(367001600) a Sp...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Warning
8 December 2015 5:29:25.12245 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

AioEventHandler class(Object)>>notify:
	Receiver: AioEventHandler
	Arguments and temporary variables: 
		aString: 	'AioPlugin not present, AioEventHandler will use polling input'
	Receiver's instance variables: 
		superclass: 	Model
		methodDict: 	a MethodDictionary(#aioDisable:->AioEventHandler>>#aioDisable: #aio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#semaphore #semaIndex #handlerProc #descriptor)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AioEventHandler
		classPool: 	a Dictionary(#AioPluginPresent->false )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OSProcess-AIO'
		traitComposition: 	{}
		localSelectors: 	nil


AioEventHandler class>>aioPluginPresent
	Receiver: AioEventHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Model
		methodDict: 	a MethodDictionary(#aioDisable:->AioEventHandler>>#aioDisable: #aio...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#semaphore #semaIndex #handlerProc #descriptor)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AioEventHandler
		classPool: 	a Dictionary(#AioPluginPresent->false )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OSProcess-AIO'
		traitComposition: 	{}
		localSelectors: 	nil


BufferedAsyncFileReadStream(AsyncFileReadStream)>>enableEventHandling
	Receiver: BufferedAsyncFileReadStream: 'pipeReader'
	Arguments and temporary variables: 

	Receiver's instance variables: 



BufferedAsyncFileReadStream(AsyncFileReadStream)>>initialize
	Receiver: BufferedAsyncFileReadStream: 'pipeReader'
	Arguments and temporary variables: 

	Receiver's instance variables: 



BufferedAsyncFileReadStream class(AttachableFileStream class)>>name:attachTo:writable:
	Receiver: BufferedAsyncFileReadStream
	Arguments and temporary variables: 
		aSymbolOrString: 	'pipeReader'
		anIOHandle: 	#[57 108 251 115 136 2 34 10 0 0 0 0 0 0 0 0]
		readWriteFlag: 	false
	Receiver's instance variables: 
		superclass: 	AsyncFileReadStream
		methodDict: 	a MethodDictionary(#actAsExecutor->BufferedAsyncFileReadStream>>#ac...etc...
		format: 	158
		layout: 	a FixedLayout
		instanceVariables: 	#(#nonBlockingMode #readBuffer #readSyncSemaphore #dataAvail...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#BufferedAsyncFileReadStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OSProcess-Base'
		traitComposition: 	{}
		localSelectors: 	nil


AttachableFileStream>>asBufferedAsyncFileReadStream
	Receiver: AttachableFileStream: 'pipeReader'
	Arguments and temporary variables: 

	Receiver's instance variables: 



ExternalPipe>>setBufferedReader
	Receiver: an ExternalPipe
	Arguments and temporary variables: 

	Receiver's instance variables: 
		writer: 	AttachableFileStream: 'pipeWriter'
		reader: 	AttachableFileStream: 'pipeReader'
		blocking: 	true


PipeableOSProcess class>>command:environment:workingDir:input:output:error:errorPipelineStream:shellSyntax:
	Receiver: PipeableOSProcess
	Arguments and temporary variables: 
		aString: 	'rostopic echo /turtle1/cmd_vel __name:=echoManager'
		anEnvironmentDictionary: 	nil
		pathString: 	nil
		inputStream: 	nil
		outputStream: 	nil
		errorStream: 	nil
		anErrorWriteStream: 	nil
		aSyntaxProcessor: 	nil
		p: 	a PipeableOSProcess on an ExternalUnixOSProcess with pid nil on /bin/sh (not...etc...
	Receiver's instance variables: 
		superclass: 	PipeJunction
		methodDict: 	a MethodDictionary(#addToErrorPipeline:->PipeableOSProcess>>#addToE...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#pipeFromError #processProxy #keepInitialStdOutOpen #keepI...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PipeableOSProcess
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CommandShell-Piping'
		traitComposition: 	{}
		localSelectors: 	nil


PipeableOSProcess class>>command:environment:workingDir:input:output:error:errorPipelineStream:
	Receiver: PipeableOSProcess
	Arguments and temporary variables: 
		aString: 	'rostopic echo /turtle1/cmd_vel __name:=echoManager'
		anEnvironmentDictionary: 	nil
		pathString: 	nil
		inputStream: 	nil
		outputStream: 	nil
		errorStream: 	nil
		anErrorWriteStream: 	nil
	Receiver's instance variables: 
		superclass: 	PipeJunction
		methodDict: 	a MethodDictionary(#addToErrorPipeline:->PipeableOSProcess>>#addToE...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#pipeFromError #processProxy #keepInitialStdOutOpen #keepI...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PipeableOSProcess
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CommandShell-Piping'
		traitComposition: 	{}
		localSelectors: 	nil


PipeableOSProcess class>>command:
	Receiver: PipeableOSProcess
	Arguments and temporary variables: 
		aString: 	'rostopic echo /turtle1/cmd_vel __name:=echoManager'
	Receiver's instance variables: 
		superclass: 	PipeJunction
		methodDict: 	a MethodDictionary(#addToErrorPipeline:->PipeableOSProcess>>#addToE...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#pipeFromError #processProxy #keepInitialStdOutOpen #keepI...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PipeableOSProcess
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CommandShell-Piping'
		traitComposition: 	{}
		localSelectors: 	nil


ROSAPI>>echoProcessOfTopic:named:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		aTopic: 	'/turtle1/cmd_vel'
		aName: 	'echoManager'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	nil


[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	nil


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ process := self echoProcessOfTopic: aTopic named: 'echoManager' ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ROSAPI>>echoTopic:
		startpc: 	113
		numArgs: 	0



--- The full stack ---
AioEventHandler class(Object)>>notify:
AioEventHandler class>>aioPluginPresent
BufferedAsyncFileReadStream(AsyncFileReadStream)>>enableEventHandling
BufferedAsyncFileReadStream(AsyncFileReadStream)>>initialize
BufferedAsyncFileReadStream class(AttachableFileStream class)>>name:attachTo:writable:
AttachableFileStream>>asBufferedAsyncFileReadStream
ExternalPipe>>setBufferedReader
PipeableOSProcess class>>command:environment:workingDir:input:output:error:errorPipelineStream:shellSyntax:
PipeableOSProcess class>>command:environment:workingDir:input:output:error:errorPipelineStream:
PipeableOSProcess class>>command:
ROSAPI>>echoProcessOfTopic:named:
[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:29:25.18845 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in SpecDebugger class>>openContext:label:contents:
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelection: 	a Text for 'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelectionString: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
	Receiver's instance variables: 
		ast: 	DoIt
	^ ROSAPI new echoTopic: '/turtle1/cmd_vel'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(614727680)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(176160768)
		submorphs: 	an Array(a RubPrimarySelectionMorph(507248640) a RubCursor(101292441...etc...
		fullBounds: 	(0@0) corner: (580@31)
		color: 	Color transparent
		extension: 	a MorphExtension (7077888) [other:  (announcer -> an Announcer) (kmD...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(137887744)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1012924416)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(890503168))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	103905
		lastStepMessage: 	nil
		lastCycleTime: 	103927
		alarms: 	a Heap()
		lastAlarmTime: 	103905
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(561774592) a GLMSyst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	103905
		lastStepMessage: 	nil
		lastCycleTime: 	103927
		alarms: 	a Heap()
		lastAlarmTime: 	103905
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	103905
		lastStepMessage: 	nil
		lastCycleTime: 	103927
		alarms: 	a Heap()
		lastAlarmTime: 	103905
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(561774592) a GLMSyst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:31:13.752451 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoProcessOfTopic:named:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		aTopic: 	'/turtle1/cmd_vel'
		aName: 	'echoManager'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ process := self echoProcessOfTopic: aTopic named: 'echoManager' ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ROSAPI>>echoTopic:
		startpc: 	113
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoProcessOfTopic:named:
[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:31:13.760451 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in MorphicUIManager>>openDebuggerOn:context:label:contents:fu...etc...
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelection: 	a Text for 'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
		itsSelectionString: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel'''
	Receiver's instance variables: 
		ast: 	DoIt
	^ ROSAPI new echoTopic: '/turtle1/cmd_vel'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(614727680)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(176160768)
		submorphs: 	an Array(a RubPrimarySelectionMorph(507248640) a RubCursor(101292441...etc...
		fullBounds: 	(0@0) corner: (580@31)
		color: 	Color transparent
		extension: 	a MorphExtension (7077888) [other:  (announcer -> an Announcer) (kmD...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(137887744)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1012924416)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(890503168))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 1 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	212543
		lastStepMessage: 	nil
		lastCycleTime: 	212565
		alarms: 	a Heap()
		lastAlarmTime: 	212543
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1040711680) a S...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	212543
		lastStepMessage: 	nil
		lastCycleTime: 	212565
		alarms: 	a Heap()
		lastAlarmTime: 	212543
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	212543
		lastStepMessage: 	nil
		lastCycleTime: 	212565
		alarms: 	a Heap()
		lastAlarmTime: 	212543
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1040711680) a S...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:31:48.60845 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoProcessOfTopic:named:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		aTopic: 	'/turtle1/cmd_vel'
		aName: 	'echoManager'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ process := self echoProcessOfTopic: aTopic named: 'echoManager' ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ROSAPI>>echoTopic:
		startpc: 	113
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoProcessOfTopic:named:
[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:33:09.65245 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoProcessOfTopic:named:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		aTopic: 	'/turtle1/cmd_vel '
		aName: 	'echoManager'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	nil


[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	nil


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ process := self echoProcessOfTopic: aTopic named: 'echoManager' ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ROSAPI>>echoTopic:
		startpc: 	113
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoProcessOfTopic:named:
[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:33:09.66045 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in MorphicUIManager>>openDebuggerOn:context:label:contents:fu...etc...
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
		itsSelection: 	a Text for 'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
		itsSelectionString: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
	Receiver's instance variables: 
		ast: 	DoIt
	^ ROSAPI new echoTopic: '/turtle1/cmd_vel '
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(614727680)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(176160768)
		submorphs: 	an Array(a RubPrimarySelectionMorph(507248640) a RubCursor(101292441...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (7077888) [other:  (announcer -> an Announcer) (kmD...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(137887744)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1012924416)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(580911104))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 1 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	328441
		lastStepMessage: 	nil
		lastCycleTime: 	328461
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	328441
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(713818112) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	328441
		lastStepMessage: 	nil
		lastCycleTime: 	328461
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	328441
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	328441
		lastStepMessage: 	nil
		lastCycleTime: 	328461
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	328441
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(713818112) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:33:12.65445 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in MorphicUIManager>>openDebuggerOn:context:label:contents:fu...etc...
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
		itsSelection: 	a Text for 'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
		itsSelectionString: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
	Receiver's instance variables: 
		ast: 	DoIt
	^ ROSAPI new echoTopic: '/turtle1/cmd_vel '
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(614727680)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(176160768)
		submorphs: 	an Array(a RubPrimarySelectionMorph(507248640) a RubCursor(101292441...etc...
		fullBounds: 	(0@0) corner: (580@31)
		color: 	Color transparent
		extension: 	a MorphExtension (7077888) [other:  (announcer -> an Announcer) (kmD...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(137887744)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1012924416)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(580911104))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	331443
		lastStepMessage: 	nil
		lastCycleTime: 	331463
		alarms: 	a Heap()
		lastAlarmTime: 	331443
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(282329088) a GLMSyst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	331443
		lastStepMessage: 	nil
		lastCycleTime: 	331463
		alarms: 	a Heap()
		lastAlarmTime: 	331443
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(770179072))(a SearchMorp...etc...
		lastStepTime: 	331443
		lastStepMessage: 	nil
		lastCycleTime: 	331463
		alarms: 	a Heap()
		lastAlarmTime: 	331443
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(282329088) a GLMSyst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:34:09.968667 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoProcessOfTopic:named:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		aTopic: 	'/turtle1/cmd_vel '
		aName: 	'echoManager'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ process := self echoProcessOfTopic: aTopic named: 'echoManager' ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ROSAPI>>echoTopic:
		startpc: 	113
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoProcessOfTopic:named:
[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:39:48.864667 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in OrderedCollection>>resetTo:
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
		itsSelection: 	a Text for 'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
		itsSelectionString: 	'ROSAPI new echoTopic: ''/turtle1/cmd_vel '''
	Receiver's instance variables: 
		ast: 	DoIt
	^ ROSAPI new echoTopic: '/turtle1/cmd_vel '
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(614727680)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(176160768)
		submorphs: 	an Array(a RubPrimarySelectionMorph(507248640) a RubCursor(101292441...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (7077888) [other:  (announcer -> an Announcer) (kmD...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(137887744)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1012924416)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(603455488))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 866385920))(3...etc...
		lastStepTime: 	727647
		lastStepMessage: 	nil
		lastCycleTime: 	727669
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	727647
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(713818112) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 866385920))(3...etc...
		lastStepTime: 	727647
		lastStepMessage: 	nil
		lastCycleTime: 	727669
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	727647
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> 3PButton(#toggleSelected 866385920))(3...etc...
		lastStepTime: 	727647
		lastStepMessage: 	nil
		lastCycleTime: 	727669
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	727647
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(713818112) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoTopic:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 5:39:48.872667 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ROSAPI>>echoProcessOfTopic:named:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
		aTopic: 	'/turtle1/cmd_vel '
		aName: 	'echoManager'
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
	Receiver: a ROSAPI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		process: 	nil
		thread: 	a Process in nil
		lastMsg: 	nil
		thread2: 	nil
		a: 	Processor


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ process := self echoProcessOfTopic: aTopic named: 'echoManager' ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ROSAPI>>echoTopic:
		startpc: 	113
		numArgs: 	0



--- The full stack ---
ROSAPI>>echoProcessOfTopic:named:
[ process := self echoProcessOfTopic: aTopic named: 'echoManager' ] in ROSAPI>>echoTopic:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
8 December 2015 5:44:52.125823 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ delaySemaphore wait ] in Delay>>wait
	Receiver: a Delay(50 msecs)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	50
		scheduler: 	a DelayMicrosecondScheduler
		schedulerResumptionTime: 	3627060292119853


BlockClosure>>ifCurtailed:
	Receiver: [ delaySemaphore wait ]
	Arguments and temporary variables: 
		aBlock: 	[ self unschedule ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	Delay>>wait
		startpc: 	36
		numArgs: 	0


Delay>>wait
	Receiver: a Delay(50 msecs)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	50
		scheduler: 	a DelayMicrosecondScheduler
		schedulerResumptionTime: 	3627060292119853


PipeableOSProcess(PipeJunction)>>outputOn:
	Receiver: a PipeableOSProcess on an ExternalUnixOSProcess with pid 28624 on /bin/sh (running)
	Arguments and temporary variables: 
		aStream: 	a WriteStream
		d: 	a Delay(50 msecs)
	Receiver's instance variables: 
		dependents: 	nil
		pipeToInput: 	an ExternalPipe
		pipeFromOutput: 	an ExternalPipe
		errorPipelineStream: 	an InternalPipe
		pipeFromError: 	an ExternalPipe
		processProxy: 	an ExternalUnixOSProcess with pid 28624 on /bin/sh (running)
		keepInitialStdOutOpen: 	false
		keepInitialStdErrOpen: 	false
		accessProtect: 	a Semaphore()


PipeableOSProcess(PipeJunction)>>output
	Receiver: a PipeableOSProcess on an ExternalUnixOSProcess with pid 28624 on /bin/sh (running)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		pipeToInput: 	an ExternalPipe
		pipeFromOutput: 	an ExternalPipe
		errorPipelineStream: 	an InternalPipe
		pipeFromError: 	an ExternalPipe
		processProxy: 	an ExternalUnixOSProcess with pid 28624 on /bin/sh (running)
		keepInitialStdOutOpen: 	false
		keepInitialStdErrOpen: 	false
		accessProtect: 	a Semaphore()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ (PipeableOSProcess command: 'grep shared') output
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(614727680)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@50)
		owner: 	a TransformWithLayoutMorph(176160768)
		submorphs: 	an Array(a RubPrimarySelectionMorph(780926976) a RubCursor(101292441...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (7077888) [other:  (announcer -> an Announcer) (kmD...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(137887744)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1012924416)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(837025792))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(412876800))(a DropList...etc...
		lastStepTime: 	1024552
		lastStepMessage: 	nil
		lastCycleTime: 	1024574
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	1024552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(713818112) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(412876800))(a DropList...etc...
		lastStepTime: 	1024552
		lastStepMessage: 	nil
		lastCycleTime: 	1024574
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	1024552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(412876800))(a DropList...etc...
		lastStepTime: 	1024552
		lastStepMessage: 	nil
		lastCycleTime: 	1024574
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1012924416)))
		lastAlarmTime: 	1024552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(713818112) a Na...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ delaySemaphore wait ] in Delay>>wait
BlockClosure>>ifCurtailed:
Delay>>wait
PipeableOSProcess(PipeJunction)>>outputOn:
PipeableOSProcess(PipeJunction)>>output
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
8 December 2015 5:44:54.254032 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ delaySemaphore wait ] in Delay>>wait
	Receiver: a Delay(50 msecs; 10 msecs remaining)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore(a Process in [ delaySemaphore wait ] in Delay>>wait...etc...
		beingWaitedOn: 	true
		millisecondDelayDuration: 	50
		scheduler: 	a DelayMicrosecondScheduler
		schedulerResumptionTime: 	3627060294264062


BlockClosure>>ifCurtailed:
	Receiver: [ delaySemaphore wait ]
	Arguments and temporary variables: 
		aBlock: 	[ self unschedule ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	Delay>>wait
		startpc: 	36
		numArgs: 	0


Delay>>wait
	Receiver: a Delay(50 msecs; 8 msecs remaining)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore(a Process in [ delaySemaphore wait ] in Delay>>wait...etc...
		beingWaitedOn: 	true
		millisecondDelayDuration: 	50
		scheduler: 	a DelayMicrosecondScheduler
		schedulerResumptionTime: 	3627060294264062


PipeableOSProcess(PipeJunction)>>outputOn:
	Receiver: a PipeableOSProcess on an ExternalUnixOSProcess with pid 28626 on /bin/sh (running)
	Arguments and temporary variables: 
		aStream: 	a WriteStream
		d: 	a Delay(50 msecs; 8 msecs remaining)
	Receiver's instance variables: 
		dependents: 	nil
		pipeToInput: 	an ExternalPipe
		pipeFromOutput: 	an ExternalPipe
		errorPipelineStream: 	an InternalPipe
		pipeFromError: 	an ExternalPipe
		processProxy: 	an ExternalUnixOSProcess with pid 28626 on /bin/sh (running)
		keepInitialStdOutOpen: 	false
		keepInitialStdErrOpen: 	false
		accessProtect: 	a Semaphore()


PipeableOSProcess(PipeJunction)>>output
	Receiver: a PipeableOSProcess on an ExternalUnixOSProcess with pid 28626 on /bin/sh (running)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		pipeToInput: 	an ExternalPipe
		pipeFromOutput: 	an ExternalPipe
		errorPipelineStream: 	an InternalPipe
		pipeFromError: 	an ExternalPipe
		processProxy: 	an ExternalUnixOSProcess with pid 28626 on /bin/sh (running)
		keepInitialStdOutOpen: 	false
		keepInitialStdErrOpen: 	false
		accessProtect: 	a Semaphore()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	a Text for ''
		itsSelectionString: 	''
	Receiver's instance variables: 
		ast: 	DoIt
	^ (PipeableOSProcess command: 'grep shared') output
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(614727680)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(54263808)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1031010
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#value -> [ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
...etc...
	Arguments and temporary variables: 
		anArgument: 	1031098
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		...etc...
		selector: 	#value
		arguments: 	#()
		scheduledTime: 	1031010
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1031098
		pending: 	a Heap()
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(231473152))(a Spec...etc...
		lastStepTime: 	1031066
		lastStepMessage: 	nil
		lastCycleTime: 	1030958
		alarms: 	a Heap()
		lastAlarmTime: 	1024552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		now: 	1031098
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(231473152))(a Spec...etc...
		lastStepTime: 	1031066
		lastStepMessage: 	nil
		lastCycleTime: 	1030958
		alarms: 	a Heap()
		lastAlarmTime: 	1024552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(231473152))(a Spec...etc...
		lastStepTime: 	1031066
		lastStepMessage: 	nil
		lastCycleTime: 	1030958
		alarms: 	a Heap()
		lastAlarmTime: 	1024552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(547880960) a GLMSyst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(231473152))(a Spec...etc...
		lastStepTime: 	1031066
		lastStepMessage: 	nil
		lastCycleTime: 	1030958
		alarms: 	a Heap()
		lastAlarmTime: 	1024552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(231473152))(a Spec...etc...
		lastStepTime: 	1031066
		lastStepMessage: 	nil
		lastCycleTime: 	1030958
		alarms: 	a Heap()
		lastAlarmTime: 	1024552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(547880960) a GLMSyst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ delaySemaphore wait ] in Delay>>wait
BlockClosure>>ifCurtailed:
Delay>>wait
PipeableOSProcess(PipeJunction)>>outputOn:
PipeableOSProcess(PipeJunction)>>output
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor
	highlightEvaluateAndDo: [ :result | 
		textMorph shoutStyler style: textMorph text.
		GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>evaluateAndPopPrintHighlight
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: MCGemstoneRepository expected
8 December 2015 6:03:04.546514 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

MCGemstoneRepository class(Object)>>error:
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 
		aString: 	'MCGemstoneRepository expected'
	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(Object class)>>readFrom:
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 
		textStringOrStream: 	a ReadStream
		object: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 
		aTemplateString: 	'MCGemstoneRepository
	location: ''http://ss3.gemtalksystems.c...etc...
		chunk: 	'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
		repo: 	nil
	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCWorkingCopyBrowser>>newRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		types: 	{MCDirectoryRepository. MCFtpRepository. MCHttpRepository. MCSubDirector...etc...
		index: 	6
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser>>addRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		anActionSelector: 	#addRepository
		anEnabledSelector: 	#buttonEnabled
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		event: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(738.0@399.0) corner: (836.0@425.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(738@399) corner: (836@425)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
		m: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		bounds: 	(738.0@399.0) corner: (836.0@425.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(738@399) corner: (836@425)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	6
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
	Receiver's instance variables: 
		bounds: 	(738.0@399.0) corner: (836.0@425.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(738@399) corner: (836@425)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(738.0@399.0) corner: (836.0@425.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(738@399) corner: (836@425)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


MouseButtonEvent>>sentTo:
	Receiver: [(789@411) mouseUp 2063019 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		timeStamp: 	2063019
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(789@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(738.0@399.0) corner: (836.0@425.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(738@399) corner: (836@425)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(738.0@399.0) corner: (836.0@425.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(738@399) corner: (836@425)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(694@383.0) corner: (710@399.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(663486464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(694@383) mouseOver nil nil]
		targetOffset: 	(28.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2083715 740 573 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(789@411) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(121372672) a Syste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(694@383.0) corner: (710@399.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(663486464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(694@383) mouseOver nil nil]
		targetOffset: 	(28.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2083715 740 573 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(694@383.0) corner: (710@399.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(663486464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(694@383) mouseOver nil nil]
		targetOffset: 	(28.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2083715 740 573 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(694@383.0) corner: (710@399.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(663486464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(694@383) mouseOver nil nil]
		targetOffset: 	(28.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2083715 740 573 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		evt: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(694@383.0) corner: (710@399.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(663486464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(694@383) mouseOver nil nil]
		targetOffset: 	(28.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2083715 740 573 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		evtBuf: 	#(1 2063019 789 411 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(694@383.0) corner: (710@399.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(663486464)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(694@383) mouseOver nil nil]
		targetOffset: 	(28.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2083715 740 573 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	2123381
		lastStepMessage: 	nil
		lastCycleTime: 	2123371
		alarms: 	a Heap()
		lastAlarmTime: 	2123381
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	2123381
		lastStepMessage: 	nil
		lastCycleTime: 	2123371
		alarms: 	a Heap()
		lastAlarmTime: 	2123381
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	2123381
		lastStepMessage: 	nil
		lastCycleTime: 	2123371
		alarms: 	a Heap()
		lastAlarmTime: 	2123381
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	2123381
		lastStepMessage: 	nil
		lastCycleTime: 	2123371
		alarms: 	a Heap()
		lastAlarmTime: 	2123381
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(121372672) a Syste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MCGemstoneRepository class(Object)>>error:
MCGemstoneRepository class(Object class)>>readFrom:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
MCWorkingCopyBrowser>>newRepository
MCWorkingCopyBrowser>>addRepository
MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:
8 December 2015 6:03:17.71252 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 
		aTemplateString: 	'MCGemstoneRepository
	location: ''http://ss3.gemtalksystems.c...etc...
		chunk: 	'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
		repo: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCWorkingCopyBrowser>>newRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		types: 	{MCDirectoryRepository. MCFtpRepository. MCHttpRepository. MCSubDirector...etc...
		index: 	6
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser>>addRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		anActionSelector: 	#addRepository
		anEnabledSelector: 	#buttonEnabled
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		event: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
		m: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	6
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


MouseButtonEvent>>sentTo:
	Receiver: [(789@411) mouseUp 2063019 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		timeStamp: 	2063019
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(789@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(236@402.0) corner: (252@418.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(236@402.0) corner: (252@418.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(558104576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(236@402) mouseOver nil nil]
		targetOffset: 	(138.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2136459 236 402 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(789@411) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(185860096) a Syste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(236@402.0) corner: (252@418.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(236@402.0) corner: (252@418.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(558104576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(236@402) mouseOver nil nil]
		targetOffset: 	(138.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2136459 236 402 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(236@402.0) corner: (252@418.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(236@402.0) corner: (252@418.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(558104576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(236@402) mouseOver nil nil]
		targetOffset: 	(138.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2136459 236 402 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(236@402.0) corner: (252@418.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(236@402.0) corner: (252@418.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(558104576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(236@402) mouseOver nil nil]
		targetOffset: 	(138.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2136459 236 402 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		evt: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(236@402.0) corner: (252@418.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(236@402.0) corner: (252@418.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(558104576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(236@402) mouseOver nil nil]
		targetOffset: 	(138.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2136459 236 402 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		evtBuf: 	#(1 2063019 789 411 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(236@402.0) corner: (252@418.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(236@402.0) corner: (252@418.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(558104576)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(236@402) mouseOver nil nil]
		targetOffset: 	(138.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2136459 236 402 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(412876800))(a DropList...etc...
		lastStepTime: 	2136505
		lastStepMessage: 	nil
		lastCycleTime: 	2136487
		alarms: 	a Heap()
		lastAlarmTime: 	2136505
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(412876800))(a DropList...etc...
		lastStepTime: 	2136505
		lastStepMessage: 	nil
		lastCycleTime: 	2136487
		alarms: 	a Heap()
		lastAlarmTime: 	2136505
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(412876800))(a DropList...etc...
		lastStepTime: 	2136505
		lastStepMessage: 	nil
		lastCycleTime: 	2136487
		alarms: 	a Heap()
		lastAlarmTime: 	2136505
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(412876800))(a DropList...etc...
		lastStepTime: 	2136505
		lastStepMessage: 	nil
		lastCycleTime: 	2136487
		alarms: 	a Heap()
		lastAlarmTime: 	2136505
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(185860096) a Syste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
MCWorkingCopyBrowser>>newRepository
MCWorkingCopyBrowser>>addRepository
MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:
8 December 2015 6:03:19.054522 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


Message>>sentTo:
	Receiver: creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
	Arguments and temporary variables: 
		receiver: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		selector: 	#creationTemplate:
		args: 	#('Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 ...etc...
		lookupClass: 	ConfigurationOfPhaROS class


ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplat...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 
		aTemplateString: 	'MCGemstoneRepository
	location: ''http://ss3.gemtalksystems.c...etc...
		chunk: 	'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
		repo: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCWorkingCopyBrowser>>newRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		types: 	{MCDirectoryRepository. MCFtpRepository. MCHttpRepository. MCSubDirector...etc...
		index: 	6
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser>>addRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		anActionSelector: 	#addRepository
		anEnabledSelector: 	#buttonEnabled
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		event: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
		m: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	6
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


MouseButtonEvent>>sentTo:
	Receiver: [(789@411) mouseUp 2063019 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		timeStamp: 	2063019
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(789@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(231@418.0) corner: (247@434.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@418.0) corner: (247@434.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(821821440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@418) mouseUp 2137827 nil]
		targetOffset: 	(113.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2137827 231 418 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(789@411) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(197132288) a SystemW...etc...
		fullBounds: 	(0@0) corner: (927@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(231@418.0) corner: (247@434.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@418.0) corner: (247@434.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(821821440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@418) mouseUp 2137827 nil]
		targetOffset: 	(113.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2137827 231 418 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(231@418.0) corner: (247@434.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@418.0) corner: (247@434.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(821821440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@418) mouseUp 2137827 nil]
		targetOffset: 	(113.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2137827 231 418 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(231@418.0) corner: (247@434.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@418.0) corner: (247@434.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(821821440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@418) mouseUp 2137827 nil]
		targetOffset: 	(113.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2137827 231 418 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		evt: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(231@418.0) corner: (247@434.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@418.0) corner: (247@434.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(821821440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@418) mouseUp 2137827 nil]
		targetOffset: 	(113.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2137827 231 418 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		evtBuf: 	#(1 2063019 789 411 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(231@418.0) corner: (247@434.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@418.0) corner: (247@434.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(821821440)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@418) mouseUp 2137827 nil]
		targetOffset: 	(113.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2137827 231 418 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(412876800))(a DropList...etc...
		lastStepTime: 	2137939
		lastStepMessage: 	nil
		lastCycleTime: 	2137921
		alarms: 	a Heap()
		lastAlarmTime: 	2137939
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(677904384))(a SearchMorp...etc...
		lastStepTime: 	2137939
		lastStepMessage: 	nil
		lastCycleTime: 	2137921
		alarms: 	a Heap()
		lastAlarmTime: 	2137939
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(677904384))(a SearchMorp...etc...
		lastStepTime: 	2137939
		lastStepMessage: 	nil
		lastCycleTime: 	2137921
		alarms: 	a Heap()
		lastAlarmTime: 	2137939
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(677904384))(a SearchMorp...etc...
		lastStepTime: 	2137939
		lastStepMessage: 	nil
		lastCycleTime: 	2137921
		alarms: 	a Heap()
		lastAlarmTime: 	2137939
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(185860096) a Syste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
Message>>sentTo:
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
MCWorkingCopyBrowser>>newRepository
MCWorkingCopyBrowser>>addRepository
MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:
8 December 2015 6:03:21.126517 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


Message>>sentTo:
	Receiver: creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
	Arguments and temporary variables: 
		receiver: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		selector: 	#creationTemplate:
		args: 	#('Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 ...etc...
		lookupClass: 	ConfigurationOfPhaROS class


ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplat...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


Message>>sentTo:
	Receiver: creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
	Arguments and temporary variables: 
		receiver: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		selector: 	#creationTemplate:
		args: 	#('Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 ...etc...
		lookupClass: 	ConfigurationOfPhaROS class


ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplat...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 
		aTemplateString: 	'MCGemstoneRepository
	location: ''http://ss3.gemtalksystems.c...etc...
		chunk: 	'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
		repo: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCWorkingCopyBrowser>>newRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		types: 	{MCDirectoryRepository. MCFtpRepository. MCHttpRepository. MCSubDirector...etc...
		index: 	6
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser>>addRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		anActionSelector: 	#addRepository
		anEnabledSelector: 	#buttonEnabled
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		event: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
		m: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	6
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


MouseButtonEvent>>sentTo:
	Receiver: [(789@411) mouseUp 2063019 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		timeStamp: 	2063019
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(789@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(266@432.0) corner: (282@448.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(266@432.0) corner: (282@448.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(412614656)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(266@432) mouseUp 2139923 nil]
		targetOffset: 	(128.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2139923 266 432 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(789@411) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(937951232) a SystemW...etc...
		fullBounds: 	(0@0) corner: (927@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(266@432.0) corner: (282@448.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(266@432.0) corner: (282@448.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(412614656)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(266@432) mouseUp 2139923 nil]
		targetOffset: 	(128.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2139923 266 432 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(266@432.0) corner: (282@448.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(266@432.0) corner: (282@448.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(412614656)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(266@432) mouseUp 2139923 nil]
		targetOffset: 	(128.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2139923 266 432 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(266@432.0) corner: (282@448.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(266@432.0) corner: (282@448.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(412614656)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(266@432) mouseUp 2139923 nil]
		targetOffset: 	(128.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2139923 266 432 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		evt: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(266@432.0) corner: (282@448.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(266@432.0) corner: (282@448.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(412614656)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(266@432) mouseUp 2139923 nil]
		targetOffset: 	(128.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2139923 266 432 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		evtBuf: 	#(1 2063019 789 411 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(266@432.0) corner: (282@448.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(266@432.0) corner: (282@448.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(412614656)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(266@432) mouseUp 2139923 nil]
		targetOffset: 	(128.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2139923 266 432 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(464257024))(a DropList...etc...
		lastStepTime: 	2139907
		lastStepMessage: 	nil
		lastCycleTime: 	2139927
		alarms: 	a Heap()
		lastAlarmTime: 	2139907
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(464257024))(a DropList...etc...
		lastStepTime: 	2139907
		lastStepMessage: 	nil
		lastCycleTime: 	2139927
		alarms: 	a Heap()
		lastAlarmTime: 	2139907
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(464257024))(a DropList...etc...
		lastStepTime: 	2139907
		lastStepMessage: 	nil
		lastCycleTime: 	2139927
		alarms: 	a Heap()
		lastAlarmTime: 	2139907
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(464257024))(a DropList...etc...
		lastStepTime: 	2139907
		lastStepMessage: 	nil
		lastCycleTime: 	2139927
		alarms: 	a Heap()
		lastAlarmTime: 	2139907
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(937951232) a SystemW...etc...
		fullBounds: 	(0@0) corner: (927@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
Message>>sentTo:
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
Message>>sentTo:
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
MCWorkingCopyBrowser>>newRepository
MCWorkingCopyBrowser>>addRepository
MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:
8 December 2015 6:03:22.138516 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


Message>>sentTo:
	Receiver: creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
	Arguments and temporary variables: 
		receiver: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		selector: 	#creationTemplate:
		args: 	#('Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 ...etc...
		lookupClass: 	ConfigurationOfPhaROS class


ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplat...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


Message>>sentTo:
	Receiver: creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
	Arguments and temporary variables: 
		receiver: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		selector: 	#creationTemplate:
		args: 	#('Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 ...etc...
		lookupClass: 	ConfigurationOfPhaROS class


ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplat...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


Message>>sentTo:
	Receiver: creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
	Arguments and temporary variables: 
		receiver: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		selector: 	#creationTemplate:
		args: 	#('Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 ...etc...
		lookupClass: 	ConfigurationOfPhaROS class


ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
	Receiver: ConfigurationOfPhaROS
	Arguments and temporary variables: 
		aMessage: 	creationTemplate: 'Gofer it
        url: ''http://smalltalkhub.com/mc...etc...
		exception: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplate:...etc...
		resumeValue: 	MessageNotUnderstood: ConfigurationOfPhaROS class>>creationTemplat...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#baseline10:->ConfigurationOfPhaROS>>#baseline10...etc...
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#project)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationOfPhaROS
		classPool: 	a Dictionary(#LastVersionLoad->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#ConfigurationOfPhaROS
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 
		aTemplateString: 	'MCGemstoneRepository
	location: ''http://ss3.gemtalksystems.c...etc...
		chunk: 	'Gofer it
        url: ''http://smalltalkhub.com/mc/CAR/PhaROS/main''
 u...etc...
		repo: 	ConfigurationOfPhaROS
	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
	Receiver: MCGemstoneRepository
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MCHttpRepository
		methodDict: 	a MethodDictionary(#includesVersionNamed:->MCGemstoneRepository>>#i...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MCGemstoneRepository
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Repositories'
		traitComposition: 	{}
		localSelectors: 	nil


MCWorkingCopyBrowser>>newRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		types: 	{MCDirectoryRepository. MCFtpRepository. MCHttpRepository. MCSubDirector...etc...
		index: 	6
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser>>addRepository
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
	Receiver: a MCWorkingCopyBrowser
	Arguments and temporary variables: 
		anActionSelector: 	#addRepository
		anEnabledSelector: 	#buttonEnabled
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(185860096) a PluggableButtonMorph(...etc...
		morph: 	a SystemWindow(185860096)
		label: 	nil
		modal: 	false
		modalValue: 	nil
		workingCopy: 	nil
		workingCopyWrapper: 	nil
		repository: 	nil
		defaults: 	nil
		order: 	2
		repositoryPattern: 	''
		workingCopyPattern: 	''
		repositoryProcess: 	nil
		packageProcess: 	nil
		showOnlyRepositoriesFromWorkingCopy: 	true


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		event: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
		m: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	6
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(149946368) a PluggableB...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		all: 	an Array(a PluggableButtonMorph(1004273664) a PluggableButtonMorph(1499463...etc...
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


MouseButtonEvent>>sentTo:
	Receiver: [(789@411) mouseUp 2063019 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(716177408)
	Receiver's instance variables: 
		timeStamp: 	2063019
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(789@411)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(716177408)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(482.0@165.0) corner: (580.0@191.0)
		owner: 	a PanelMorph(896532480)
		submorphs: 	an Array(an AlignmentMorph(497287168))
		fullBounds: 	(482@165) corner: (580@191)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (783548416) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCWorkingCopyBrowser
		label: 	'+Repository'
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#addRepository #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		lastColor: 	nil
		labelMorph: 	a LabelMorph(585367552)'+Repository'


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(269@452.0) corner: (285@468.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(269@452.0) corner: (285@468.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(537133056)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(269@452) mouseUp 2140939 nil]
		targetOffset: 	(111.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2140939 269 452 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(789@411) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(538181632) a SystemW...etc...
		fullBounds: 	(0@0) corner: (927@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(269@452.0) corner: (285@468.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(269@452.0) corner: (285@468.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(537133056)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(269@452) mouseUp 2140939 nil]
		targetOffset: 	(111.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2140939 269 452 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		focusHolder: 	a PluggableButtonMorph(716177408)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(269@452.0) corner: (285@468.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(269@452.0) corner: (285@468.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(537133056)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(269@452) mouseUp 2140939 nil]
		targetOffset: 	(111.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2140939 269 452 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(269@452.0) corner: (285@468.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(269@452.0) corner: (285@468.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(537133056)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(269@452) mouseUp 2140939 nil]
		targetOffset: 	(111.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2140939 269 452 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(789@411) mouseUp 2063019 nil]
		evt: 	[(789@411) mouseUp 2063019 nil]
	Receiver's instance variables: 
		bounds: 	(269@452.0) corner: (285@468.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(269@452.0) corner: (285@468.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(537133056)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(269@452) mouseUp 2140939 nil]
		targetOffset: 	(111.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2140939 269 452 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(789@411) mouseUp 2063019 nil]
		evtBuf: 	#(1 2063019 789 411 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(269@452.0) corner: (285@468.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(269@452.0) corner: (285@468.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(537133056)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(269@452) mouseUp 2140939 nil]
		targetOffset: 	(111.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2140939 269 452 0 0 0 1)
		lastKeyScanCode: 	22
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	2140925
		lastStepMessage: 	nil
		lastCycleTime: 	2140945
		alarms: 	a Heap()
		lastAlarmTime: 	2140925
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	2140925
		lastStepMessage: 	nil
		lastCycleTime: 	2140945
		alarms: 	a Heap()
		lastAlarmTime: 	2140925
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	2140925
		lastStepMessage: 	nil
		lastCycleTime: 	2140945
		alarms: 	a Heap()
		lastAlarmTime: 	2140925
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (927@1028)
		canvas: 	a FormCanvas on: DisplayScreen(927x1028x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(160432128))(a DropList...etc...
		lastStepTime: 	2140925
		lastStepMessage: 	nil
		lastCycleTime: 	2140945
		alarms: 	a Heap()
		lastAlarmTime: 	2140925
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (927@1028)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(538181632) a SystemW...etc...
		fullBounds: 	(0@0) corner: (927@1028)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
Message>>sentTo:
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
Message>>sentTo:
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
Message>>sentTo:
ConfigurationOfPhaROS class(Object)>>doesNotUnderstand: #creationTemplate:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure:
MCGemstoneRepository class(MCRepository class)>>fillInTheBlankConfigure
MCGemstoneRepository class(MCHttpRepository class)>>morphicConfigure
MCWorkingCopyBrowser>>newRepository
MCWorkingCopyBrowser>>addRepository
MCWorkingCopyBrowser(MCTool)>>performButtonAction:enabled:
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
XMLRPCFaultException: <type 'exceptions.Exception'>:method "getBusStats" is not supported
8 December 2015 6:30:37.584543 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

XMLRPCProxy>>processFault:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		xmlFault: 	<fault><value><struct><member><name>faultCode</name><value><int>1</in...etc...
		d: 	a Dictionary('faultCode'->1 'faultString'->'<type ''exceptions.Exception''>:...etc...
		decoder: 	a XMLRPCDecoder
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


XMLRPCProxy>>processResponse:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		xmlStream: 	'<?xml version=''1.0''?>
<methodResponse>
<fault>
<value><struct>
<m...etc...
		xmldoc: 	<?xml version="1.0"?><methodResponse><fault><value><struct><member><nam...etc...
		methodResponse: 	<methodResponse><fault><value><struct><member><name>faultCode</...etc...
		fault: 	<fault><value><struct><member><name>faultCode</name><value><int>1</int><...etc...
		parameters: 	nil
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


XMLRPCProxy>>invokeMethod:withArgs:
	Receiver: a XMLRPCProxy
	Arguments and temporary variables: 
		aString: 	'getBusStats'
		anArray: 	#('/script')
		request: 	'<?xml version="1.0"?><methodCall><methodName>getBusStats</methodName>...etc...
		response: 	'<?xml version=''1.0''?>
<methodResponse>
<fault>
<value><struct>
<me...etc...
	Receiver's instance variables: 
		url: 	'http://localhost:11311'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'proxy := XMLRPCProxy withUrl: ''http://localhost:11311''.
	sys...etc...
		itsSelection: 	a Text for 'proxy := XMLRPCProxy withUrl: ''http://localhost:1131...etc...
		itsSelectionString: 	'proxy := XMLRPCProxy withUrl: ''http://localhost:11311''.
...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	proxy := XMLRPCProxy withUrl: 'http://localhost:11311'.
	systemState...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(692322304)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(692322304)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(140509184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(692322304)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@88)
		owner: 	a TransformWithLayoutMorph(262406144)
		submorphs: 	an Array(a RubCursor(52953088) a RubPrimarySelectionMorph(200278016)...etc...
		fullBounds: 	(0@0) corner: (580@88)
		color: 	Color transparent
		extension: 	a MorphExtension (84672512) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(224133120)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(52953088)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(126091264))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(140509184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(650379264))(a SearchMorp...etc...
		lastStepTime: 	68615
		lastStepMessage: 	nil
		lastCycleTime: 	68685
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(52953088)))
		lastAlarmTime: 	68615
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1003225088) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(650379264))(a SearchMorp...etc...
		lastStepTime: 	68615
		lastStepMessage: 	nil
		lastCycleTime: 	68685
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(52953088)))
		lastAlarmTime: 	68615
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(650379264))(a SearchMorp...etc...
		lastStepTime: 	68615
		lastStepMessage: 	nil
		lastCycleTime: 	68685
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(52953088)))
		lastAlarmTime: 	68615
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1003225088) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
XMLRPCProxy>>processFault:
XMLRPCProxy>>processResponse:
XMLRPCProxy>>invokeMethod:withArgs:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RQTGMainWindow>>refresh
8 December 2015 6:42:06.888539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RQTGMainWindow(Object)>>doesNotUnderstand: #refresh
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		aMessage: 	refresh
		exception: 	MessageNotUnderstood: RQTGMainWindow>>refresh
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	nil
		refresh: 	a ButtonModel


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#refresh
		args: 	#()
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #refresh)
		index: 	3


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#()
		numArgs: 	0
		selector: 	#refresh
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #refresh)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #refresh)
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #refresh)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #refresh)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #refresh)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #refresh)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #refresh)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFracti...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFracti...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFracti...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #to...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #top...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Spe...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0. #r...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #topFraction:. 0. #r...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction:. 0. #to...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayou...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Spe...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayou...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Spe...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayou...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Sp...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayo...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Sp...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayo...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Sp...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayo...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayoutFram...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayoutFrame. #leftFraction...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#SpecLayoutFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refre...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refre...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refre...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refresh)...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refr...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refr...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refresh)....etc...
		numArgs: 	1
		selector: 	#add:
		each: 	{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refresh). ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: {{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Spec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refresh). #layout:. {#Spec...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	{{{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model #refresh)....etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a RQTGMainWindow
		aSelector: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {{#Contain...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	a SpecLayout
		aModel: 	a RQTGMainWindow
		aSelector: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings



--- The full stack ---
RQTGMainWindow(Object)>>doesNotUnderstand: #refresh
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTEllipse>>do:
8 December 2015 7:25:38.956539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTEllipse(Object)>>doesNotUnderstand: #do:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aMessage: 	do: [ :el | self add: el ]
		exception: 	MessageNotUnderstood: RTEllipse>>do:
		resumeValue: 	nil
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTViewForSpec(RTView)>>addAll:
	Receiver: a RTViewForSpec
	Arguments and temporary variables: 
		someElements: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	an Announcer
		attributes: 	nil
		elements: 	an OrderedCollection()
		edges: 	an OrderedCollection()
		trCanvas: 	a TRCanvas
		lastEvent: 	a NewValueHolder[ nil ]


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		n: 	a RTMultiLinearColor
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	nil


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(370933760)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(370933760)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFr...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame...etc...
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#Spec...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayout...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFram...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame ...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	{#ContainerModel. #add:. {{#ContainerModel. #add:. {#(#model ...etc...
		index: 	4


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: ...etc...


--- The full stack ---
RTEllipse(Object)>>doesNotUnderstand: #do:
RTViewForSpec(RTView)>>addAll:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Node>>isNaN
8 December 2015 7:27:15.448541 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node(Object)>>doesNotUnderstand: #isNaN
	Receiver: a Node
	Arguments and temporary variables: 
		aMessage: 	isNaN
		exception: 	MessageNotUnderstood: Node>>isNaN
		resumeValue: 	nil
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/turtlesim'


RTMultiLinearColor>>level:
	Receiver: a RTMultiLinearColor
	Arguments and temporary variables: 
		f: 	a Node
		arr: 	nil
		c1: 	nil
		c2: 	nil
		nr: 	nil
		ng: 	nil
		nb: 	nil
		i1: 	nil
		i2: 	nil
		nbColors: 	nil
		ff: 	nil
	Receiver's instance variables: 
		command: 	#yourself
		colors: 	{(Color r: 0.969 g: 0.988 b: 0.9410000000000001 alpha: 1.0). (Color r: ...etc...


RTMultiLinearColor>>rtValue:
	Receiver: a RTMultiLinearColor
	Arguments and temporary variables: 
		anObject: 	a Node
		v: 	a Node
	Receiver's instance variables: 
		command: 	#yourself
		colors: 	{(Color r: 0.969 g: 0.988 b: 0.9410000000000001 alpha: 1.0). (Color r: ...etc...


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	a RTMultiLinearColor
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		n: 	a RTMultiLinearColor
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	nil


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	nil


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(748683264)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(748683264)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...


--- The full stack ---
Node(Object)>>doesNotUnderstand: #isNaN
RTMultiLinearColor>>level:
RTMultiLinearColor>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ZeroDivide
8 December 2015 7:38:46.618539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

SmallInteger>>/
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	0
	Receiver's instance variables: 
0

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(3 3)
		pubOrSub: 	'pub'
		min: 	3
		max: 	3
		num: 	nil
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/turtlesim'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(746061824)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(746061824)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
SmallInteger>>/
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Color>>r:g:b:alpha:
8 December 2015 7:41:29.828539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Color(Object)>>doesNotUnderstand: #r:g:b:alpha:
	Receiver: Color black
	Arguments and temporary variables: 
		aMessage: 	r: 0.5 g: 0.5 b: 0.5 alpha: 0.4
		exception: 	MessageNotUnderstood: Color>>r:g:b:alpha:
		resumeValue: 	nil
	Receiver's instance variables: 
		rgb: 	0
		cachedDepth: 	nil
		cachedBitPattern: 	nil
		alpha: 	255


Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(3 3)
		pubOrSub: 	'pub'
		min: 	3
		max: 	3
		num: 	0.5
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/turtlesim'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(540016640)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(540016640)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
Color(Object)>>doesNotUnderstand: #r:g:b:alpha:
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:43:05.966541 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
nodeC := node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		nodeC: 	nil
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
nodeC := node nodeColor: (self getMinMaxPubSub: nodeArray) with: sel...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	77
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
nodeC := node nodeColor: (self getM...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeC: 	nil
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(825491456)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(825491456)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
nodeC := node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: RTBox>>color:r:g:b:alpha:
8 December 2015 7:45:04.924545 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

RTBox(Object)>>doesNotUnderstand: #color:r:g:b:alpha:
	Receiver: a RTBox
	Arguments and temporary variables: 
		aMessage: 	color: Color r: 0.4 g: 0.5 b: 0.5 alpha: 0.4
		exception: 	MessageNotUnderstood: RTBox>>color:r:g:b:alpha:
		resumeValue: 	nil
	Receiver's instance variables: 
		color: 	Color veryVeryLightGray
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'v := RTView new.
n := RTMultiLinearColor new
colors: (ColorPal...etc...
		itsSelection: 	a Text for 'v := RTView new.
n := RTMultiLinearColor new
colors: ...etc...
		itsSelectionString: 	'v := RTView new.
n := RTMultiLinearColor new
colors: (Colo...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	v := RTView new.
	n := RTMultiLinearColor new colors: (ColorPalette ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(692322304)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(692322304)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(140509184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(692322304)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (285@240)
		owner: 	a TransformWithLayoutMorph(262406144)
		submorphs: 	an Array(a RubPrimarySelectionMorph(776208384) a RubCursor(52953088)...etc...
		fullBounds: 	(0@0) corner: (285@240)
		color: 	Color transparent
		extension: 	a MorphExtension (84672512) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(224133120)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(52953088)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(423624704))
		getMenuPolicy: 	a RubEditingArea(692322304)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(140509184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(166461440))(a SearchMorp...etc...
		lastStepTime: 	4536057
		lastStepMessage: 	nil
		lastCycleTime: 	4536055
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(52953088)))
		lastAlarmTime: 	4536057
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1003225088) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(166461440))(a SearchMorp...etc...
		lastStepTime: 	4536057
		lastStepMessage: 	nil
		lastCycleTime: 	4536055
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(52953088)))
		lastAlarmTime: 	4536057
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(166461440))(a SearchMorp...etc...
		lastStepTime: 	4536057
		lastStepMessage: 	nil
		lastCycleTime: 	4536055
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(52953088)))
		lastAlarmTime: 	4536057
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(1003225088) a N...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
RTBox(Object)>>doesNotUnderstand: #color:r:g:b:alpha:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:46:12.956541 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
nodeC := node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		nodeC: 	nil
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
nodeC := node nodeColor: (self getMinMaxPubSub: nodeArray) with: sel...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	77
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
nodeC := node nodeColor: (self getM...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeC: 	nil
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(896532480)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(896532480)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
nodeC := node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:47:37.648539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		nodeC: 	nil
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:sel...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	68
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
nodeC := node nodeColor	":(self get...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeC: 	nil
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(519307264)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(519307264)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:48:02.584539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		nodeC: 	Color red
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:sel...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	68
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
nodeC := node nodeColor	":(self get...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeC: 	Color red
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(519307264)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(519307264)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:48:19.030539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		nodeC: 	nil
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:sel...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	68
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
nodeC := node nodeColor	":(self get...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeC: 	nil
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:48:19.754539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		nodeC: 	Color red
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:sel...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	68
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
nodeC := node nodeColor	":(self get...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeC: 	Color red
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:48:25.268539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		nodeC: 	nil
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:sel...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	68
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
nodeC := node nodeColor	":(self get...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeC: 	nil
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:48:28.820539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		nodeC: 	nil
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:sel...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	68
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
nodeC := node nodeColor	":(self get...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeC: 	nil
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
nodeC := node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: false ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:48:47.856539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	64
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor	":(self getMinMaxPub...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:48:48.822538 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	64
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor	":(self getMinMaxPub...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(670040064)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
node nodeColor	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
a := hideMenu selectedItems collect: [ :item | item first ].
a do: [ :ele | self listChange: ele with: true ].
mainWindow graphUpdate ] in HideWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:49:33.126538 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
Color red	"node nodeColor"	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
Color red	"node nodeColor"	":(self getMinMaxPubSub: nodeArray) with:...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	68
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
Color red	"node nodeColor"	":(self ...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(631767040)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(631767040)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
Color red	"node nodeColor"	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:49:34.140539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
Color red	"node nodeColor"	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
Color red	"node nodeColor"	":(self getMinMaxPubSub: nodeArray) with:...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	68
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
Color red	"node nodeColor"	":(self ...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(631767040)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(631767040)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
Color red	"node nodeColor"	":(self getMinMaxPubSub: nodeArray) with:self pubOrSub " ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:52:43.678538 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(414187520)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(414187520)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:52:45.238539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(414187520)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(414187520)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:53:16.722539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	a MorphicAdapterBindings


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:53:17.982539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node)
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node)
		group: 	a RTGroup(a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node)
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node)
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node)
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: vie...etc...
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>initializeWidgets
		startpc: 	79
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>adapt:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


SpecInterpreter>>actionToPerformWithSelector:arguments:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		selector: 	#adapt:
		args: 	an Array(a RoassalModel)
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	an Array(a RoassalModel)
		numArgs: 	1
		selector: 	#adapt:
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RoassalModel
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		index: 	4


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#MorphicRoassalAdapter #adapt: #(#model))
		aModel: 	a RoassalModel
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter class>>private_buildWidgetFor:withSpec:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aComposableModel: 	a RoassalModel
		aSymbol: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aModel: 	a RoassalModel
		aSpec: 	#defaultSpec
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		aSpec: 	#defaultSpec
		adapter: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel(ComposableModel)>>private_buildWithSpec
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
self graphObj: Graph new.
self gra...etc...
		lastEvent: 	a NewValueHolder[ nil ]


SpecInterpreter>>returnInterpretationOf:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		newInstance: 	a RoassalModel
		result: 	a RoassalModel
		return: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aSelector: 	#defaultSpec
		newInstance: 	a RoassalModel
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#model #graph)
		index: 	3


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#model #graph)
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


SpecInterpreter>>computeSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aSymbol: 	#(#model #graph)
		aSelector: 	#defaultSpec
		instance: 	nil
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>retrieveSpecFrom:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter>>interpretASpec:model:selector:
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	nil
		arrayToInterpret: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction:...etc...
		index: 	nil


SpecInterpreter class>>private_interpretASpec:model:selector:
	Receiver: SpecInterpreter
	Arguments and temporary variables: 
		aPresenter: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #to...etc...
		aModel: 	a RQTGMainWindow
		aSelector: 	#defaultSpec
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #spec #arrayToInterpret #index)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpecInterpreter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		bindings: 	nil


[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
		each: 	#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFract...etc...
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2


Array(SequenceableCollection)>>collect:
	Receiver: #(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self class private_interpretASpec: each model: model selector...etc...
		newCollection: 	#(nil)
		index: 	1
	Receiver's instance variables: 
#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFraction: 0 #rightFr...etc...

SpecInterpreter>>performNextSelectorAndIncrementIndex
	Receiver: a SpecInterpreter
	Arguments and temporary variables: 
		args: 	#(#(#(#model #graph) #layout: #(#SpecLayoutFrame #leftFraction: 0 #topFra...etc...
		numArgs: 	1
		selector: 	#add:
	Receiver's instance variables: 
		model: 	a RQTGMainWindow
		spec: 	a SpecWrapper
		arrayToInterpret: 	#(#ContainerModel #add: #(#(#model #graph) #layout: #(#SpecLa...etc...
		index: 	2



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>initializeWidgets
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
RoassalModel(ComposableModel)>>privateAdapterFromModel:withSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec:
RoassalModel(ComposableModel)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
RQTGMainWindow(ComposableModel)>>adapterFrom:model:
RQTGMainWindow(ComposableModel)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:
DependentsArray>>do:
WindowModel(Object)>>changed:with:
WindowModel>>addModelIn:withSpecLayout:
WindowModel>>buildWithSpecLayout:
WindowModel>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpecLayout:
RQTGMainWindow(ComposableModel)>>openWithSpec:
RQTGMainWindow(ComposableModel)>>openWithSpec
PhaRos>>initialize
PhaRos class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:53:49.966539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self data: Adapter new getData.
self graphUpdate ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:53:51.164539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self data: Adapter new getData.
self graphUpdate ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:53:51.794539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self data: Adapter new getData.
self graphUpdate ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:53:52.642539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self data: Adapter new getData.
self graphUpdate ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:53:53.390539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self data: Adapter new getData.
self graphUpdate ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 7:53:54.03054 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSu...etc...
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	73
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | 
self halt.
node nodeColor: (self getMinMaxPubS...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
self graphObj: Graph new.
self graphObj createGra...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
[ :node | 
self halt.
node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self data: Adapter new getData.
self graphUpdate ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:00:51.466539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(27 27)
		pubOrSub: 	'pub'
		min: 	27
		max: 	27
		num: 	-25000.0
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/app_manager'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self data: Adapter new getData.
self graphUpdate ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:01:44.970539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	'pub'
		min: 	1
		max: 	27
		num: 	0.03846005922849121
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/app_manager'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'pub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(307232768)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self data: Adapter new getData.
self graphUpdate ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:11:48.676539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
	...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(796655616))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(796655616)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		event: 	[(393@171) mouseUp 6139779 nil]
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(642777088))
		fullBounds: 	(345@159) corner: (419@188)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(865075200)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(393@171) mouseUp 6139779 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
		m: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(642777088))
		fullBounds: 	(345@159) corner: (419@188)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(865075200)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(393@171) mouseUp 6139779 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(642777088))
		fullBounds: 	(345@159) corner: (419@188)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(865075200)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(393@171) mouseUp 6139779 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(642777088))
		fullBounds: 	(345@159) corner: (419@188)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(865075200)


MouseButtonEvent>>sentTo:
	Receiver: [(393@171) mouseUp 6139779 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		timeStamp: 	6139779
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(393@171)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(393@171) mouseUp 6139779 nil]
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(642777088))
		fullBounds: 	(345@159) corner: (419@188)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(865075200)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(393@171) mouseUp 6139779 nil]
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(642777088))
		fullBounds: 	(345@159) corner: (419@188)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(865075200)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(393@171) mouseUp 6139779 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(393@171.0) corner: (409@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(393@171.0) corner: (409@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(393@171) mouseOver nil nil]
		targetOffset: 	(48.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6139779 393 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(393@171) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(393@171) mouseUp 6139779 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(393@171.0) corner: (409@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(393@171.0) corner: (409@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(393@171) mouseOver nil nil]
		targetOffset: 	(48.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6139779 393 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(393@171) mouseUp 6139779 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(393@171.0) corner: (409@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(393@171.0) corner: (409@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(393@171) mouseOver nil nil]
		targetOffset: 	(48.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6139779 393 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(393@171) mouseUp 6139779 nil]
	Receiver's instance variables: 
		bounds: 	(393@171.0) corner: (409@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(393@171.0) corner: (409@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(393@171) mouseOver nil nil]
		targetOffset: 	(48.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6139779 393 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(393@171) mouseUp 6139779 nil]
		evt: 	[(393@171) mouseUp 6139779 nil]
	Receiver's instance variables: 
		bounds: 	(393@171.0) corner: (409@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(393@171.0) corner: (409@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(393@171) mouseOver nil nil]
		targetOffset: 	(48.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6139779 393 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(393@171) mouseUp 6139779 nil]
		evtBuf: 	#(1 6139779 393 171 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(393@171.0) corner: (409@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(393@171.0) corner: (409@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(393@171) mouseOver nil nil]
		targetOffset: 	(48.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6139779 393 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6139821
		lastStepMessage: 	nil
		lastCycleTime: 	6139821
		alarms: 	a Heap()
		lastAlarmTime: 	6139821
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6139821
		lastStepMessage: 	nil
		lastCycleTime: 	6139821
		alarms: 	a Heap()
		lastAlarmTime: 	6139821
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6139821
		lastStepMessage: 	nil
		lastCycleTime: 	6139821
		alarms: 	a Heap()
		lastAlarmTime: 	6139821
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6139821
		lastStepMessage: 	nil
		lastCycleTime: 	6139821
		alarms: 	a Heap()
		lastAlarmTime: 	6139821
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:12:30.960539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
	...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(796655616))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(796655616)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		event: 	[(381@174) mouseUp 6182067 nil]
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(760479744)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(381@174) mouseUp 6182067 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
		m: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(760479744)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(381@174) mouseUp 6182067 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(760479744)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(381@174) mouseUp 6182067 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(760479744)


MouseButtonEvent>>sentTo:
	Receiver: [(381@174) mouseUp 6182067 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		timeStamp: 	6182067
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(381@174)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(381@174) mouseUp 6182067 nil]
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(760479744)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(381@174) mouseUp 6182067 nil]
	Receiver's instance variables: 
		bounds: 	(345.0@159.0) corner: (419.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(760479744)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(381@174) mouseUp 6182067 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(381@174.0) corner: (397@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(381@174.0) corner: (397@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(381@174) mouseUp 6182067 nil]
		targetOffset: 	(36.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6182067 381 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(381@174) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(381@174) mouseUp 6182067 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(381@174.0) corner: (397@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(381@174.0) corner: (397@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(381@174) mouseUp 6182067 nil]
		targetOffset: 	(36.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6182067 381 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(381@174) mouseUp 6182067 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(381@174.0) corner: (397@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(381@174.0) corner: (397@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(381@174) mouseUp 6182067 nil]
		targetOffset: 	(36.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6182067 381 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(381@174) mouseUp 6182067 nil]
	Receiver's instance variables: 
		bounds: 	(381@174.0) corner: (397@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(381@174.0) corner: (397@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(381@174) mouseUp 6182067 nil]
		targetOffset: 	(36.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6182067 381 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(381@174) mouseUp 6182067 nil]
		evt: 	[(381@174) mouseUp 6182067 nil]
	Receiver's instance variables: 
		bounds: 	(381@174.0) corner: (397@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(381@174.0) corner: (397@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(381@174) mouseUp 6182067 nil]
		targetOffset: 	(36.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6182067 381 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(381@174) mouseUp 6182067 nil]
		evtBuf: 	#(1 6182067 381 174 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(381@174.0) corner: (397@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(381@174.0) corner: (397@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(381@174) mouseUp 6182067 nil]
		targetOffset: 	(36.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6182067 381 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6182049
		lastStepMessage: 	nil
		lastCycleTime: 	6182069
		alarms: 	a Heap()
		lastAlarmTime: 	6182049
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6182049
		lastStepMessage: 	nil
		lastCycleTime: 	6182069
		alarms: 	a Heap()
		lastAlarmTime: 	6182049
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6182049
		lastStepMessage: 	nil
		lastCycleTime: 	6182069
		alarms: 	a Heap()
		lastAlarmTime: 	6182049
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6182089
		lastStepMessage: 	nil
		lastCycleTime: 	6182089
		alarms: 	a Heap()
		lastAlarmTime: 	6182089
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:13:48.290539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
	...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(796655616))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(796655616)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		event: 	[(536@173) mouseUp 6259379 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(576716800))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(786956288)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(536@173) mouseUp 6259379 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
		m: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(576716800))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(786956288)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(536@173) mouseUp 6259379 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(576716800))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(786956288)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(536@173) mouseUp 6259379 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(576716800))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(786956288)


MouseButtonEvent>>sentTo:
	Receiver: [(536@173) mouseUp 6259379 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		timeStamp: 	6259379
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(536@173)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(536@173) mouseUp 6259379 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(576716800))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(786956288)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(536@173) mouseUp 6259379 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(576716800))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(786956288)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(536@173) mouseUp 6259379 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(536@173.0) corner: (552@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(536@173.0) corner: (552@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(536@173) mouseUp 6259379 nil]
		targetOffset: 	(57.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6259379 536 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(536@173) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(536@173) mouseUp 6259379 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(536@173.0) corner: (552@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(536@173.0) corner: (552@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(536@173) mouseUp 6259379 nil]
		targetOffset: 	(57.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6259379 536 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(536@173) mouseUp 6259379 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(536@173.0) corner: (552@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(536@173.0) corner: (552@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(536@173) mouseUp 6259379 nil]
		targetOffset: 	(57.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6259379 536 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(536@173) mouseUp 6259379 nil]
	Receiver's instance variables: 
		bounds: 	(536@173.0) corner: (552@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(536@173.0) corner: (552@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(536@173) mouseUp 6259379 nil]
		targetOffset: 	(57.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6259379 536 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(536@173) mouseUp 6259379 nil]
		evt: 	[(536@173) mouseUp 6259379 nil]
	Receiver's instance variables: 
		bounds: 	(536@173.0) corner: (552@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(536@173.0) corner: (552@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(536@173) mouseUp 6259379 nil]
		targetOffset: 	(57.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6259379 536 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(536@173) mouseUp 6259379 nil]
		evtBuf: 	#(1 6259379 536 173 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(536@173.0) corner: (552@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(536@173.0) corner: (552@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(536@173) mouseUp 6259379 nil]
		targetOffset: 	(57.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6259379 536 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6259417
		lastStepMessage: 	nil
		lastCycleTime: 	6259417
		alarms: 	a Heap()
		lastAlarmTime: 	6259417
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6259417
		lastStepMessage: 	nil
		lastCycleTime: 	6259417
		alarms: 	a Heap()
		lastAlarmTime: 	6259417
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6259417
		lastStepMessage: 	nil
		lastCycleTime: 	6259417
		alarms: 	a Heap()
		lastAlarmTime: 	6259417
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6259417
		lastStepMessage: 	nil
		lastCycleTime: 	6259417
		alarms: 	a Heap()
		lastAlarmTime: 	6259417
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a GLMSyst...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:14:29.038539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
	...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(796655616))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(796655616)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		event: 	[(567@172) mouseUp 6300139 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1066139648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(202637312)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(567@172) mouseUp 6300139 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
		m: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1066139648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(202637312)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(567@172) mouseUp 6300139 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1066139648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(202637312)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(567@172) mouseUp 6300139 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1066139648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(202637312)


MouseButtonEvent>>sentTo:
	Receiver: [(567@172) mouseUp 6300139 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		timeStamp: 	6300139
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(567@172)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(567@172) mouseUp 6300139 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1066139648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(202637312)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(567@172) mouseUp 6300139 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1066139648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(202637312)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(567@172) mouseUp 6300139 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(567@172.0) corner: (583@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(567@172.0) corner: (583@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(567@172) mouseUp 6300139 nil]
		targetOffset: 	(88.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6300139 567 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(567@172) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(567@172) mouseUp 6300139 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(567@172.0) corner: (583@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(567@172.0) corner: (583@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(567@172) mouseUp 6300139 nil]
		targetOffset: 	(88.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6300139 567 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(567@172) mouseUp 6300139 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(567@172.0) corner: (583@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(567@172.0) corner: (583@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(567@172) mouseUp 6300139 nil]
		targetOffset: 	(88.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6300139 567 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(567@172) mouseUp 6300139 nil]
	Receiver's instance variables: 
		bounds: 	(567@172.0) corner: (583@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(567@172.0) corner: (583@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(567@172) mouseUp 6300139 nil]
		targetOffset: 	(88.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6300139 567 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(567@172) mouseUp 6300139 nil]
		evt: 	[(567@172) mouseUp 6300139 nil]
	Receiver's instance variables: 
		bounds: 	(567@172.0) corner: (583@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(567@172.0) corner: (583@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(567@172) mouseUp 6300139 nil]
		targetOffset: 	(88.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6300139 567 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(567@172) mouseUp 6300139 nil]
		evtBuf: 	#(1 6300139 567 172 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(567@172.0) corner: (583@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(567@172.0) corner: (583@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(567@172) mouseUp 6300139 nil]
		targetOffset: 	(88.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6300139 567 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6300125
		lastStepMessage: 	nil
		lastCycleTime: 	6300147
		alarms: 	a Heap()
		lastAlarmTime: 	6300125
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6300125
		lastStepMessage: 	nil
		lastCycleTime: 	6300147
		alarms: 	a Heap()
		lastAlarmTime: 	6300125
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6300125
		lastStepMessage: 	nil
		lastCycleTime: 	6300147
		alarms: 	a Heap()
		lastAlarmTime: 	6300125
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6300125
		lastStepMessage: 	nil
		lastCycleTime: 	6300147
		alarms: 	a Heap()
		lastAlarmTime: 	6300125
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:14:37.282539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
	...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(796655616))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(796655616)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		event: 	[(521@171) mouseUp 6308387 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1030750208))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(185335808)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(521@171) mouseUp 6308387 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
		m: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1030750208))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(185335808)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(521@171) mouseUp 6308387 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1030750208))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(185335808)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(521@171) mouseUp 6308387 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1030750208))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(185335808)


MouseButtonEvent>>sentTo:
	Receiver: [(521@171) mouseUp 6308387 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		timeStamp: 	6308387
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(521@171)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(521@171) mouseUp 6308387 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1030750208))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(185335808)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(521@171) mouseUp 6308387 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(1030750208))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(185335808)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(521@171) mouseUp 6308387 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(521@171.0) corner: (537@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(521@171.0) corner: (537@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(521@171) mouseUp 6308387 nil]
		targetOffset: 	(42.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6308387 521 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(521@171) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(521@171) mouseUp 6308387 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(521@171.0) corner: (537@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(521@171.0) corner: (537@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(521@171) mouseUp 6308387 nil]
		targetOffset: 	(42.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6308387 521 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(521@171) mouseUp 6308387 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(521@171.0) corner: (537@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(521@171.0) corner: (537@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(521@171) mouseUp 6308387 nil]
		targetOffset: 	(42.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6308387 521 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(521@171) mouseUp 6308387 nil]
	Receiver's instance variables: 
		bounds: 	(521@171.0) corner: (537@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(521@171.0) corner: (537@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(521@171) mouseUp 6308387 nil]
		targetOffset: 	(42.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6308387 521 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(521@171) mouseUp 6308387 nil]
		evt: 	[(521@171) mouseUp 6308387 nil]
	Receiver's instance variables: 
		bounds: 	(521@171.0) corner: (537@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(521@171.0) corner: (537@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(521@171) mouseUp 6308387 nil]
		targetOffset: 	(42.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6308387 521 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(521@171) mouseUp 6308387 nil]
		evtBuf: 	#(1 6308387 521 171 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(521@171.0) corner: (537@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(521@171.0) corner: (537@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(521@171) mouseUp 6308387 nil]
		targetOffset: 	(42.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6308387 521 171 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6308369
		lastStepMessage: 	nil
		lastCycleTime: 	6308389
		alarms: 	a Heap()
		lastAlarmTime: 	6308369
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6308369
		lastStepMessage: 	nil
		lastCycleTime: 	6308389
		alarms: 	a Heap()
		lastAlarmTime: 	6308369
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6308369
		lastStepMessage: 	nil
		lastCycleTime: 	6308389
		alarms: 	a Heap()
		lastAlarmTime: 	6308369
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6308369
		lastStepMessage: 	nil
		lastCycleTime: 	6308389
		alarms: 	a Heap()
		lastAlarmTime: 	6308369
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:14:51.390539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
	...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(796655616))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(796655616)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		event: 	[(573@172) mouseUp 6322491 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(672923648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(919339008)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(573@172) mouseUp 6322491 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
		m: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(672923648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(919339008)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(573@172) mouseUp 6322491 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(672923648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(919339008)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(573@172) mouseUp 6322491 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(672923648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(919339008)


MouseButtonEvent>>sentTo:
	Receiver: [(573@172) mouseUp 6322491 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		timeStamp: 	6322491
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(573@172)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(573@172) mouseUp 6322491 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(672923648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(919339008)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(573@172) mouseUp 6322491 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(672923648))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(919339008)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(573@172) mouseUp 6322491 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(573@172.0) corner: (589@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(573@172.0) corner: (589@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(573@172) mouseUp 6322491 nil]
		targetOffset: 	(94.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6322491 573 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(573@172) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(573@172) mouseUp 6322491 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(573@172.0) corner: (589@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(573@172.0) corner: (589@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(573@172) mouseUp 6322491 nil]
		targetOffset: 	(94.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6322491 573 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(573@172) mouseUp 6322491 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(573@172.0) corner: (589@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(573@172.0) corner: (589@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(573@172) mouseUp 6322491 nil]
		targetOffset: 	(94.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6322491 573 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(573@172) mouseUp 6322491 nil]
	Receiver's instance variables: 
		bounds: 	(573@172.0) corner: (589@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(573@172.0) corner: (589@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(573@172) mouseUp 6322491 nil]
		targetOffset: 	(94.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6322491 573 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(573@172) mouseUp 6322491 nil]
		evt: 	[(573@172) mouseUp 6322491 nil]
	Receiver's instance variables: 
		bounds: 	(573@172.0) corner: (589@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(573@172.0) corner: (589@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(573@172) mouseUp 6322491 nil]
		targetOffset: 	(94.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6322491 573 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(573@172) mouseUp 6322491 nil]
		evtBuf: 	#(1 6322491 573 172 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(573@172.0) corner: (589@188.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(573@172.0) corner: (589@188.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(573@172) mouseUp 6322491 nil]
		targetOffset: 	(94.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6322491 573 172 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6322477
		lastStepMessage: 	nil
		lastCycleTime: 	6322497
		alarms: 	a Heap()
		lastAlarmTime: 	6322477
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6322477
		lastStepMessage: 	nil
		lastCycleTime: 	6322497
		alarms: 	a Heap()
		lastAlarmTime: 	6322477
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6322477
		lastStepMessage: 	nil
		lastCycleTime: 	6322497
		alarms: 	a Heap()
		lastAlarmTime: 	6322477
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6322477
		lastStepMessage: 	nil
		lastCycleTime: 	6322497
		alarms: 	a Heap()
		lastAlarmTime: 	6322477
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:15:17.524539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
	...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(796655616))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(796655616)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		event: 	[(548@168) mouseUp 6348611 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(414711808))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(624951296)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(548@168) mouseUp 6348611 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
		m: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(414711808))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(624951296)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(548@168) mouseUp 6348611 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(414711808))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(624951296)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(548@168) mouseUp 6348611 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(414711808))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(624951296)


MouseButtonEvent>>sentTo:
	Receiver: [(548@168) mouseUp 6348611 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		timeStamp: 	6348611
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(548@168)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(548@168) mouseUp 6348611 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(414711808))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(624951296)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(548@168) mouseUp 6348611 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(414711808))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(624951296)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(548@168) mouseUp 6348611 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(548@168.0) corner: (564@184.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(548@168.0) corner: (564@184.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@168) mouseUp 6348611 nil]
		targetOffset: 	(69.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6348611 548 168 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(548@168) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(548@168) mouseUp 6348611 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(548@168.0) corner: (564@184.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(548@168.0) corner: (564@184.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@168) mouseUp 6348611 nil]
		targetOffset: 	(69.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6348611 548 168 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(548@168) mouseUp 6348611 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(548@168.0) corner: (564@184.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(548@168.0) corner: (564@184.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@168) mouseUp 6348611 nil]
		targetOffset: 	(69.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6348611 548 168 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(548@168) mouseUp 6348611 nil]
	Receiver's instance variables: 
		bounds: 	(548@168.0) corner: (564@184.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(548@168.0) corner: (564@184.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@168) mouseUp 6348611 nil]
		targetOffset: 	(69.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6348611 548 168 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(548@168) mouseUp 6348611 nil]
		evt: 	[(548@168) mouseUp 6348611 nil]
	Receiver's instance variables: 
		bounds: 	(548@168.0) corner: (564@184.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(548@168.0) corner: (564@184.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@168) mouseUp 6348611 nil]
		targetOffset: 	(69.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6348611 548 168 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(548@168) mouseUp 6348611 nil]
		evtBuf: 	#(1 6348611 548 168 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(548@168.0) corner: (564@184.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(548@168.0) corner: (564@184.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@168) mouseUp 6348611 nil]
		targetOffset: 	(69.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6348611 548 168 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6348651
		lastStepMessage: 	nil
		lastCycleTime: 	6348651
		alarms: 	a Heap()
		lastAlarmTime: 	6348651
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6348651
		lastStepMessage: 	nil
		lastCycleTime: 	6348651
		alarms: 	a Heap()
		lastAlarmTime: 	6348651
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6348651
		lastStepMessage: 	nil
		lastCycleTime: 	6348651
		alarms: 	a Heap()
		lastAlarmTime: 	6348651
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6348651
		lastStepMessage: 	nil
		lastCycleTime: 	6348651
		alarms: 	a Heap()
		lastAlarmTime: 	6348651
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:15:26.256539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
	...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(796655616))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(796655616)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		event: 	[(523@175) mouseUp 6357355 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(715653120))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(962068480)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(523@175) mouseUp 6357355 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
		m: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(715653120))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(962068480)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848) a PluggableBut...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		evt: 	[(523@175) mouseUp 6357355 nil]
		all: 	an Array(a PluggableButtonMorph(98304000) a PluggableButtonMorph(849870848...etc...
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(715653120))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(962068480)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(523@175) mouseUp 6357355 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(715653120))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(962068480)


MouseButtonEvent>>sentTo:
	Receiver: [(523@175) mouseUp 6357355 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(796655616)
	Receiver's instance variables: 
		timeStamp: 	6357355
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(523@175)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(523@175) mouseUp 6357355 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(715653120))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(962068480)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(796655616)
	Arguments and temporary variables: 
		anEvent: 	[(523@175) mouseUp 6357355 nil]
	Receiver's instance variables: 
		bounds: 	(479.0@159.0) corner: (621.0@188.0)
		owner: 	a PanelMorph(270270464)
		submorphs: 	an Array(an AlignmentMorph(715653120))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (864026624) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(962068480)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@175) mouseUp 6357355 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(523@175.0) corner: (539@191.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@175.0) corner: (539@191.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@175) mouseUp 6357355 nil]
		targetOffset: 	(44.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6357355 523 175 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(523@175) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(523@175) mouseUp 6357355 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(523@175.0) corner: (539@191.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@175.0) corner: (539@191.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@175) mouseUp 6357355 nil]
		targetOffset: 	(44.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6357355 523 175 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@175) mouseUp 6357355 nil]
		focusHolder: 	a PluggableButtonMorph(796655616)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(523@175.0) corner: (539@191.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@175.0) corner: (539@191.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@175) mouseUp 6357355 nil]
		targetOffset: 	(44.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6357355 523 175 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@175) mouseUp 6357355 nil]
	Receiver's instance variables: 
		bounds: 	(523@175.0) corner: (539@191.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@175.0) corner: (539@191.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@175) mouseUp 6357355 nil]
		targetOffset: 	(44.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6357355 523 175 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@175) mouseUp 6357355 nil]
		evt: 	[(523@175) mouseUp 6357355 nil]
	Receiver's instance variables: 
		bounds: 	(523@175.0) corner: (539@191.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@175.0) corner: (539@191.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@175) mouseUp 6357355 nil]
		targetOffset: 	(44.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6357355 523 175 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(523@175) mouseUp 6357355 nil]
		evtBuf: 	#(1 6357355 523 175 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(523@175.0) corner: (539@191.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@175.0) corner: (539@191.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(796655616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@175) mouseUp 6357355 nil]
		targetOffset: 	(44.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6357355 523 175 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6357343
		lastStepMessage: 	nil
		lastCycleTime: 	6357363
		alarms: 	a Heap()
		lastAlarmTime: 	6357343
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6357343
		lastStepMessage: 	nil
		lastCycleTime: 	6357363
		alarms: 	a Heap()
		lastAlarmTime: 	6357343
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6357343
		lastStepMessage: 	nil
		lastCycleTime: 	6357363
		alarms: 	a Heap()
		lastAlarmTime: 	6357343
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(655097856))(a TRMorph(655097...etc...
		lastStepTime: 	6357343
		lastStepMessage: 	nil
		lastCycleTime: 	6357363
		alarms: 	a Heap()
		lastAlarmTime: 	6357343
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(366739456) a Nautilu...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteString>>ifTrue:ifFalse:
8 December 2015 8:17:01.244539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

ByteString(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 'sub'
	Arguments and temporary variables: 
		aMessage: 	ifTrue: self ifFalse: 3
		exception: 	MessageNotUnderstood: ByteString>>ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
'sub'

Node>>ExecuteUnOptimizedIn:
	Receiver: a Node
	Arguments and temporary variables: 
		t1: 	Node>>nodeColor:with:
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/app_manager'


ByteString(Object)>>mustBeBooleanInMagic:
	Receiver: 'sub'
	Arguments and temporary variables: 
		context: 	Node>>nodeColor:with:
		sendNode: 	RBMessageNode(pubOrSub
	ifTrue: [ num := (self pub size - min) * 1.0 ...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ (ThisContext namedTempAt: 2)
	...etc...
		method: 	Node>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
'sub'

ByteString(Object)>>mustBeBoolean
	Receiver: 'sub'
	Arguments and temporary variables: 

	Receiver's instance variables: 
'sub'

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(0 14)
		pubOrSub: 	'sub'
		min: 	0
		max: 	14
		num: 	nil
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/app_manager'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'sub'


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'sub'


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	'sub'


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(655097856)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(655097856)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(655097856)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
Node>>ExecuteUnOptimizedIn:
ByteString(Object)>>mustBeBooleanInMagic:
ByteString(Object)>>mustBeBoolean
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub = 'sub'
	ifTrue: [ 
		self graphObj pubOrSub: 'pub'.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: 'sub'.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:17:37.796539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub
	ifTrue: [ 
		self gr...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(309854208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(309854208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		event: 	[(562@173) mouseUp 6488891 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(958660608))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(52953088)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(562@173) mouseUp 6488891 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
		m: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(958660608))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(52953088)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(562@173) mouseUp 6488891 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(958660608))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(52953088)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(562@173) mouseUp 6488891 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(958660608))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(52953088)


MouseButtonEvent>>sentTo:
	Receiver: [(562@173) mouseUp 6488891 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		timeStamp: 	6488891
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(562@173)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(562@173) mouseUp 6488891 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(958660608))
		fullBounds: 	(488@159) corner: (634@188)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(52953088)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(562@173) mouseUp 6488891 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(958660608))
		fullBounds: 	(488@159) corner: (634@188)
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(52953088)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(562@173) mouseUp 6488891 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(562@173.0) corner: (578@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(562@173.0) corner: (578@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(562@173) mouseOver nil nil]
		targetOffset: 	(74.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6488891 562 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(562@173) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(562@173) mouseUp 6488891 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(562@173.0) corner: (578@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(562@173.0) corner: (578@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(562@173) mouseOver nil nil]
		targetOffset: 	(74.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6488891 562 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(562@173) mouseUp 6488891 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(562@173.0) corner: (578@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(562@173.0) corner: (578@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(562@173) mouseOver nil nil]
		targetOffset: 	(74.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6488891 562 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(562@173) mouseUp 6488891 nil]
	Receiver's instance variables: 
		bounds: 	(562@173.0) corner: (578@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(562@173.0) corner: (578@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(562@173) mouseOver nil nil]
		targetOffset: 	(74.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6488891 562 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(562@173) mouseUp 6488891 nil]
		evt: 	[(562@173) mouseUp 6488891 nil]
	Receiver's instance variables: 
		bounds: 	(562@173.0) corner: (578@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(562@173.0) corner: (578@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(562@173) mouseOver nil nil]
		targetOffset: 	(74.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6488891 562 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(562@173) mouseUp 6488891 nil]
		evtBuf: 	#(1 6488891 562 173 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(562@173.0) corner: (578@189.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(562@173.0) corner: (578@189.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(562@173) mouseOver nil nil]
		targetOffset: 	(74.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6488891 562 173 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(396623872))(a DropList...etc...
		lastStepTime: 	6488919
		lastStepMessage: 	nil
		lastCycleTime: 	6488919
		alarms: 	a Heap()
		lastAlarmTime: 	6488919
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(396623872))(a DropList...etc...
		lastStepTime: 	6488919
		lastStepMessage: 	nil
		lastCycleTime: 	6488919
		alarms: 	a Heap()
		lastAlarmTime: 	6488919
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(396623872))(a DropList...etc...
		lastStepTime: 	6488919
		lastStepMessage: 	nil
		lastCycleTime: 	6488919
		alarms: 	a Heap()
		lastAlarmTime: 	6488919
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(396623872))(a DropList...etc...
		lastStepTime: 	6488919
		lastStepMessage: 	nil
		lastCycleTime: 	6488919
		alarms: 	a Heap()
		lastAlarmTime: 	6488919
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:17:42.076539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub
	ifTrue: [ 
		self gr...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(309854208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(309854208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		event: 	[(534@174) mouseUp 6493171 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(742391808)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(534@174) mouseUp 6493171 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
		m: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(742391808)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(534@174) mouseUp 6493171 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(742391808)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(534@174) mouseUp 6493171 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(742391808)


MouseButtonEvent>>sentTo:
	Receiver: [(534@174) mouseUp 6493171 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		timeStamp: 	6493171
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(534@174)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(534@174) mouseUp 6493171 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(742391808)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(534@174) mouseUp 6493171 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(514064384))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(742391808)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(534@174) mouseUp 6493171 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(534@174.0) corner: (550@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(534@174.0) corner: (550@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(534@174) mouseUp 6493171 nil]
		targetOffset: 	(46.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6493171 534 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(534@174) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(534@174) mouseUp 6493171 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(534@174.0) corner: (550@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(534@174.0) corner: (550@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(534@174) mouseUp 6493171 nil]
		targetOffset: 	(46.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6493171 534 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(534@174) mouseUp 6493171 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(534@174.0) corner: (550@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(534@174.0) corner: (550@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(534@174) mouseUp 6493171 nil]
		targetOffset: 	(46.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6493171 534 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(534@174) mouseUp 6493171 nil]
	Receiver's instance variables: 
		bounds: 	(534@174.0) corner: (550@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(534@174.0) corner: (550@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(534@174) mouseUp 6493171 nil]
		targetOffset: 	(46.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6493171 534 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(534@174) mouseUp 6493171 nil]
		evt: 	[(534@174) mouseUp 6493171 nil]
	Receiver's instance variables: 
		bounds: 	(534@174.0) corner: (550@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(534@174.0) corner: (550@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(534@174) mouseUp 6493171 nil]
		targetOffset: 	(46.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6493171 534 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(534@174) mouseUp 6493171 nil]
		evtBuf: 	#(1 6493171 534 174 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(534@174.0) corner: (550@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(534@174.0) corner: (550@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(534@174) mouseUp 6493171 nil]
		targetOffset: 	(46.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6493171 534 174 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6493203
		lastStepMessage: 	nil
		lastCycleTime: 	6493203
		alarms: 	a Heap()
		lastAlarmTime: 	6493203
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6493203
		lastStepMessage: 	nil
		lastCycleTime: 	6493203
		alarms: 	a Heap()
		lastAlarmTime: 	6493203
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6493203
		lastStepMessage: 	nil
		lastCycleTime: 	6493203
		alarms: 	a Heap()
		lastAlarmTime: 	6493203
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6493203
		lastStepMessage: 	nil
		lastCycleTime: 	6493203
		alarms: 	a Heap()
		lastAlarmTime: 	6493203
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:11.976539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub
	ifTrue: [ 
		self gr...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(309854208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(309854208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		event: 	[(512@181) mouseUp 6523067 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(24641536))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(252968960)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(512@181) mouseUp 6523067 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
		m: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(24641536))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(252968960)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(512@181) mouseUp 6523067 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(24641536))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(252968960)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(512@181) mouseUp 6523067 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(24641536))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(252968960)


MouseButtonEvent>>sentTo:
	Receiver: [(512@181) mouseUp 6523067 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		timeStamp: 	6523067
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(512@181)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(512@181) mouseUp 6523067 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(24641536))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(252968960)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(512@181) mouseUp 6523067 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(24641536))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(252968960)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(512@181) mouseUp 6523067 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(512@181.0) corner: (528@197.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@181) mouseUp 6523067 nil]
		targetOffset: 	(24.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6523067 512 181 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(512@181) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(512@181) mouseUp 6523067 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(512@181.0) corner: (528@197.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@181) mouseUp 6523067 nil]
		targetOffset: 	(24.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6523067 512 181 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(512@181) mouseUp 6523067 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(512@181.0) corner: (528@197.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@181) mouseUp 6523067 nil]
		targetOffset: 	(24.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6523067 512 181 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(512@181) mouseUp 6523067 nil]
	Receiver's instance variables: 
		bounds: 	(512@181.0) corner: (528@197.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@181) mouseUp 6523067 nil]
		targetOffset: 	(24.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6523067 512 181 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(512@181) mouseUp 6523067 nil]
		evt: 	[(512@181) mouseUp 6523067 nil]
	Receiver's instance variables: 
		bounds: 	(512@181.0) corner: (528@197.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@181) mouseUp 6523067 nil]
		targetOffset: 	(24.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6523067 512 181 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(512@181) mouseUp 6523067 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(512@181) mouseUp 6523067 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a SpecWindow(5767168)
		clickState: 	#firstClickUp
		firstClickDown: 	[(512@181) mouseDown red 6522995 nil]
		firstClickUp: 	[(512@181) mouseUp 6523067 nil]
		firstClickTime: 	6522995
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	#doubleClickTimeout:
		dragSelector: 	#startDrag:
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(512@181) mouseUp 6523067 nil]
		evt: 	[(512@181) mouseUp 6523067 nil]
	Receiver's instance variables: 
		bounds: 	(512@181.0) corner: (528@197.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@181) mouseUp 6523067 nil]
		targetOffset: 	(24.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6523067 512 181 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(512@181) mouseUp 6523067 nil]
		evtBuf: 	#(1 6523067 512 181 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(512@181.0) corner: (528@197.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@181) mouseUp 6523067 nil]
		targetOffset: 	(24.0@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6523067 512 181 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6523061
		lastStepMessage: 	nil
		lastCycleTime: 	6523083
		alarms: 	a Heap()
		lastAlarmTime: 	6523061
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6523061
		lastStepMessage: 	nil
		lastCycleTime: 	6523083
		alarms: 	a Heap()
		lastAlarmTime: 	6523061
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6523061
		lastStepMessage: 	nil
		lastCycleTime: 	6523083
		alarms: 	a Heap()
		lastAlarmTime: 	6523061
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6523061
		lastStepMessage: 	nil
		lastCycleTime: 	6523083
		alarms: 	a Heap()
		lastAlarmTime: 	6523061
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:14.604539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub
	ifTrue: [ 
		self gr...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(309854208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(309854208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		event: 	[(523@174) mouseUp 6525707 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(464519168))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(632553472)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(523@174) mouseUp 6525707 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
		m: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(464519168))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(632553472)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(523@174) mouseUp 6525707 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(464519168))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(632553472)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(523@174) mouseUp 6525707 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(464519168))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(632553472)


MouseButtonEvent>>sentTo:
	Receiver: [(523@174) mouseUp 6525707 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		timeStamp: 	6525707
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(523@174)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(523@174) mouseUp 6525707 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(464519168))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(632553472)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(523@174) mouseUp 6525707 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(464519168))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(632553472)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@174) mouseUp 6525707 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(523@174.0) corner: (539@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@174.0) corner: (539@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@174) mouseUp 6525707 nil]
		targetOffset: 	(35.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6525707 523 174 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(523@174) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(523@174) mouseUp 6525707 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(523@174.0) corner: (539@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@174.0) corner: (539@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@174) mouseUp 6525707 nil]
		targetOffset: 	(35.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6525707 523 174 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@174) mouseUp 6525707 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(523@174.0) corner: (539@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@174.0) corner: (539@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@174) mouseUp 6525707 nil]
		targetOffset: 	(35.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6525707 523 174 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@174) mouseUp 6525707 nil]
	Receiver's instance variables: 
		bounds: 	(523@174.0) corner: (539@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@174.0) corner: (539@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@174) mouseUp 6525707 nil]
		targetOffset: 	(35.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6525707 523 174 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@174) mouseUp 6525707 nil]
		evt: 	[(523@174) mouseUp 6525707 nil]
	Receiver's instance variables: 
		bounds: 	(523@174.0) corner: (539@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@174.0) corner: (539@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@174) mouseUp 6525707 nil]
		targetOffset: 	(35.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6525707 523 174 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(523@174) mouseUp 6525707 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(523@174) mouseUp 6525707 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a SpecWindow(5767168)
		clickState: 	#firstClickUp
		firstClickDown: 	[(523@174) mouseDown red 6525635 nil]
		firstClickUp: 	[(523@174) mouseUp 6525707 nil]
		firstClickTime: 	6525635
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	#doubleClickTimeout:
		dragSelector: 	#startDrag:
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(523@174) mouseUp 6525707 nil]
		evt: 	[(523@174) mouseUp 6525707 nil]
	Receiver's instance variables: 
		bounds: 	(523@174.0) corner: (539@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@174.0) corner: (539@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@174) mouseUp 6525707 nil]
		targetOffset: 	(35.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6525707 523 174 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(523@174) mouseUp 6525707 nil]
		evtBuf: 	#(1 6525707 523 174 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(523@174.0) corner: (539@190.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(523@174.0) corner: (539@190.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(523@174) mouseUp 6525707 nil]
		targetOffset: 	(35.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6525707 523 174 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6525691
		lastStepMessage: 	nil
		lastCycleTime: 	6525711
		alarms: 	a Heap()
		lastAlarmTime: 	6525691
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6525691
		lastStepMessage: 	nil
		lastCycleTime: 	6525711
		alarms: 	a Heap()
		lastAlarmTime: 	6525691
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6525691
		lastStepMessage: 	nil
		lastCycleTime: 	6525711
		alarms: 	a Heap()
		lastAlarmTime: 	6525691
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6525691
		lastStepMessage: 	nil
		lastCycleTime: 	6525711
		alarms: 	a Heap()
		lastAlarmTime: 	6525691
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:25.350539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub
	ifTrue: [ 
		self gr...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(309854208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(309854208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		event: 	[(578@176) mouseUp 6536443 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(238288896))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(448528384)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(578@176) mouseUp 6536443 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
		m: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(238288896))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(448528384)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(578@176) mouseUp 6536443 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(238288896))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(448528384)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(578@176) mouseUp 6536443 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(238288896))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(448528384)


MouseButtonEvent>>sentTo:
	Receiver: [(578@176) mouseUp 6536443 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		timeStamp: 	6536443
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(578@176)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(578@176) mouseUp 6536443 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(238288896))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(448528384)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(578@176) mouseUp 6536443 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(238288896))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(448528384)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(578@176) mouseUp 6536443 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(578@176.0) corner: (594@192.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(578@176.0) corner: (594@192.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(578@176) mouseUp 6536443 nil]
		targetOffset: 	(90.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6536443 578 176 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(578@176) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(578@176) mouseUp 6536443 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(578@176.0) corner: (594@192.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(578@176.0) corner: (594@192.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(578@176) mouseUp 6536443 nil]
		targetOffset: 	(90.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6536443 578 176 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(578@176) mouseUp 6536443 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(578@176.0) corner: (594@192.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(578@176.0) corner: (594@192.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(578@176) mouseUp 6536443 nil]
		targetOffset: 	(90.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6536443 578 176 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(578@176) mouseUp 6536443 nil]
	Receiver's instance variables: 
		bounds: 	(578@176.0) corner: (594@192.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(578@176.0) corner: (594@192.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(578@176) mouseUp 6536443 nil]
		targetOffset: 	(90.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6536443 578 176 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(578@176) mouseUp 6536443 nil]
		evt: 	[(578@176) mouseUp 6536443 nil]
	Receiver's instance variables: 
		bounds: 	(578@176.0) corner: (594@192.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(578@176.0) corner: (594@192.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(578@176) mouseUp 6536443 nil]
		targetOffset: 	(90.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6536443 578 176 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(578@176) mouseUp 6536443 nil]
		evtBuf: 	#(1 6536443 578 176 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(578@176.0) corner: (594@192.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(578@176.0) corner: (594@192.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(578@176) mouseUp 6536443 nil]
		targetOffset: 	(90.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6536443 578 176 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6536437
		lastStepMessage: 	nil
		lastCycleTime: 	6536457
		alarms: 	a Heap()
		lastAlarmTime: 	6536437
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6536437
		lastStepMessage: 	nil
		lastCycleTime: 	6536457
		alarms: 	a Heap()
		lastAlarmTime: 	6536437
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6536437
		lastStepMessage: 	nil
		lastCycleTime: 	6536457
		alarms: 	a Heap()
		lastAlarmTime: 	6536437
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6536437
		lastStepMessage: 	nil
		lastCycleTime: 	6536457
		alarms: 	a Heap()
		lastAlarmTime: 	6536437
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:28.578539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub
	ifTrue: [ 
		self gr...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(309854208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(309854208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		event: 	[(605@170) mouseUp 6539667 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(38273024))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(206307328)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(605@170) mouseUp 6539667 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
		m: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(38273024))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(206307328)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(605@170) mouseUp 6539667 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(38273024))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(206307328)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(605@170) mouseUp 6539667 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(38273024))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(206307328)


MouseButtonEvent>>sentTo:
	Receiver: [(605@170) mouseUp 6539667 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		timeStamp: 	6539667
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(605@170)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(605@170) mouseUp 6539667 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(38273024))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(206307328)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(605@170) mouseUp 6539667 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(38273024))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(206307328)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(605@170) mouseUp 6539667 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(605@170.0) corner: (621@186.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(605@170.0) corner: (621@186.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(605@170) mouseUp 6539667 nil]
		targetOffset: 	(117.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6539667 605 170 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(605@170) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(605@170) mouseUp 6539667 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(605@170.0) corner: (621@186.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(605@170.0) corner: (621@186.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(605@170) mouseUp 6539667 nil]
		targetOffset: 	(117.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6539667 605 170 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(605@170) mouseUp 6539667 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(605@170.0) corner: (621@186.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(605@170.0) corner: (621@186.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(605@170) mouseUp 6539667 nil]
		targetOffset: 	(117.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6539667 605 170 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(605@170) mouseUp 6539667 nil]
	Receiver's instance variables: 
		bounds: 	(605@170.0) corner: (621@186.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(605@170.0) corner: (621@186.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(605@170) mouseUp 6539667 nil]
		targetOffset: 	(117.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6539667 605 170 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(605@170) mouseUp 6539667 nil]
		evt: 	[(605@170) mouseUp 6539667 nil]
	Receiver's instance variables: 
		bounds: 	(605@170.0) corner: (621@186.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(605@170.0) corner: (621@186.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(605@170) mouseUp 6539667 nil]
		targetOffset: 	(117.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6539667 605 170 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(605@170) mouseUp 6539667 nil]
		evtBuf: 	#(1 6539667 605 170 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(605@170.0) corner: (621@186.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(605@170.0) corner: (621@186.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(605@170) mouseUp 6539667 nil]
		targetOffset: 	(117.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6539667 605 170 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6539663
		lastStepMessage: 	nil
		lastCycleTime: 	6539685
		alarms: 	a Heap()
		lastAlarmTime: 	6539663
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6539663
		lastStepMessage: 	nil
		lastCycleTime: 	6539685
		alarms: 	a Heap()
		lastAlarmTime: 	6539663
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6539663
		lastStepMessage: 	nil
		lastCycleTime: 	6539685
		alarms: 	a Heap()
		lastAlarmTime: 	6539663
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6539663
		lastStepMessage: 	nil
		lastCycleTime: 	6539685
		alarms: 	a Heap()
		lastAlarmTime: 	6539663
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:48.232539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub
	ifTrue: [ 
		self gr...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(309854208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(309854208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		event: 	[(545@169) mouseUp 6559339 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(300154880))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(510394368)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(545@169) mouseUp 6559339 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
		m: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(300154880))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(510394368)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(545@169) mouseUp 6559339 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(300154880))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(510394368)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(545@169) mouseUp 6559339 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(300154880))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(510394368)


MouseButtonEvent>>sentTo:
	Receiver: [(545@169) mouseUp 6559339 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		timeStamp: 	6559339
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(545@169)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(545@169) mouseUp 6559339 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(300154880))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(510394368)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(545@169) mouseUp 6559339 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(300154880))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(510394368)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(545@169) mouseUp 6559339 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(545@169.0) corner: (561@185.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@169) mouseUp 6559339 nil]
		targetOffset: 	(57.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6559339 545 169 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(545@169) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(545@169) mouseUp 6559339 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(545@169.0) corner: (561@185.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@169) mouseUp 6559339 nil]
		targetOffset: 	(57.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6559339 545 169 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(545@169) mouseUp 6559339 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(545@169.0) corner: (561@185.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@169) mouseUp 6559339 nil]
		targetOffset: 	(57.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6559339 545 169 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(545@169) mouseUp 6559339 nil]
	Receiver's instance variables: 
		bounds: 	(545@169.0) corner: (561@185.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@169) mouseUp 6559339 nil]
		targetOffset: 	(57.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6559339 545 169 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(545@169) mouseUp 6559339 nil]
		evt: 	[(545@169) mouseUp 6559339 nil]
	Receiver's instance variables: 
		bounds: 	(545@169.0) corner: (561@185.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@169) mouseUp 6559339 nil]
		targetOffset: 	(57.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6559339 545 169 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(545@169) mouseUp 6559339 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(545@169) mouseUp 6559339 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a SpecWindow(5767168)
		clickState: 	#firstClickUp
		firstClickDown: 	[(545@169) mouseDown red 6559267 nil]
		firstClickUp: 	[(545@169) mouseUp 6559339 nil]
		firstClickTime: 	6559267
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	#doubleClickTimeout:
		dragSelector: 	#startDrag:
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(545@169) mouseUp 6559339 nil]
		evt: 	[(545@169) mouseUp 6559339 nil]
	Receiver's instance variables: 
		bounds: 	(545@169.0) corner: (561@185.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@169) mouseUp 6559339 nil]
		targetOffset: 	(57.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6559339 545 169 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(545@169) mouseUp 6559339 nil]
		evtBuf: 	#(1 6559339 545 169 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(545@169.0) corner: (561@185.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@169) mouseOver nil nil]
		targetOffset: 	(57.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6559339 545 169 0 0 0 1)
		lastKeyScanCode: 	19
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6559367
		lastStepMessage: 	nil
		lastCycleTime: 	6559361
		alarms: 	a Heap()
		lastAlarmTime: 	6559367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6559367
		lastStepMessage: 	nil
		lastCycleTime: 	6559361
		alarms: 	a Heap()
		lastAlarmTime: 	6559367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6559367
		lastStepMessage: 	nil
		lastCycleTime: 	6559361
		alarms: 	a Heap()
		lastAlarmTime: 	6559367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6559367
		lastStepMessage: 	nil
		lastCycleTime: 	6559361
		alarms: 	a Heap()
		lastAlarmTime: 	6559367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:49.900539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.19230029614245606
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/app_manager'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:57.81654 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.9999615399407714
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic a Topic a Topic a Topic a Topic a Topic a Top...etc...
		pub: 	an OrderedCollection(a Topic a Topic a Topic a Topic a Topic a Topic a Top...etc...
		show: 	true
		nodeName: 	'/mobile_base_nodelet_manager'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:58.612539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.03846005922849121
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic)
		show: 	true
		nodeName: 	'/robot_state_publisher'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:59.104539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.07692011845698242
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/interactions'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:18:59.650539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.07692011845698242
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/capability_server'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:00.106539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.03846005922849121
	Receiver's instance variables: 
		sub: 	an OrderedCollection()
		pub: 	an OrderedCollection(a Topic a Topic)
		show: 	true
		nodeName: 	'/master'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement)
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:00.546539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.07692011845698242
	Receiver's instance variables: 
		sub: 	an OrderedCollection()
		pub: 	an OrderedCollection(a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/zeroconf/zeroconf'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:01.012539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.07692011845698242
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/turtlesim'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	8
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:01.574539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.07692011845698242
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/diagnostic_aggregator'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	9
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:02.230539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.03846005922849121
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic)
		show: 	true
		nodeName: 	'/mobile_base'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	10
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:02.786539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.03846005922849121
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic)
		show: 	true
		nodeName: 	'/cmd_vel_mux'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	11
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:03.274539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.03846005922849121
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic a Topic)
		show: 	true
		nodeName: 	'/bumper2pointcloud'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	12
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:03.750539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.0
	Receiver's instance variables: 
		sub: 	an OrderedCollection()
		pub: 	an OrderedCollection(a Topic)
		show: 	true
		nodeName: 	'/capability_server_nodelet_manager'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	13
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:04.204539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.0
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic)
		pub: 	an OrderedCollection(a Topic)
		show: 	true
		nodeName: 	'/rosout'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	14
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup(a RTElement a RTElement a RTElement a RTElement a RTElement a ...etc...
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:07.496539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


ButtonModel>>performAction
	Receiver: a ButtonModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicButtonAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary(Character space->[ self action ] )
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Button' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		actionHolder: 	a NewValueHolder[ [ 
self graphObj pubOrSub
	ifTrue: [ 
		self gr...etc...
		labelHolder: 	a CollectionValueHolder[ 'Color by Subscribers' ]
		stateHolder: 	a NewValueHolder[ false ]
		actionPerformedHolder: 	a NewValueHolder[ nil ]
		askBeforeChangingHolder: 	a NewValueHolder[ false ]
		iconHolder: 	a NewValueHolder[ nil ]
		menuHolder: 	a NewValueHolder[ a MenuModel ]
		shortcutHolder: 	a NewValueHolder[ nil ]


MorphicButtonAdapter>>action
	Receiver: a MorphicButtonAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(309854208))
		model: 	a ButtonModel
		widget: 	a PluggableButtonMorph(309854208)
		selector: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		event: 	[(583@171) mouseUp 6578587 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(407896064))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(654311424)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(583@171) mouseUp 6578587 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
		m: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(407896064))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(654311424)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	3
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(338952192) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		evt: 	[(583@171) mouseUp 6578587 nil]
		all: 	an Array(a PluggableButtonMorph(527695872) a PluggableButtonMorph(33895219...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(407896064))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(654311424)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(583@171) mouseUp 6578587 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(407896064))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(654311424)


MouseButtonEvent>>sentTo:
	Receiver: [(583@171) mouseUp 6578587 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(309854208)
	Receiver's instance variables: 
		timeStamp: 	6578587
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(583@171)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(583@171) mouseUp 6578587 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(407896064))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(654311424)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(309854208)
	Arguments and temporary variables: 
		anEvent: 	[(583@171) mouseUp 6578587 nil]
	Receiver's instance variables: 
		bounds: 	(488.0@159.0) corner: (634.0@188.0)
		owner: 	a PanelMorph(819462144)
		submorphs: 	an Array(an AlignmentMorph(407896064))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (377225216) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MorphicButtonAdapter
		label: 	a Text for 'Color by Subscribers'
		getStateSelector: 	#state
		actionSelector: 	#action
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	a TextMorph(654311424)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(583@171) mouseUp 6578587 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(583@171.0) corner: (599@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(583@171.0) corner: (599@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(583@171) mouseUp 6578587 nil]
		targetOffset: 	(95.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6578587 583 171 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(583@171) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(583@171) mouseUp 6578587 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(583@171.0) corner: (599@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(583@171.0) corner: (599@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(583@171) mouseUp 6578587 nil]
		targetOffset: 	(95.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6578587 583 171 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(583@171) mouseUp 6578587 nil]
		focusHolder: 	a PluggableButtonMorph(309854208)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(583@171.0) corner: (599@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(583@171.0) corner: (599@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(583@171) mouseUp 6578587 nil]
		targetOffset: 	(95.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6578587 583 171 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(583@171) mouseUp 6578587 nil]
	Receiver's instance variables: 
		bounds: 	(583@171.0) corner: (599@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(583@171.0) corner: (599@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(583@171) mouseUp 6578587 nil]
		targetOffset: 	(95.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6578587 583 171 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(583@171) mouseUp 6578587 nil]
		evt: 	[(583@171) mouseUp 6578587 nil]
	Receiver's instance variables: 
		bounds: 	(583@171.0) corner: (599@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(583@171.0) corner: (599@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(583@171) mouseUp 6578587 nil]
		targetOffset: 	(95.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6578587 583 171 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(583@171) mouseUp 6578587 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(583@171) mouseUp 6578587 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a SpecWindow(5767168)
		clickState: 	#firstClickUp
		firstClickDown: 	[(583@171) mouseDown red 6578539 nil]
		firstClickUp: 	[(583@171) mouseUp 6578587 nil]
		firstClickTime: 	6578539
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	#doubleClickTimeout:
		dragSelector: 	#startDrag:
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(583@171) mouseUp 6578587 nil]
		evt: 	[(583@171) mouseUp 6578587 nil]
	Receiver's instance variables: 
		bounds: 	(583@171.0) corner: (599@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(583@171.0) corner: (599@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(583@171) mouseUp 6578587 nil]
		targetOffset: 	(95.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6578587 583 171 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(583@171) mouseUp 6578587 nil]
		evtBuf: 	#(1 6578587 583 171 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(583@171.0) corner: (599@187.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(583@171.0) corner: (599@187.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(309854208)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(583@171) mouseUp 6578587 nil]
		targetOffset: 	(95.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6578587 583 171 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6578581
		lastStepMessage: 	nil
		lastCycleTime: 	6578603
		alarms: 	a Heap()
		lastAlarmTime: 	6578581
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6578581
		lastStepMessage: 	nil
		lastCycleTime: 	6578603
		alarms: 	a Heap()
		lastAlarmTime: 	6578581
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6578581
		lastStepMessage: 	nil
		lastCycleTime: 	6578603
		alarms: 	a Heap()
		lastAlarmTime: 	6578581
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1855@1056)
		canvas: 	a FormCanvas on: DisplayScreen(1855x1056x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TRMorph(554172416))(a TRMorph(554172...etc...
		lastStepTime: 	6578581
		lastStepMessage: 	nil
		lastCycleTime: 	6578603
		alarms: 	a Heap()
		lastAlarmTime: 	6578581
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1855@1056)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(5767168) a NautilusW...etc...
		fullBounds: 	(0@0) corner: (1855@1056)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
8 December 2015 8:19:08.732539 pm

VM: unix - i686 - linux-gnu - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo4.0 [Latest update: #40623]

Node>>nodeColor:with:
	Receiver: a Node
	Arguments and temporary variables: 
		minAndMax: 	#(1 27)
		pubOrSub: 	true
		min: 	1
		max: 	27
		num: 	0.19230029614245606
	Receiver's instance variables: 
		sub: 	an OrderedCollection(a Topic a Topic)
		pub: 	an OrderedCollection(a Topic a Topic a Topic a Topic a Topic a Topic)
		show: 	true
		nodeName: 	'/app_manager'


[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		node: 	a Node
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


BlockClosure>>rtValue:
	Receiver: [ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ]
	Arguments and temporary variables: 
		valueOrArray: 	a Node
	Receiver's instance variables: 
		outerContext: 	Graph>>addNodesFrom:
		startpc: 	69
		numArgs: 	1


[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aValueOrAOneArgBlock: 	[ :node | node nodeColor: (self getMinMaxPubSub: nodeArra...etc...
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


BlockClosure>>rtValue:
	Receiver: [ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
	Arguments and temporary variables: 
		valueOrArray: 	a RTElement
	Receiver's instance variables: 
		outerContext: 	RTEllipse(RTShape)>>color:
		startpc: 	31
		numArgs: 	1


RTEllipse(RTShape)>>colorFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse>>updateFor:trachelShape:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
		ex: 	(50@50)
		rec: 	(-25@ -25) corner: (25@25)
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTEllipse(RTShape)>>trachelShapeFor:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		anElement: 	a RTElement
		trachelShape: 	a TREllipseShape
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


RTElement(RTShapedObject)>>addShape:
	Receiver: a RTElement
	Arguments and temporary variables: 
		aRTShape: 	a RTEllipse
	Receiver's instance variables: 
		announcer: 	nil
		attributes: 	nil
		isFixed: 	false
		model: 	a Node
		shape: 	a RTEllipse
		trachelShape: 	a TRNoShape
		view: 	nil
		connectedEdges: 	nil
		shouldUpdateEdges: 	true


RTEllipse(RTShape)>>elementOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		aModel: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
		m: 	a Node
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a Node a Node a Node...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | group add: (self elementOn: m) ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Node a Node a Node a Node a Node a Node a Node a Node a Node ...etc...
		firstIndex: 	1
		lastIndex: 	14


RTEllipse(RTShape)>>elementsOn:
	Receiver: a RTEllipse
	Arguments and temporary variables: 
		models: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a...etc...
		group: 	a RTGroup()
	Receiver's instance variables: 
		color: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		height: 	[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ]
		width: 	[ :anElement | aValueOrASymbolOrAOneArgBlock rtValue: anElement model ]
		borderColor: 	nil
		borderWidth: 	1


Graph>>addNodesFrom:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


Graph>>createGraph:withView:
	Receiver: a Graph
	Arguments and temporary variables: 
		nodeArray: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Nod...etc...
		aView: 	a RTViewForSpec
	Receiver's instance variables: 
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		view: 	a RTViewForSpec
		showNodeNames: 	true
		pubOrSub: 	true


[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
	Receiver: a RQTGMainWindow
	Arguments and temporary variables: 
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection()
		owner: 	nil
		window: 	a NewValueHolder[ a WindowModel ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'RQT-GraPharo' ]
		showName: 	a CheckBoxModel
		hideNodes: 	a ButtonModel
		hideTopics: 	a ButtonModel
		graph: 	a RoassalModel
		data: 	an OrderedCollection(a Node a Node a Node a Node a Node a Node a Node a N...etc...
		hide: 	a HideWindow
		graphObj: 	a Graph
		refresh: 	a ButtonModel
		colorBy: 	a ButtonModel


BlockClosure>>cull:cull:
	Receiver: [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ]
	Arguments and temporary variables: 
		firstArg: 	a RTViewForSpec
		secondArg: 	a TRCanvas
	Receiver's instance variables: 
		outerContext: 	RQTGMainWindow>>graphUpdate
		startpc: 	35
		numArgs: 	2


MorphicRoassalAdapter>>basicApplyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter>>applyScript
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


MorphicRoassalAdapter(AbstractAdapter)>>update:with:
	Receiver: a MorphicRoassalAdapter
	Arguments and temporary variables: 
		aSymbol: 	#applyScript
		anArray: 	#()
	Receiver's instance variables: 
		dependents: 	nil
		model: 	a RoassalModel
		widget: 	a TRMorph(554172416)
		selector: 	nil
		view: 	a RTViewForSpec
		canvas: 	a TRCanvas


[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
		aDependent: 	a MorphicRoassalAdapter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


DependentsArray>>do:
	Receiver: a DependentsArray(a MorphicRoassalAdapter)
	Arguments and temporary variables: 
		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicRoassalAdapter
		i: 	1
	Receiver's instance variables: 
a DependentsArray(a MorphicRoassalAdapter)

RoassalModel(Object)>>changed:with:
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		anAspect: 	#applyScript
		anObject: 	#()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


RoassalModel>>refresh
	Receiver: a RoassalModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


[ :s | self refresh ] in RoassalModel>>initialize
	Receiver: a RoassalModel
	Arguments and temporary variables: 
		s: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicRoassalAdapter)
		focusOrder: 	nil
		owner: 	a RQTGMainWindow
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		script: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj creat...etc...
		lastEvent: 	a NewValueHolder[ nil ]


BlockClosure>>cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		anArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


BlockClosure>>cull:cull:cull:cull:
	Receiver: [ :s | self refresh ]
	Arguments and temporary variables: 
		firstArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wit...etc...
		secondArg: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data wi...etc...
		thirdArg: 	a ValueChanged
		fourthArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	RoassalModel>>initialize
		startpc: 	48
		numArgs: 	1


[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
	Receiver: a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :s | self refresh ]
		block: 	nil
		announcement: 	a ValueChanged
		ann: 	an Announcer
	Receiver's instance variables: 
		announcer: 	an Announcer
		lock: 	true
		value: 	[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withVi...etc...


BlockClosure>>cull:cull:
	Receiver: [ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	...etc...
	Arguments and temporary variables: 
		firstArg: 	a ValueChanged
		secondArg: 	an Announcer
	Receiver's instance variables: 
		outerContext: 	NewValueHolder>>whenChangedDo:
		startpc: 	38
		numArgs: 	2


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	ValueChanged
		subscriber: 	a NewValueHolder[ [ :view :canvas | 
view cleanAll.
self graphObj c...etc...
		action: 	[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: anno...etc...


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a ValueChanged
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
		monitor: 	a Semaphore()



--- The full stack ---
Node>>nodeColor:with:
[ :node | node nodeColor: (self getMinMaxPubSub: nodeArray) with: self pubOrSub ] in Graph>>addNodesFrom:
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTEllipse(RTShape)>>color:
BlockClosure>>rtValue:
RTEllipse(RTShape)>>colorFor:
RTEllipse>>updateFor:trachelShape:
RTEllipse(RTShape)>>trachelShapeFor:
RTElement(RTShapedObject)>>addShape:
RTEllipse(RTShape)>>elementOn:
[ :m | group add: (self elementOn: m) ] in RTEllipse(RTShape)>>elementsOn:
OrderedCollection>>do:
RTEllipse(RTShape)>>elementsOn:
Graph>>addNodesFrom:
Graph>>createGraph:withView:
[ :view :canvas | 
view cleanAll.
self graphObj createGraph: data withView: view ] in RQTGMainWindow>>graphUpdate
BlockClosure>>cull:cull:
MorphicRoassalAdapter>>basicApplyScript
MorphicRoassalAdapter>>applyScript
MorphicRoassalAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in RoassalModel(Object)>>changed:with:
DependentsArray>>do:
RoassalModel(Object)>>changed:with:
RoassalModel>>refresh
[ :s | self refresh ] in RoassalModel>>initialize
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SubscriptionRegistry>>deliver:
Announcer>>announce:
NewValueHolder>>valueChanged:
[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:
BlockClosure>>ensure:
NewValueHolder>>handleCircularReferencesWhile:
NewValueHolder>>value:
RoassalModel>>script:
RQTGMainWindow>>graphUpdate
[ 
self graphObj pubOrSub
	ifTrue: [ 
		self graphObj pubOrSub: true.
		colorBy label: 'Color by Subscribers'.
		self halt.
		self graphUpdate ]
	ifFalse: [ 
		self graphObj pubOrSub: false.
		colorBy label: 'Color by Publishers'.
		self graphUpdate ] ] in RQTGMainWindow>>initializePresenter
ButtonModel>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

